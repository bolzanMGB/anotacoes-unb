{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Anota\u00e7\u00f5es UnB","text":"<p>Bem-vindo(a)! </p> <p>Este site re\u00fane algumas das anota\u00e7\u00f5es e resumos feitos por mim, Othavio Bolzan, ao longo da minha gradua\u00e7\u00e3o em Engenharia de Software na Universidade de Bras\u00edlia (UnB). As anota\u00e7\u00f5es foram originalmente escritas no Notion e depois organizadas aqui com o aux\u00edlio do MkDocs, para facilitar a navega\u00e7\u00e3o e a consulta.</p> <p>Aviso: Durante a migra\u00e7\u00e3o, pode ser que algumas anota\u00e7\u00f5es contenham erros de digita\u00e7\u00e3o, formata\u00e7\u00e3o ou pequenos enganos de conte\u00fado. Caso encontre algo, considere que o material n\u00e3o substitui livros ou aulas, mas serve como apoio de estudos.</p>"},{"location":"disciplinas/EDA1/alocacao/","title":"Aloca\u00e7\u00e3o de Mem\u00f3ria em C","text":""},{"location":"disciplinas/EDA1/alocacao/#1-tipos-de-espaco-de-enderecos","title":"1. Tipos de Espa\u00e7o de Endere\u00e7os","text":"<p>A mem\u00f3ria de um processo \u00e9 dividida em segmentos distintos, cada um com prop\u00f3sito espec\u00edfico:</p> <ul> <li> <p>Text: cont\u00e9m o c\u00f3digo do programa e suas constantes. Este segmento \u00e9 alocado durante a cria\u00e7\u00e3o do processo (<code>exec</code>) e permanece do mesmo tamanho durante toda a vida do processo.</p> </li> <li> <p>Data: este segmento \u00e9 a mem\u00f3ria de trabalho do processo, onde ficam alocadas as vari\u00e1veis globais e est\u00e1ticas. Tem tamanho fixo ao longo da execu\u00e7\u00e3o do processo.</p> </li> <li> <p>Stack: cont\u00e9m a pilha de execu\u00e7\u00e3o, onde s\u00e3o armazenadas os par\u00e2metros, endere\u00e7os de retorno e vari\u00e1veis locais de fun\u00e7\u00f5es. Pode variar de tamanho durante a execu\u00e7\u00e3o do processo.</p> </li> <li> <p>Heap: cont\u00e9m blocos de mem\u00f3ria alocadas dinamicamente, a pedido do processo, durante sua execu\u00e7\u00e3o. Varia de tamanho durante a vida do processo. Gerenciado pelo sistema operacional.</p> </li> </ul>"},{"location":"disciplinas/EDA1/alocacao/#2-tipos-de-alocacao-de-memoria","title":"2. Tipos de Aloca\u00e7\u00e3o de Mem\u00f3ria","text":""},{"location":"disciplinas/EDA1/alocacao/#21-alocacao-estatica","title":"2.1 Aloca\u00e7\u00e3o Est\u00e1tica","text":"<ul> <li>Ocorre quando s\u00e3o declaradas vari\u00e1veis globais (alocadas fora de fun\u00e7\u00f5es) ou est\u00e1ticas (usando o modificador <code>static</code>)</li> <li>Geralmente alocadas em Data</li> <li>Uma vari\u00e1vel alocada estaticamente mant\u00e9m seu valor durante toda a vida do programa, exceto quando explicitamente modificada</li> </ul>"},{"location":"disciplinas/EDA1/alocacao/#22-alocacao-automatica","title":"2.2 Aloca\u00e7\u00e3o Autom\u00e1tica","text":"<ul> <li>Ocorre quando s\u00e3o declaradas vari\u00e1veis locais e par\u00e2metros de fun\u00e7\u00f5es</li> <li>Geralmente \u00e9 usada a pilha (stack)</li> <li>O espa\u00e7o para a aloca\u00e7\u00e3o dessas vari\u00e1veis \u00e9 reservado de forma autom\u00e1tica na pilha de execu\u00e7\u00e3o do programa a cada chamada da fun\u00e7\u00e3o, e liberado quando a fun\u00e7\u00e3o termina</li> <li>Aloca\u00e7\u00e3o e desaloca\u00e7\u00e3o autom\u00e1tica (SO \u2014 sistema operacional)</li> </ul>"},{"location":"disciplinas/EDA1/alocacao/#23-alocacao-dinamica","title":"2.3 Aloca\u00e7\u00e3o Din\u00e2mica","text":"<ul> <li>O programa solicita explicitamente \u00e1reas de mem\u00f3ria ao sistema operacional, as utiliza e depois as libera quando n\u00e3o forem mais necess\u00e1rias</li> <li>O controle das \u00e1reas alocadas dinamicamente \u00e9 manual: o programador \u00e9 respons\u00e1vel por liberar as \u00e1reas alocadas</li> <li>Geralmente alocadas na \u00e1rea de mem\u00f3ria heap</li> <li>Permite alocar mem\u00f3ria durante a execu\u00e7\u00e3o do programa</li> <li>Permite alocar tamanhos maiores que a \u00e1rea reservada na stack Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nint a = 0;  // vari\u00e1vel global, aloc. est\u00e1tica\n\nvoid incrementa(void)\n{\n    int b = 0;        // vari\u00e1vel local, aloc. autom\u00e1tica\n    static int c = 0; // vari\u00e1vel local, aloc. est\u00e1tica\n\n    printf(\"a: %d, b: %d, c: %d\\n\", a, b, c);\n    a++;\n    b++;\n    c++;\n}\n\nint main(void)\n{\n    int i;\n\n    for (i = 0; i &lt; 5; i++)\n        incrementa();\n\n    return 0;\n}\n</code></pre></li> </ul>"},{"location":"disciplinas/EDA1/alocacao/#3-operadores-e-funcoes-para-alocacao-dinamica","title":"3. Operadores e Fun\u00e7\u00f5es para Aloca\u00e7\u00e3o Din\u00e2mica","text":""},{"location":"disciplinas/EDA1/alocacao/#31-sizeof","title":"3.1 sizeof()","text":"<p>Retorna o tamanho em bytes de um tipo de dado ou estrutura</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nstruct endereco {\n    char rua[100];\n    int numero;\n};\n\nint main() {\n    printf(\"%lu bytes \\n\", sizeof(int)); // 4 bytes\n    printf(\"%lu bytes \\n\", sizeof(float)); // 4 bytes\n    printf(\"%lu bytes \\n\", sizeof(double)); // 8 bytes\n    printf(\"%lu bytes \\n\", sizeof(char)); // 1 byte\n    printf(\"%lu bytes \\n\", sizeof(struct endereco)); // 104 bytes\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/alocacao/#32-malloc","title":"3.2 malloc()","text":"<p>Aloca uma quantidade espec\u00edfica de bytes na mem\u00f3ria heap</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = (int *)malloc(sizeof(int)); // Aloca espa\u00e7o para um inteiro\n    if (p == NULL) {\n        printf(\"Falha na aloca\u00e7\u00e3o de mem\u00f3ria!\\n\");\n        return 1;\n    }\n\n    *p = 42;\n    printf(\"Valor: %d\\n\", *p);\n\n    free(p); // Libera a mem\u00f3ria alocada\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/alocacao/#33-calloc","title":"3.3 calloc()","text":"<p>Aloca mem\u00f3ria para um array de elementos, inicializando todos os bytes com zero</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = calloc(5, sizeof(int)); // Aloca array de 5 inteiros (todos zeros)\n    if (p == NULL) {\n        printf(\"Falha na aloca\u00e7\u00e3o de mem\u00f3ria!\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"p[%d] = %d\\n\", i, p[i]); // Todos ser\u00e3o zero\n    }\n\n    free(p); // Libera a mem\u00f3ria alocada\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/alocacao/#34-realloc","title":"3.4 realloc()","text":"<p>Altera o tamanho do bloco de mem\u00f3ria apontado por um ponteiro</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int)); // Aloca espa\u00e7o para 1 inteiro\n    *p = 10;\n\n    p = realloc(p, 4 * sizeof(int)); // Redimensiona para 4 inteiros\n\n    p[1] = 20;\n    p[2] = 30;\n    p[3] = 40;\n\n    for (int i = 0; i &lt; 4; i++) {\n        printf(\"p[%d] = %d\\n\", i, p[i]);\n    }\n\n    free(p); // Libera a mem\u00f3ria alocada\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/alocacao/#35-free","title":"3.5 free()","text":"<p>Libera o espa\u00e7o de mem\u00f3ria apontado por um ponteiro previamente alocado</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(10 * sizeof(int)); // Aloca array de 10 inteiros\n\n    if (p != NULL) {\n        for (int i = 0; i &lt; 10; i++) {\n            p[i] = i * 10;\n        }\n\n        // Usa o array...\n\n        free(p); // Libera a mem\u00f3ria quando n\u00e3o for mais necess\u00e1ria\n        p = NULL; // Boa pr\u00e1tica: definir ponteiro como NULL ap\u00f3s liberar\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/alocacao/#4-boas-praticas-com-alocacao-dinamica","title":"4. Boas Pr\u00e1ticas com Aloca\u00e7\u00e3o Din\u00e2mica","text":"<ol> <li>Sempre verifique se a aloca\u00e7\u00e3o foi bem-sucedida (ponteiro != NULL)</li> <li>Sempre libere a mem\u00f3ria alocada quando n\u00e3o for mais necess\u00e1ria</li> <li>Defina ponteiros como NULL ap\u00f3s liberar a mem\u00f3ria para evitar \"dangling pointers\"</li> <li>Evite vazamentos de mem\u00f3ria - toda mem\u00f3ria alocada deve ser liberada</li> <li>Use free() apenas com ponteiros que foram alocados com malloc, calloc ou realloc</li> </ol> Exemplo de uso correto:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *array = NULL;\n    int tamanho = 5;\n\n    // Aloca mem\u00f3ria\n    array = (int *)malloc(tamanho * sizeof(int));\n    if (array == NULL) {\n        printf(\"Erro: n\u00e3o foi poss\u00edvel alocar mem\u00f3ria!\\n\");\n        return 1;\n    }\n\n    // Usa a mem\u00f3ria alocada\n    for (int i = 0; i &lt; tamanho; i++) {\n        array[i] = i * 2;\n    }\n\n    // Libera a mem\u00f3ria quando n\u00e3o for mais necess\u00e1ria\n    free(array);\n    array = NULL; // Boa pr\u00e1tica\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/","title":"An\u00e1lise de Complexidade de Algoritmos","text":""},{"location":"disciplinas/EDA1/complexidade/#1-definicao","title":"1. Defini\u00e7\u00e3o","text":"<p>A an\u00e1lise de complexidade estuda o consumo de recursos (tempo e espa\u00e7o) de um algoritmo em rela\u00e7\u00e3o ao tamanho da entrada. </p> <p>A complexidade \u00e9 expressa usando a nota\u00e7\u00e3o O (Big O), que descreve o comportamento assint\u00f3tico do algoritmo.</p>"},{"location":"disciplinas/EDA1/complexidade/#2-classes-de-complexidade","title":"2. Classes de Complexidade","text":""},{"location":"disciplinas/EDA1/complexidade/#21-complexidade-constante-o1","title":"2.1 Complexidade Constante - O(1)","text":"<p>O tempo de execu\u00e7\u00e3o n\u00e3o depende do tamanho da entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#211-caracteristicas","title":"2.1.1 Caracter\u00edsticas","text":"<ul> <li>Instru\u00e7\u00f5es s\u00e3o realizadas um n\u00famero fixo de vezes;</li> <li>Opera\u00e7\u00f5es b\u00e1sicas: atribui\u00e7\u00e3o, compara\u00e7\u00e3o, acesso a \u00edndice;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#212-quando-ocorrre","title":"2.1.2 Quando ocorrre","text":"<ul> <li>Acesso a elementos em arrays est\u00e1ticos;</li> <li>Opera\u00e7\u00f5es em listas duplamente encadeadas: remo\u00e7\u00e3o, inser\u00e7\u00e3o ap\u00f3s/before um n\u00f3;</li> <li>Opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas;</li> </ul> Exemplo:<pre><code>int operacao(int n, int a, char op) {\n    int r = 0; // O(1) - atribui\u00e7\u00e3o\n\n    if (op == '+')      // O(1) - compara\u00e7\u00e3o\n        r = n + a;      // O(1) - aritm\u00e9tica + atribui\u00e7\u00e3o\n    else if (op == '-') // O(1) - compara\u00e7\u00e3o\n        r = n - a;      // O(1) - aritm\u00e9tica + atribui\u00e7\u00e3o\n    else if (op == '*') // O(1) - compara\u00e7\u00e3o\n        r = n * a;      // O(1) - aritm\u00e9tica + atribui\u00e7\u00e3o\n\n    return r;           // O(1) - retorno\n}\n// Complexidade total: O(1)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#22-complexidade-linear-on","title":"2.2 Complexidade Linear - O(n)","text":"<p>O tempo de execu\u00e7\u00e3o cresce linearmente com o tamanho da entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#221-caracteristicas","title":"2.2.1 Caracter\u00edsticas","text":"<ul> <li>Percorre cada elemento da entrada uma vez</li> <li>Cresce a uma taxa constante</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#222-quando-ocorrre","title":"2.2.2 Quando ocorrre","text":"<ul> <li>Busca sequencial em array n\u00e3o ordenado</li> <li>Remo\u00e7\u00e3o de n\u00f3 espec\u00edfico em lista simplesmente encadeada</li> <li>Fatorial por recurs\u00e3o (chamadas lineares)</li> </ul> Exemplo:<pre><code>int pesquisa(int x, int n, int v[]) {\n    for (int i = 0; i &lt; n &amp;&amp; v[i] != x; i = i + 1); // O(n) - loop\n    return i; // O(1)\n}\n// Complexidade total: O(n)\n\n// Fatorial recursivo - O(n) linear\nint fat(int n) {\n    if (n == 0) return 1;        // O(1)\n    return n * fat(n - 1);       // n chamadas recursivas\n}\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#23-complexidade-quadratica-on2","title":"2.3 Complexidade Quadr\u00e1tica - O(n\u00b2)","text":"<p>O tempo de execu\u00e7\u00e3o cresce proporcionalmente ao quadrado do tamanho da entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#231-caracteristicas","title":"2.3.1 Caracter\u00edsticas","text":"<ul> <li>Dois loops aninhados, cada um percorrendo n elementos;</li> <li>Comum em algoritmos de ordena\u00e7\u00e3o simples;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#232-quando-ocorrre","title":"2.3.2 Quando ocorrre","text":"<ul> <li>Bubble Sort, Selection Sort, Insertion Sort;</li> <li>Compara\u00e7\u00e3o de todos os pares em um conjunto;</li> </ul> Exemplo:<pre><code>void ordenacao(int v[], int n) {\n    for (int i = 1; i &lt; n; i++) {           // O(n)\n        for (int j = i; j &gt; 0 &amp;&amp; v[j] &lt; v[j - 1]; j--) { // O(n)\n            troca(v[j], v[j - 1]);          // O(1) - opera\u00e7\u00e3o constante\n        }\n    }\n}\n// Complexidade total: O(n\u00b2)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#24-complexidade-cubica-on3","title":"2.4 Complexidade C\u00fabica - O(n\u00b3)","text":"<p>O tempo de execu\u00e7\u00e3o cresce proporcionalmente ao cubo do tamanho da entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#241-caracteristicas","title":"2.4.1 Caracter\u00edsticas","text":"<ul> <li>Tr\u00eas loops aninhados, cada um percorrendo n elementos;</li> <li>Comum em opera\u00e7\u00f5es com matrizes;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#242-quando-ocorrre","title":"2.4.2 Quando ocorrre","text":"<ul> <li>Multiplica\u00e7\u00e3o de matrizes n \u00d7 n;</li> <li>Algoritmos que processam dados tridimensionais;</li> </ul> Exemplo:<pre><code>void multiplica_matrizes(int A[3][3], int B[3][3], int C[3][3]) {\n    for (int i = 0; i &lt; 3; i++) {           // O(n)\n        for (int j = 0; j &lt; 3; j++) {       // O(n)\n            C[i][j] = 0;                    // O(1)\n            for (int k = 0; k &lt; 3; k++) {   // O(n)\n                C[i][j] += A[i][k] * B[k][j]; // O(1)\n            }\n        }\n    }\n}\n// Complexidade total: O(n\u00b3)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#25-complexidade-exponencial-okn","title":"2.5 Complexidade Exponencial - O(k\u207f)","text":"<p>O tempo de execu\u00e7\u00e3o dobra (ou multiplica por k) a cada aumento unit\u00e1rio na entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#251-caracteristicas","title":"2.5.1 Caracter\u00edsticas","text":"<ul> <li>M\u00faltiplas chamadas recursivas em cada passo;</li> <li>Extremamente ineficiente para entradas grandes;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#252-quando-ocorrre","title":"2.5.2 Quando ocorrre","text":"<ul> <li>Fibonacci recursivo ing\u00eanuo;</li> <li>Problema da mochila (for\u00e7a bruta);</li> <li>Torre de Hanoi;</li> </ul> Exemplo:<pre><code>// Fibonacci recursivo - O(2\u207f)\nint fib(int n) {\n    if (n == 0 || n == 1) return n;         // O(1)\n    return fib(n - 2) + fib(n - 2);         // 2 chamadas recursivas\n}\n\n// Gera\u00e7\u00e3o de permuta\u00e7\u00f5es - O(n!)\nvoid anagram(char str[], int k) {\n    int len = strlen(str);                  // O(n)\n    if (k == len)                           // O(1)\n        printf(\"%s\\n\", str);                // O(n)\n    else {\n        for (int i = k; i &lt; len; i++) {     // O(n)\n            swap_char(str, k, i);           // O(1)\n            anagram(str, k + 1);            // Chamada recursiva\n            swap_char(str, i, k);           // O(1)\n        }\n    }\n}\n// Rela\u00e7\u00e3o de recorr\u00eancia: T(n) = n \u00d7 T(n-1) = O(n!)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#26-complexidade-logaritmica-olog-n","title":"2.6 Complexidade Logar\u00edtmica - O(log n)","text":"<p>O tempo de execu\u00e7\u00e3o cresce logarithmicamente com o tamanho da entrada.</p>"},{"location":"disciplinas/EDA1/complexidade/#261-caracteristicas","title":"2.6.1 Caracter\u00edsticas","text":"<ul> <li>Inversa da fun\u00e7\u00e3o exponencial;</li> <li>Muito eficiente para grandes entradas;</li> <li>Divide o problema pela metade a cada passo;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#262-quando-ocorrre","title":"2.6.2 Quando ocorrre","text":"<ul> <li>Busca bin\u00e1ria em array ordenado;</li> <li>Opera\u00e7\u00f5es em \u00e1rvores bin\u00e1rias balanceadas;</li> </ul> Exemplo:<pre><code>int pesquisa(int x, int v[], int esq, int dir) {\n    if (esq &gt; dir) return -1;               // O(1)\n\n    int meio = (esq + dir) / 2;             // O(1)\n\n    if (v[meio] == x) return meio;          // O(1)\n    else if (v[meio] &lt; x)\n        return pesquisa(x, v, meio + 1, dir); // T(n/2)\n    else\n        return pesquisa(x, v, esq, meio - 1); // T(n/2)\n}\n// Rela\u00e7\u00e3o de recorr\u00eancia: T(n) = T(n/2) + O(1) = O(log n)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#27-complexidade-linearitmica-on-log-n","title":"2.7 Complexidade Linear\u00edtmica - O(n log n)","text":"<p>Combina caracter\u00edsticas lineares e logar\u00edtmicas.</p>"},{"location":"disciplinas/EDA1/complexidade/#271-caracteristicas","title":"2.7.1 Caracter\u00edsticas","text":"<ul> <li>Divide e conquista: quebra problemas em subproblemas menores;</li> <li>Resolve subproblemas independentemente e combina solu\u00e7\u00f5es;</li> <li>Muito eficiente para ordena\u00e7\u00e3o;</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#272-quando-ocorrre","title":"2.7.2 Quando ocorrre","text":"<ul> <li>Merge Sort, Quick Sort, Heap Sort;</li> <li>Algoritmos de transformada r\u00e1pida de Fourier;</li> </ul> Exemplo conceitual:<pre><code>// Merge Sort - O(n log n)\nvoid merge_sort(int arr[], int l, int r) {\n    if (l &lt; r) {\n        int m = l + (r - l) / 2;    // O(1)\n        merge_sort(arr, l, m);       // T(n/2)\n        merge_sort(arr, m + 1, r);   // T(n/2)\n        merge(arr, l, m, r);         // O(n)\n    }\n}\n// Rela\u00e7\u00e3o: T(n) = 2T(n/2) + O(n) = O(n log n)\n</code></pre>"},{"location":"disciplinas/EDA1/complexidade/#3-comparacao-de-complexidades","title":"3. Compara\u00e7\u00e3o de Complexidades","text":"Complexidade n = 10 n = 100 n = 1000 Exemplo O(1) 1 1 1 Acesso a array O(log n) ~3 ~7 ~10 Busca bin\u00e1ria O(n) 10 100 1000 Busca sequencial O(n log n) ~30 ~700 ~10000 Merge Sort O(n\u00b2) 100 10000 1000000 Bubble Sort O(n\u00b3) 1000 1000000 10\u2079 Multiplica\u00e7\u00e3o de matrizes O(2\u207f) 1024 1.3\u00d710\u00b3\u2070 1.1\u00d710\u00b3\u2070\u00b9 Fibonacci recursivo O(n!) 3.6\u00d710\u2076 9.3\u00d710\u00b9\u2075\u2077 4.0\u00d710\u00b2\u2075\u2076\u2077 Permuta\u00e7\u00f5es"},{"location":"disciplinas/EDA1/complexidade/#4-consideracoes-importantes","title":"4. Considera\u00e7\u00f5es Importantes","text":""},{"location":"disciplinas/EDA1/complexidade/#41-complexidade-de-espaco","title":"4.1 Complexidade de Espa\u00e7o","text":"<p>Al\u00e9m do tempo, tamb\u00e9m analisamos o consumo de mem\u00f3ria:</p> <ul> <li>O(1): espa\u00e7o constante (vari\u00e1veis fixas);</li> <li>O(n): espa\u00e7o linear (arrays, listas);</li> <li>O(n\u00b2): espa\u00e7o quadr\u00e1tico (matrizes n\u00d7n);</li> </ul>"},{"location":"disciplinas/EDA1/complexidade/#42-melhor-caso-caso-medio-e-pior-caso","title":"4.2 Melhor Caso, Caso M\u00e9dio e Pior Caso","text":"<ul> <li>Melhor caso: menor tempo poss\u00edvel (ex: elemento encontrado logo);</li> <li>Caso m\u00e9dio: tempo esperado para entradas aleat\u00f3rias; </li> <li>Pior caso: maior tempo poss\u00edvel (ex: elemento n\u00e3o existe);</li> </ul>"},{"location":"disciplinas/EDA1/ponteiros/","title":"Ponteiros em C","text":""},{"location":"disciplinas/EDA1/ponteiros/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<ul> <li>*ponteiro = acessa o conte\u00fado armazenado no endere\u00e7o apontado pelo ponteiro</li> <li>&amp;variavel = mostra o endere\u00e7o da vari\u00e1vel</li> <li>%p = especificador de formato para mostrar endere\u00e7os de mem\u00f3ria</li> </ul> Exemplo:<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    int age = 1;\n    int *pAge = &amp;age; // ponteiro pAge recebe o endere\u00e7o de age\n\n    printf(\"valor de age: %d \\n\", age);       \n    // Sa\u00edda: valor de age: 1\n    // -&gt; imprime o valor armazenado em age\n\n    printf(\"endereco de age: %p \\n\", &amp;age);   \n    // Sa\u00edda: endereco de age: 0x7ffee6d2c8ac\n    // -&gt; imprime o endere\u00e7o de mem\u00f3ria da vari\u00e1vel age\n\n    printf(\"valor de pAge: %d \\n\", *pAge);    \n    // Sa\u00edda: valor de pAge: 1\n    // -&gt; *pAge acessa o conte\u00fado do endere\u00e7o que pAge aponta, ou seja, o valor de age\n\n    printf(\"endereco de pAge: %p \\n\", &amp;pAge); \n    // Sa\u00edda: endereco de pAge: 0x7ffee6d2c8b0\n    // -&gt; imprime o endere\u00e7o de mem\u00f3ria da vari\u00e1vel ponteiro pAge \n    //    (diferente do endere\u00e7o armazenado dentro dele!)\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/ponteiros/#2-ponteiros-como-parametros","title":"2. Ponteiros como Par\u00e2metros","text":"<p>A passagem de par\u00e2metros por ponteiros permite modificar valores fora do escopo da fun\u00e7\u00e3o.</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nvoid troca(int *p, int *q) { \n    *p = 89;\n    *q = 45;\n}\n\nint main() {\n    int a = 3, b = 9;\n\n    troca(&amp;a, &amp;b); // passando os endere\u00e7os\n\n    printf(\"%d %d\\n\", a, b); // printa 89 e 45\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/ponteiros/#3-ponteiros-x-arrays-x-matrizes","title":"3. Ponteiros x Arrays x Matrizes","text":"<p>Em C, o nome de um vetor \u00e9 equivalente ao endere\u00e7o de seu primeiro elemento (<code>&amp;v[0]</code>). Assim, um ponteiro pode percorrer arrays e at\u00e9 matrizes lineares.</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int v[2] = {1, 2}; // array\n    int *p;            // ponteiro de inteiro\n\n    p = v; // ou p = &amp;v[0]\n\n    p[0] = 5; // altera o primeiro valor do array v\n\n    printf(\"%d %d\\n\", p[0], p[1]); \n    printf(\"%d %d\\n\", v[0], v[1]); \n\n    --------------------------------------------------------------------------\n\n    int m[2][2] = {{1, 2}, {3, 4}}; // matriz 2x2\n\n    printf(\"%d\\n\", m[1][1]); // elemento da linha 2, coluna 2 (4)\n\n    p = m[0]; // ou (int *)m\n              // p aponta para o endere\u00e7o de m[0][0]\n\n    for (int i = 0; i &lt; 4; i++)\n        printf(\"%2d \", p[i]); // printa 1 2 3 4\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/ponteiros/#4-ponteiros-x-structs","title":"4. Ponteiros x Structs","text":"<p>Quando trabalhamos com structs, </p> <ul> <li>Usamos . para acessar campos de vari\u00e1veis normais </li> <li>Usamos -&gt; para acessar campos de ponteiros para struct.</li> </ul> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct {\n    int value;\n} Point;\n\nint main() {\n    Point s;\n    Point *ptr = &amp;s;\n\n    s.value = 20;       // acesso direto pela struct\n    (*ptr).value = 40;  // acesso via ponteiro com ()\n    ptr-&gt;value = 30;    // acesso simplificado com -&gt;\n\n    printf(\"%d\\n\", s.value); // retorna 30\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/recurcao/","title":"Recurs\u00e3o em C","text":""},{"location":"disciplinas/EDA1/recurcao/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":""},{"location":"disciplinas/EDA1/recurcao/#11-definicao","title":"1.1 Defini\u00e7\u00e3o:","text":"<p>Recurs\u00e3o \u00e9 uma t\u00e9cnica de programa\u00e7\u00e3o onde uma fun\u00e7\u00e3o chama a si mesma para resolver problemas menores da mesma natureza. Uma fun\u00e7\u00e3o recursiva deve ter:</p> <ul> <li>Caso base: Condi\u00e7\u00e3o de parada que impede chamadas infinitas;</li> <li>Passo recursivo: Chamada \u00e0 pr\u00f3pria fun\u00e7\u00e3o com problema reduzido;</li> </ul>"},{"location":"disciplinas/EDA1/recurcao/#12-vantagens","title":"1.2 Vantagens:","text":"<ul> <li>C\u00f3digo mais limpo e elegante para certos problemas;</li> <li>Facilita a solu\u00e7\u00e3o de problemas complexos dividindo-os em subproblemas;</li> </ul>"},{"location":"disciplinas/EDA1/recurcao/#13-desvantagens","title":"1.3 Desvantagens:","text":"<ul> <li>Pode consumir mais mem\u00f3ria (pilha de chamadas);</li> <li>Pode ser menos eficiente que solu\u00e7\u00f5es iterativas;</li> </ul>"},{"location":"disciplinas/EDA1/recurcao/#2usos-de-recurcao","title":"2.Usos de recur\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA1/recurcao/#21-fatorial-por-recursao","title":"2.1 Fatorial por Recurs\u00e3o","text":"<p>O fatorial de um n\u00famero n (n!) \u00e9 o produto de todos os n\u00fameros inteiros positivos de 1 at\u00e9 n.</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\n// Fatorial recursivo\nint fat(int n) {\n    if (n == 0) return 1;        // Caso base: 0! = 1\n    return n * fat(n - 1);       // Passo recursivo: n! = n * (n-1)!\n}\n\nint main() {\n    int n = 5;\n\n    // Chamada da fun\u00e7\u00e3o e impress\u00e3o do retorno\n    printf(\"%d! = %d\\n\", n, fat(n)); // Sa\u00edda: 5! = 120\n\n    return 0;\n}\n</code></pre> Visualiza\u00e7\u00e3o do fluxo:<pre><code>fat(5) = 5 * fat(4)\n       = 5 * (4 * fat(3))\n       = 5 * (4 * (3 * fat(2)))\n       = 5 * (4 * (3 * (2 * fat(1))))\n       = 5 * (4 * (3 * (2 * (1 * fat(0)))))\n       = 5 * (4 * (3 * (2 * (1 * 1))))\n       = 5 * (4 * (3 * (2 * 1)))\n       = 5 * (4 * (3 * 2))\n       = 5 * (4 * 6)\n       = 5 * 24\n       = 120\n</code></pre>"},{"location":"disciplinas/EDA1/recurcao/#22-fibonacci-por-recursao","title":"2.2 Fibonacci por Recurs\u00e3o","text":"<p>A sequ\u00eancia de Fibonacci \u00e9 definida como:</p> <ul> <li>Fib(0) = 0</li> <li>Fib(1) = 1  </li> <li>Fib(n) = Fib(n-2) + Fib(n-1)</li> </ul> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nint fib(int n) {\n    if (n == 0 || n == 1) return n;  // Casos base\n    return fib(n - 2) + fib(n - 1);  // Passo recursivo\n}\n\nint main() {\n    int a = fib(6);\n    printf(\"Fib(6) = %d\\n\", a); // Sa\u00edda: Fib(6) = 8\n\n    // Mostrando a sequ\u00eancia at\u00e9 o 6\u00ba termo\n    for (int i = 0; i &lt;= 6; i++) {\n        printf(\"Fib(%d) = %d\\n\", i, fib(i));\n    }\n    return 0;\n}\n</code></pre> Visualiza\u00e7\u00e3o do fluxo:<pre><code>        fib(4)\n        /    \\\n    fib(3)   fib(2)\n    /    \\    /    \\\nfib(2) fib(1) fib(1) fib(0)\n/    \\\nfib(1) fib(0)\n</code></pre>"},{"location":"disciplinas/EDA1/recurcao/#23-avaliacao-de-expressoes-na-notacao-polonesa","title":"2.3 Avalia\u00e7\u00e3o de Express\u00f5es na Nota\u00e7\u00e3o Polonesa","text":"<p>A nota\u00e7\u00e3o polonesa (prefixa) coloca o operador antes dos operandos. Exemplo: <code>+ 3 4</code> em vez de <code>3 + 4</code>.</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nchar a[] = \"+ * 2 3 4\"; // Express\u00e3o: (2 * 3) + 4 = 10\nint i = 0;              // \u00cdndice global para percorrer a string\n\nint eval() {\n    int x = 0;\n\n    // Pula espa\u00e7os em branco\n    while (a[i] == ' ') i++;\n\n    if (a[i] == '+') {\n        i++;\n        return eval() + eval();  // Soma dos dois operandos seguintes\n    }\n\n    if (a[i] == '*') {\n        i++;\n        return eval() * eval();  // Multiplica\u00e7\u00e3o dos dois operandos seguintes\n    }\n\n    // Converte d\u00edgitos para n\u00famero\n    while (a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') {\n        x = 10 * x + (a[i++] - '0');\n    }\n\n    return x;  // Retorna o n\u00famero convertido\n}\n\nint main() {\n    int resultado = eval();\n    printf(\"Resultado: %d\\n\", resultado); // Sa\u00edda: Resultado: 10\n    return 0;\n}\n</code></pre> Visualiza\u00e7\u00e3o do fluxo:<pre><code>eval() \u2192 encontra '+' \u2192 chama eval() + eval()\n    Primeiro eval(): encontra '*' \u2192 chama eval() * eval()\n        Primeiro eval(): encontra '2' \u2192 retorna 2\n        Segundo eval(): encontra '3' \u2192 retorna 3\n        Retorna 2 * 3 = 6\n    Segundo eval(): encontra '4' \u2192 retorna 4\n    Retorna 6 + 4 = 10\n</code></pre>"},{"location":"disciplinas/EDA1/recurcao/#24-geracao-de-subconjuntos","title":"2.4 Gera\u00e7\u00e3o de Subconjuntos","text":"<p>Algoritmo para gerar todos os subconjuntos de um conjunto usando recurs\u00e3o.</p> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n\nvoid subsets(int sub[], int v[], int n, int i, int fim) {\n    // Imprime o subconjunto atual\n    printf(\"{ \");\n    for (int j = 0; j &lt; fim; j++) {\n        printf(\"%d \", sub[j]);\n    }\n    printf(\"}\\n\");\n\n    // Gera os subconjuntos recursivamente\n    for (; i &lt; n; i++) {\n        sub[fim] = v[i];               // Adiciona o elemento atual ao subconjunto\n        subsets(sub, v, n, i + 1, fim + 1);  // Chamada recursiva\n    }\n}\n\nint main() {\n    int v[] = {1, 2, 3};  // Array original\n    int sub[3];           // Array para armazenar os subconjuntos\n    int n = 3;            // Tamanho do array\n\n    printf(\"Subconjuntos de {1, 2, 3}:\\n\");\n    subsets(sub, v, n, 0, 0);  // Chama a fun\u00e7\u00e3o para gerar os subconjuntos\n\n    return 0;\n}\n</code></pre> Sa\u00edda:<pre><code>{ }\n{ 1 }\n{ 1 2 }\n{ 1 2 3 }\n{ 1 3 }\n{ 2 }\n{ 2 3 }\n{ 3 }\n</code></pre> <p>Explica\u00e7\u00e3o: O algoritmo usa backtracking. Para cada elemento, temos duas op\u00e7\u00f5es: incluir ou n\u00e3o incluir no subconjunto atual. A recurs\u00e3o explora todas as combina\u00e7\u00f5es poss\u00edveis.</p>"},{"location":"disciplinas/EDA1/recurcao/#3-consideracoes-importantes-sobre-recursao","title":"3. Considera\u00e7\u00f5es Importantes sobre Recurs\u00e3o","text":""},{"location":"disciplinas/EDA1/recurcao/#31-recursao-vs-iteracao","title":"3.1 Recurs\u00e3o vs Itera\u00e7\u00e3o","text":"<ul> <li>Itera\u00e7\u00e3o: geralmente \u00e9 mais eficiente em termos de mem\u00f3ria;</li> <li>Recurs\u00e3o: pode ser mais intuitiva para certos problemas (\u00e1rvores, backtracking);</li> </ul>"},{"location":"disciplinas/EDA1/recurcao/#32-recursao-de-cauda-tail-recursion","title":"3.2 Recurs\u00e3o de Cauda (Tail Recursion)","text":"<p>Uma recurs\u00e3o onde a chamada recursiva \u00e9 a \u00faltima opera\u00e7\u00e3o da fun\u00e7\u00e3o. Pode ser otimizada pelo compilador.</p> Exemplo de fatorial com recurs\u00e3o de cauda:<pre><code>int fat_tail(int n, int acc) {\n    if (n == 0) return acc;\n    return fat_tail(n - 1, n * acc);\n}\n\nint factorial(int n) {\n    return fat_tail(n, 1);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/recurcao/#33-limitacoes","title":"3.3 Limita\u00e7\u00f5es","text":"<ul> <li>Estouro de pilha: pode ocorrer com recurs\u00f5es muito profundas;</li> <li>M\u00faltiplas chamadas recursivas: (como Fibonacci) podem ser extremamente ineficientes;</li> </ul>"},{"location":"disciplinas/EDA1/recurcao/#34-memoizacao","title":"3.4 Memoiza\u00e7\u00e3o","text":"<p>T\u00e9cnica para melhorar a efici\u00eancia armazenando resultados de chamadas anteriores.</p> Fibonacci com memoiza\u00e7\u00e3o:<pre><code>#include &lt;stdio.h&gt;\n#define MAX 100\n\nint memo[MAX] = {0};\n\nint fib_memo(int n) {\n    if (n == 0 || n == 1) return n;\n    if (memo[n] != 0) return memo[n];\n\n    memo[n] = fib_memo(n - 2) + fib_memo(n - 1);\n    return memo[n];\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/","title":"Busca Bin\u00e1ria","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>A busca bin\u00e1ria \u00e9 um algoritmo eficiente para encontrar elementos em arrays ordenados. </p> <p>Ele funciona dividindo repetidamente o intervalo de busca pela metade, aproveitando a propriedade de ordena\u00e7\u00e3o para descartar metade dos elementos a cada itera\u00e7\u00e3o.</p> <p>Princ\u00edpio fundamental: \"Divide and Conquer\" (Dividir e Conquistar).</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#2-implementacao-da-busca-binaria","title":"2. Implementa\u00e7\u00e3o da Busca Bin\u00e1ria","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#21-estruturas-de-dados","title":"2.1 Estruturas de Dados","text":"Implementa\u00e7\u00e3o:<pre><code>#define key(A) (A.chave)  // Macro para acessar a chave\n\ntypedef int Key;  // Tipo da chave\n\ntypedef struct data Item;  // Tipo do item\nstruct data { \n    Key chave;     // Chave para busca\n    char info[100]; // Informa\u00e7\u00e3o adicional\n};\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#22-implementacao-recursiva","title":"2.2 Implementa\u00e7\u00e3o Recursiva","text":"Implementa\u00e7\u00e3o:<pre><code>int binary_search(Item *v, int l, int r, Key k) {\n    // Condi\u00e7\u00e3o de parada: intervalo inv\u00e1lido\n    if (l &gt; r) return -1;\n\n    // Calcular o \u00edndice central (evita overflow)\n    int m = l + (r - l) / 2;\n\n    // Comparar k com o elemento central\n    if (k == key(v[m])) return m;  // Elemento encontrado\n\n    // Procurar na metade esquerda\n    if (k &lt; key(v[m]))\n        return binary_search(v, l, m - 1, k);\n\n    // Procurar na metade direita\n    return binary_search(v, m + 1, r, k);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#23-implementacao-iterativa","title":"2.3 Implementa\u00e7\u00e3o Iterativa","text":"Implementa\u00e7\u00e3o:<pre><code>int binary_search_iterative(Item *v, int n, Key k) {\n    int l = 0, r = n - 1;\n\n    while (l &lt;= r) {\n        int m = l + (r - l) / 2;\n\n        if (k == key(v[m])) return m;      // Encontrado\n        if (k &lt; key(v[m])) r = m - 1;      // Buscar \u00e0 esquerda\n        else l = m + 1;                    // Buscar \u00e0 direita\n    }\n\n    return -1;  // N\u00e3o encontrado\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#3-exemplo-passo-a-passo","title":"3. Exemplo Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#31-dados-de-entrada","title":"3.1 Dados de Entrada","text":"Exemplo:<pre><code>V[10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\u00cdndices: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nProcurar: 7\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#32-execucao-do-algoritmo","title":"3.2 Execu\u00e7\u00e3o do Algoritmo","text":"Exemplo:<pre><code>Passo 1: l = 0, r = 9\n- m = (0 + 9) / 2 = 4\n- V[4] = 5 &lt; 7 \u2192 Buscar \u00e0 direita\n\nPasso 2: l = 5, r = 9  \n- m = 5 + (9 - 5) / 2 = 7\n- V[7] = 8 &gt; 7 \u2192 Buscar \u00e0 esquerda\n\nPasso 3: l = 5, r = 6\n- m = 5 + (6 - 5) / 2 = 5\n- V[5] = 6 &lt; 7 \u2192 Buscar \u00e0 direita\n\nPasso 4: l = 6, r = 6\n- m = 6 + (6 - 6) / 2 = 6\n- V[6] = 7 == 7 \u2192 **Elemento encontrado!**\n\nRetorno: \u00edndice 6\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#4-complexidade","title":"4. Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(1) Elemento no meio do array Caso m\u00e9dio O(log n) Distribui\u00e7\u00e3o uniforme Pior caso O(log n) Elemento nas extremidades ou ausente"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#5-variacoes-da-busca-binaria","title":"5. Varia\u00e7\u00f5es da Busca Bin\u00e1ria","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#51-encontrar-primeira-ocorrencia","title":"5.1 Encontrar Primeira Ocorr\u00eancia","text":"<pre><code>int binary_search_first(Item *v, int n, Key k) {\n    int l = 0, r = n - 1;\n    int result = -1;\n\n    while (l &lt;= r) {\n        int m = l + (r - l) / 2;\n\n        if (k == key(v[m])) {\n            result = m;      // Registra posi\u00e7\u00e3o\n            r = m - 1;       // Continua procurando \u00e0 esquerda\n        }\n        else if (k &lt; key(v[m])) r = m - 1;\n        else l = m + 1;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#52-encontrar-ultima-ocorrencia","title":"5.2 Encontrar \u00daltima Ocorr\u00eancia","text":"<pre><code>int binary_search_last(Item *v, int n, Key k) {\n    int l = 0, r = n - 1;\n    int result = -1;\n\n    while (l &lt;= r) {\n        int m = l + (r - l) / 2;\n\n        if (k == key(v[m])) {\n            result = m;      // Registra posi\u00e7\u00e3o\n            l = m + 1;       // Continua procurando \u00e0 direita\n        }\n        else if (k &lt; key(v[m])) r = m - 1;\n        else l = m + 1;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#53-encontrar-menor-elemento-maior-ou-igual","title":"5.3 Encontrar Menor Elemento Maior ou Igual","text":"<pre><code>int binary_search_ceiling(Item *v, int n, Key k) {\n    int l = 0, r = n - 1;\n    int result = -1;\n\n    while (l &lt;= r) {\n        int m = l + (r - l) / 2;\n\n        if (k == key(v[m])) return m;\n\n        if (k &lt; key(v[m])) {\n            result = m;      // Poss\u00edvel candidato\n            r = m - 1;\n        }\n        else {\n            l = m + 1;\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#6-analise-do-algoritmo","title":"6. An\u00e1lise do algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#61-pre-requisitos","title":"6.1 Pr\u00e9-requisitos","text":"<ul> <li>Array deve estar ordenado;</li> <li>Acesso aleat\u00f3rio aos elementos (\u00edndices);</li> <li>Operador de compara\u00e7\u00e3o definido;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#62-vantagens","title":"6.2 Vantagens","text":"<ul> <li>Extremamente eficiente (O(log n));</li> <li>Baixo consumo de mem\u00f3ria (iterativa: O(1));</li> <li>Previs\u00edvel e confi\u00e1vel;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaBinaria/#73-limitacoes","title":"7.3 Limita\u00e7\u00f5es","text":"<ul> <li>Requer array ordenado (custo de ordena\u00e7\u00e3o);</li> <li>N\u00e3o funciona com listas encadeadas;</li> <li>Overhead para dados muito pequenos;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/","title":"Busca Sequencial","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>A busca sequencial \u00e9 um algoritmo simples que percorre cada elemento de uma estrutura de dados (lista, array, etc.) at\u00e9 encontrar o elemento desejado ou percorrer toda a estrutura.</p> <p>Caracter\u00edsticas principais:</p> <ul> <li>Algoritmo mais b\u00e1sico para busca;</li> <li>N\u00e3o requer que os dados estejam ordenados;</li> <li>Implementa\u00e7\u00e3o simples e intuitiva;</li> <li>Pode ser aplicada em qualquer estrutura sequencial;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#2-complexidade","title":"2. Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(1) Elemento encontrado na primeira posi\u00e7\u00e3o Caso m\u00e9dio O(n) = (n + 1)/2 Em m\u00e9dia, verifica metade dos registros Pior caso O(n) Elemento na \u00faltima posi\u00e7\u00e3o ou ausente"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#3-implementacao","title":"3. Implementa\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#31-em-arrays-nao-ordenados","title":"3.1 Em Arrays N\u00e3o Ordenados","text":"Implementa\u00e7\u00e3o:<pre><code>int busca_sequencial_array(int vetor[], int tamanho, int chave) {\n    for (int i = 0; i &lt; tamanho; i++) {\n        if (vetor[i] == chave) {\n            return i; // Retorna o \u00edndice onde encontrou\n        }\n    }\n    return -1; // Retorna -1 se n\u00e3o encontrou\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#32-em-arrays-ordenados","title":"3.2 Em Arrays Ordenados","text":"Implementa\u00e7\u00e3o:<pre><code>int busca_sequencial_ordenada(int vetor[], int tamanho, int chave) {\n    for (int i = 0; i &lt; tamanho; i++) {\n        if (vetor[i] == chave) {\n            return i; // Elemento encontrado\n        }\n        if (vetor[i] &gt; chave) {\n            return -1; // Para antecipadamente - elemento n\u00e3o existe\n        }\n    }\n    return -1; // Elemento n\u00e3o encontrado\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#33-em-listas-simplesmente-encadeadas","title":"3.3 Em Listas Simplesmente Encadeadas","text":"Implementa\u00e7\u00e3o:<pre><code>no *busca_sequencial_lista(no *inicio, int chave) {\n    no *atual = inicio;\n\n    while (atual != NULL) {\n        if (atual-&gt;info == chave) {\n            return atual; // Retorna o n\u00f3 encontrado\n        }\n        atual = atual-&gt;prox;\n    }\n\n    return NULL; // Retorna NULL se n\u00e3o encontrou\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#4-analise-comparativa","title":"4. An\u00e1lise Comparativa","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#41-comparacao-entre-estruturas","title":"4.1 Compara\u00e7\u00e3o entre Estruturas","text":"Estrutura Busca Inser\u00e7\u00e3o Remo\u00e7\u00e3o Melhor Uso Lista Encadeada O(n) O(1) no in\u00edcio/fim O(1) no in\u00edcio, O(n) no meio/fim Inser\u00e7\u00f5es/remo\u00e7\u00f5es frequentes no in\u00edcio Array N\u00e3o-Ordenado O(n) O(1) no fim (com espa\u00e7o) O(n) Dados n\u00e3o ordenados, acesso aleat\u00f3rio Array Ordenado O(n) O(n) O(n) Dados que precisam estar ordenados"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#42-vantagens-da-busca-sequencial","title":"4.2 Vantagens da Busca Sequencial","text":"<ul> <li>Implementa\u00e7\u00e3o simples</li> <li>N\u00e3o requer dados ordenados</li> <li>Funciona com qualquer estrutura sequencial</li> <li>N\u00e3o requer conhecimento pr\u00e9vio da estrutura</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#43-desvantagens-da-busca-sequencial","title":"4.3 Desvantagens da Busca Sequencial","text":"<ul> <li>Ineficiente para grandes conjuntos de dados</li> <li>Complexidade linear pode ser limitante</li> <li>N\u00e3o aproveita ordena\u00e7\u00e3o quando existe</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#5-quando-usar-busca-sequencial","title":"5. Quando Usar Busca Sequencial","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#51-cenarios-adequados","title":"5.1 Cen\u00e1rios Adequados","text":"<ul> <li>Conjuntos de dados pequenos</li> <li>Dados n\u00e3o ordenados</li> <li>Buscas espor\u00e1dicas</li> <li>Implementa\u00e7\u00f5es simples</li> <li>Quando a ordena\u00e7\u00e3o tem custo proibitivo</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20Busca/buscaLinear/#52-cenarios-nao-adequados","title":"5.2 Cen\u00e1rios N\u00e3o Adequados","text":"<ul> <li>Conjuntos de dados muito grandes</li> <li>Buscas frequentes</li> <li>Dados ordenados (use busca bin\u00e1ria)</li> <li>Aplica\u00e7\u00f5es que requerem alto desempenho</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/","title":"Bubble Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Bubble Sort (Ordena\u00e7\u00e3o por Bolha) \u00e9 um algoritmo de ordena\u00e7\u00e3o simples que funciona repetidamente percorrendo o array, comparando elementos adjacentes e trocando-os se estiverem na ordem errada.</p> <p>Princ\u00edpio fundamental: \"Flutua\u00e7\u00e3o\" - os elementos maiores \"borbulham\" para o final do array a cada passagem completa.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#2-implementacao-do-bubble-sort","title":"2. Implementa\u00e7\u00e3o do Bubble Sort","text":"Implementa\u00e7\u00e3o:<pre><code>void bubble_sort(int v[], int l, int r) {\n    int swap = 1;\n\n    while (r &gt; l &amp;&amp; swap) {          // Loop externo: O(n)\n        swap = 0;\n\n        // Percorre o array comparando elementos adjacentes\n        for (int j = l; j &lt; r; j++) { // Loop interno: O(n)\n            if (v[j] &gt; v[j + 1]) {    // Compara\u00e7\u00e3o\n                // Troca os elementos se estiverem na ordem errada\n                exch(v[j], v[j + 1]); // Troca: O(1)\n                swap = 1;\n            }\n        }\n        r--;  // Reduz o limite, pois o \u00faltimo elemento j\u00e1 est\u00e1 na posi\u00e7\u00e3o correta\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo:<pre><code>Array inicial: [64, 34, 25, 12, 22, 11, 90]\n\nPrimeira passagem (r=6):\n- [34, 64, 25, 12, 22, 11, 90] (troca 64-34)\n- [34, 25, 64, 12, 22, 11, 90] (troca 64-25)\n- [34, 25, 12, 64, 22, 11, 90] (troca 64-12)\n- [34, 25, 12, 22, 64, 11, 90] (troca 64-22)\n- [34, 25, 12, 22, 11, 64, 90] (troca 64-11)\n- [34, 25, 12, 22, 11, 64, 90] (sem troca 64-90)\n- Array ap\u00f3s 1\u00aa passagem: [34, 25, 12, 22, 11, 64, 90]\n\nSegunda passagem (r=5):\n- [25, 34, 12, 22, 11, 64, 90] (troca 34-25)\n- [25, 12, 34, 22, 11, 64, 90] (troca 34-12)\n- [25, 12, 22, 34, 11, 64, 90] (troca 34-22)\n- [25, 12, 22, 11, 34, 64, 90] (troca 34-11)\n- Array ap\u00f3s 2\u00aa passagem: [25, 12, 22, 11, 34, 64, 90]\n\nTerceira passagem (r=4):\n- [12, 25, 22, 11, 34, 64, 90] (troca 25-12)\n- [12, 22, 25, 11, 34, 64, 90] (troca 25-22)\n- [12, 22, 11, 25, 34, 64, 90] (troca 25-11)\n- Array ap\u00f3s 3\u00aa passagem: [12, 22, 11, 25, 34, 64, 90]\n\nQuarta passagem (r=3):\n- [12, 22, 11, 25, 34, 64, 90] (sem troca 12-22)\n- [12, 11, 22, 25, 34, 64, 90] (troca 22-11)\n- Array ap\u00f3s 4\u00aa passagem: [12, 11, 22, 25, 34, 64, 90]\n\nQuinta passagem (r=2):\n- [11, 12, 22, 25, 34, 64, 90] (troca 12-11)\n- Array final ordenado: [11, 12, 22, 25, 34, 64, 90]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#32-visualizacao-grafica","title":"3.2 Visualiza\u00e7\u00e3o Gr\u00e1fica","text":"Implementa\u00e7\u00e3o:<pre><code>Array inicial: [64, 34, 25, 12, 22, 11, 90]\n\nPassagem 1: [34, 25, 12, 22, 11, 64, 90] (5 trocas)\nPassagem 2: [25, 12, 22, 11, 34, 64, 90] (4 trocas)  \nPassagem 3: [12, 22, 11, 25, 34, 64, 90] (3 trocas)\nPassagem 4: [12, 11, 22, 25, 34, 64, 90] (1 troca)\nPassagem 5: [11, 12, 22, 25, 34, 64, 90] (1 troca)\n\nArray ordenado: [11, 12, 22, 25, 34, 64, 90]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#41-caracteristicas_1","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade Sim Adaptabilidade Sim In-Place Sim Lista Encadeada N\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n) Array j\u00e1 ordenado (vers\u00e3o otimizada) Caso m\u00e9dio O(n\u00b2) Array em ordem aleat\u00f3ria Pior caso O(n\u00b2) Array em ordem inversa"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Simplicidade: F\u00e1cil de implementar e entender;</li> <li>Adaptabilidade: Vers\u00e3o otimizada detecta arrays j\u00e1 ordenados;</li> <li>Estabilidade: Mant\u00e9m a ordem relativa de elementos iguais;</li> <li>Baixo overhead: Pouca mem\u00f3ria adicional necess\u00e1ria;</li> <li>\u00datil para arrays pequenos ou quase ordenados;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Complexidade quadr\u00e1tica: Ineficiente para arrays grandes;</li> <li>Muitas trocas: Pode realizar at\u00e9 O(n\u00b2) trocas;</li> <li>Pouco eficiente: Comparado a algoritmos O(n log n);</li> <li>Performance ruim: Em arrays grandes ou desordenados;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/bubble/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Arrays muito pequenos (n &lt; 20)</li> <li>Arrays quase ordenados (poucas trocas necess\u00e1rias)</li> <li>Implementa\u00e7\u00e3o educacional</li> <li>Quando a estabilidade \u00e9 importante</li> <li>Mem\u00f3ria extremamente limitada</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/","title":"Counting Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Counting Sort (Ordena\u00e7\u00e3o por Contagem) \u00e9 um algoritmo de ordena\u00e7\u00e3o n\u00e3o comparativo que funciona contando as ocorr\u00eancias de cada elemento distinto no array de entrada. \u00c9 particularmente eficiente para ordenar n\u00fameros inteiros em um intervalo conhecido e limitado.</p> <p>Princ\u00edpio fundamental: \"Contar, acumular e distribuir\" - conta as frequ\u00eancias de cada chave, calcula as posi\u00e7\u00f5es finais atrav\u00e9s das frequ\u00eancias acumuladas, e distribui os elementos nas posi\u00e7\u00f5es corretas.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#2-implementacao-do-counting-sort","title":"2. Implementa\u00e7\u00e3o do Counting Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#21-funcao-principal-de-ordenacao","title":"2.1 Fun\u00e7\u00e3o Principal de Ordena\u00e7\u00e3o","text":"Fun\u00e7\u00e3o principal do Counting Sort:<pre><code>#define MAX 10000\n#define R 5\n\nint aux[MAX];\n\nvoid countingsort(int *v, int l, int r) {\n    int i, count[R + 1];\n\n    // Inicializa o array de contagem com zeros\n    for (i = 0; i &lt;= R; i++) count[i] = 0;\n\n    // Fase 1: Contar as frequ\u00eancias de cada elemento\n    for (i = l; i &lt;= r; i++) count[v[i] + 1]++;\n\n    // Fase 2: Calcular as posi\u00e7\u00f5es finais (frequ\u00eancias acumuladas)\n    for (i = 1; i &lt;= R; i++) count[i] += count[i - 1];\n\n    // Fase 3: Distribuir os elementos nas posi\u00e7\u00f5es corretas\n    for (i = l; i &lt;= r; i++) aux[count[v[i]]++] = v[i];\n\n    // Copiar o array ordenado de volta para o original\n    for (i = l; i &lt;= r; i++) v[i] = aux[i - l];\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#22-passos-do-algoritmo","title":"2.2 Passos do Algoritmo","text":"<p>Fase 1 - Contagem de Frequ\u00eancias: - Encontrar o intervalo de valores (min e max); - Criar um array de contagem com tamanho (max - min + 1); - Contar quantas vezes cada elemento aparece no array original;</p> <p>Fase 2 - C\u00e1lculo de Posi\u00e7\u00f5es: - Transformar as frequ\u00eancias em posi\u00e7\u00f5es acumuladas; - Cada elemento indica a posi\u00e7\u00e3o onde o pr\u00f3ximo elemento daquela chave deve ser colocado;</p> <p>Fase 3 - Distribui\u00e7\u00e3o: - Percorrer o array original e colocar cada elemento na posi\u00e7\u00e3o correta do array auxiliar; - Atualizar o contador de posi\u00e7\u00f5es para cada chave;</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo: v[5] = [2, 3, 3, 4, 1]<pre><code>Array inicial: [2, 3, 3, 4, 1]\nIntervalo de valores: 1 a 4 (R = 4)\n\nFase 1 - Contagem de frequ\u00eancias:\ncount[0] = 0  // valor 0\ncount[1] = 1  // valor 1\ncount[2] = 1  // valor 2\ncount[3] = 2  // valor 3\ncount[4] = 1  // valor 4\n\nFase 2 - C\u00e1lculo de posi\u00e7\u00f5es (acumulado):\ncount[0] = 0\ncount[1] = 0 + 1 = 1\ncount[2] = 1 + 1 = 2\ncount[3] = 2 + 2 = 4\ncount[4] = 4 + 1 = 5\n\nFase 3 - Distribui\u00e7\u00e3o:\nElemento 1: posi\u00e7\u00e3o count[1] = 0 \u2192 aux[0] = 1\nElemento 2: posi\u00e7\u00e3o count[2] = 1 \u2192 aux[1] = 2\nElemento 3: posi\u00e7\u00e3o count[3] = 2 \u2192 aux[2] = 3\nElemento 3: posi\u00e7\u00e3o count[3] = 3 \u2192 aux[3] = 3\nElemento 4: posi\u00e7\u00e3o count[4] = 4 \u2192 aux[4] = 4\n\nArray ordenado: [1, 2, 3, 3, 4]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#32-visualizacao-das-fases","title":"3.2 Visualiza\u00e7\u00e3o das Fases","text":"Processo detalhado:<pre><code>Array original: [2, 3, 3, 4, 1]\n\nFase 1 - Contagem:\nValor 1: aparece 1 vez \u2192 count[1] = 1\nValor 2: aparece 1 vez \u2192 count[2] = 1  \nValor 3: aparece 2 vezes \u2192 count[3] = 2\nValor 4: aparece 1 vez \u2192 count[4] = 1\n\nFase 2 - Acumula\u00e7\u00e3o:\ncount[1] = 1 (0 + 1)\ncount[2] = 2 (1 + 1)\ncount[3] = 4 (2 + 2)\ncount[4] = 5 (4 + 1)\n\nFase 3 - Distribui\u00e7\u00e3o:\nProcessa elemento 2: count[2] = 2 \u2192 aux[1] = 2, count[2] = 3\nProcessa elemento 3: count[3] = 4 \u2192 aux[3] = 3, count[3] = 5\nProcessa elemento 3: count[3] = 5 \u2192 aux[4] = 3, count[3] = 6\nProcessa elemento 4: count[4] = 5 \u2192 aux[4] = 4, count[4] = 6\nProcessa elemento 1: count[1] = 1 \u2192 aux[0] = 1, count[1] = 2\n\nResultado: aux = [1, 2, 3, 3, 4]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Counting Sort Estabilidade Sim Adaptabilidade N\u00e3o In-Place N\u00e3o N\u00e3o Comparativo Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n + k) n = n\u00famero de elementos, k = intervalo Caso m\u00e9dio O(n + k) Performance consistente Pior caso O(n + k) Garantido em todos os casos Complexidade de espa\u00e7o O(n + k) Array auxiliar + array de contagem"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Complexidade linear O(n + k): Extremamente r\u00e1pido para intervalos limitados;</li> <li>Est\u00e1vel: Mant\u00e9m a ordem relativa de elementos iguais;</li> <li>N\u00e3o comparativo: N\u00e3o depende de compara\u00e7\u00f5es entre elementos;</li> <li>Determin\u00edstico: Sempre executa no mesmo tempo para mesma entrada;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>N\u00e3o in-place: Requer mem\u00f3ria adicional O(n + k);</li> <li>Apenas para inteiros: Limitado a tipos de dados discretos;</li> <li>Ineficiente para grandes intervalos: Se k &gt;&gt; n, torna-se ineficiente;</li> <li>Requer conhecimento do intervalo: Precisa saber min e max antecipadamente;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Para ordenar inteiros com intervalo limitado;</li> <li>Quando k = O(n) (intervalo proporcional ao n\u00famero de elementos);</li> <li>Em aplica\u00e7\u00f5es onde estabilidade \u00e9 importante;</li> <li>Como sub-rotina de algoritmos mais complexos (ex: Radix Sort);</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/counting/#5-aplicacoes-especiais","title":"5. Aplica\u00e7\u00f5es Especiais","text":"<ul> <li>Radix Sort: Como sub-rotina para ordena\u00e7\u00e3o por d\u00edgitos;</li> <li>Bucket Sort: Para distribui\u00e7\u00e3o em baldes;</li> <li>Processamento de dados com chaves inteiras;</li> <li>Algoritmos de compress\u00e3o e codifica\u00e7\u00e3o;</li> <li>Processamento de imagens (para histogramas e equaliza\u00e7\u00e3o);</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/","title":"Heap Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Heap Sort (Ordena\u00e7\u00e3o por Heap) \u00e9 um algoritmo de ordena\u00e7\u00e3o baseado na estrutura de dados heap. Desenvolvido por J. W. J. Williams em 1964, \u00e9 um algoritmo eficiente que combina as vantagens da ordena\u00e7\u00e3o por sele\u00e7\u00e3o com a efici\u00eancia do heap.</p> <p>Princ\u00edpio fundamental: \"Transformar o array em um heap m\u00e1ximo, extrair repetidamente o maior elemento e reconstruir o heap\" - converte o array em um heap m\u00e1ximo, extrai o elemento raiz (maior) e reconstr\u00f3i o heap com os elementos restantes.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#2-implementacao-do-heap-sort","title":"2. Implementa\u00e7\u00e3o do Heap Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#21-funcao-principal-de-ordenacao","title":"2.1 Fun\u00e7\u00e3o Principal de Ordena\u00e7\u00e3o","text":"Fun\u00e7\u00e3o principal do Heap Sort:<pre><code>// Defini\u00e7\u00e3o do tipo Item\ntypedef int Item;\n\n// Fun\u00e7\u00e3o para trocar dois elementos\nvoid exch(Item *a, Item *b) {\n    Item temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Fun\u00e7\u00e3o para restaurar a propriedade de heap (max-heap)\nvoid fixDown(Item *pq, int k, int N) {\n    while (2 * k &lt;= N) {\n        int j = 2 * k; // Filho esquerdo\n        if (j &lt; N &amp;&amp; pq[j] &lt; pq[j + 1]) j++; // Escolhe o maior filho\n        if (pq[k] &gt;= pq[j]) break; // Se o pai \u00e9 maior que o filho, para\n        exch(&amp;pq[k], &amp;pq[j]); // Troca pai e filho\n        k = j; // Continua no filho\n    }\n}\n\n// Fun\u00e7\u00e3o principal do Heap Sort\nvoid heap_sort(Item *v, int l, int r) {\n    Item *pq = v + l - 1; // Ajusta o ponteiro para o heap\n    int N = r - l + 1;    // Tamanho do heap\n\n    // Constr\u00f3i o heap (max-heap) - Fase 1\n    for (int k = N / 2; k &gt;= 1; k--) {\n        fixDown(pq, k, N);\n    }\n\n    // Ordena o array - Fase 2\n    while (N &gt; 1) {\n        exch(&amp;pq[1], &amp;pq[N]); // Troca o maior elemento (raiz) com o \u00faltimo\n        fixDown(pq, 1, --N);  // Restaura a propriedade de heap\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#22-passos-do-algoritmo","title":"2.2 Passos do Algoritmo","text":"<p>Fase 1 - Constru\u00e7\u00e3o do Heap M\u00e1ximo: - Transformar a lista original em um heap m\u00e1ximo; - Come\u00e7a pela metade do array (\u00faltimo n\u00f3 n\u00e3o-folha); - Aplica <code>fixDown</code> em cada n\u00f3 at\u00e9 chegar na raiz;</p> <p>Fase 2 - Ordena\u00e7\u00e3o: - Trocar a raiz (maior elemento) pelo \u00faltimo elemento; - Remove a raiz do heap (diminui o tamanho); - Aplica <code>fixDown</code> na nova raiz para restaurar a propriedade de heap; - Repete o processo at\u00e9 que o heap tenha apenas um elemento;</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo: [3, 7, 8, 5, 2, 1, 9, 5, 4]<pre><code>Array inicial: [3, 7, 8, 5, 2, 1, 9, 5, 4]\n\nFase 1 - Constru\u00e7\u00e3o do Heap M\u00e1ximo:\nHeap constru\u00eddo: [9, 7, 8, 5, 4, 1, 3, 5, 2]\n\nFase 2 - Ordena\u00e7\u00e3o:\nPasso 1: Troca 9\u21942 \u2192 [2, 7, 8, 5, 4, 1, 3, 5, 9]\n         fixDown: [8, 7, 3, 5, 4, 1, 2, 5, 9]\n\nPasso 2: Troca 8\u21945 \u2192 [5, 7, 3, 5, 4, 1, 2, 8, 9]\n         fixDown: [7, 5, 3, 5, 4, 1, 2, 8, 9]\n\nPasso 3: Troca 7\u21942 \u2192 [2, 5, 3, 5, 4, 1, 7, 8, 9]\n         fixDown: [5, 5, 3, 2, 4, 1, 7, 8, 9]\n\nContinua at\u00e9 array ordenado: [1, 2, 3, 4, 5, 5, 7, 8, 9]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#32-visualizacao-da-construcao-do-heap","title":"3.2 Visualiza\u00e7\u00e3o da Constru\u00e7\u00e3o do Heap","text":"Constru\u00e7\u00e3o do heap m\u00e1ximo:<pre><code>Array original: [3, 7, 8, 5, 2, 1, 9, 5, 4]\n\nConstru\u00e7\u00e3o a partir do meio (k = 4):\n- k=4: [3, 7, 8, 5, 2, 1, 9, 5, 4] \u2713\n- k=3: [3, 7, 8, 5, 2, 1, 9, 5, 4] \u2192 [3, 7, 9, 5, 2, 1, 8, 5, 4]\n- k=2: [3, 7, 9, 5, 2, 1, 8, 5, 4] \u2192 [3, 5, 9, 7, 2, 1, 8, 5, 4]\n- k=1: [3, 5, 9, 7, 2, 1, 8, 5, 4] \u2192 [9, 5, 8, 7, 2, 1, 3, 5, 4]\n\nHeap m\u00e1ximo final: [9, 7, 8, 5, 4, 1, 3, 5, 2]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Heap Sort Estabilidade N\u00e3o Adaptabilidade N\u00e3o In-Place Sim Lista Encadeada N\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n log n) Constru\u00e7\u00e3o do heap + extra\u00e7\u00f5es Caso m\u00e9dio O(n log n) Constru\u00e7\u00e3o do heap + extra\u00e7\u00f5es Pior caso O(n log n) Garantido em todos os casos Complexidade de espa\u00e7o O(1) Ordena\u00e7\u00e3o in-place"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Complexidade garantida O(n log n): Nunca degrada para O(n\u00b2);</li> <li>Ordena\u00e7\u00e3o in-place: Baixo uso de mem\u00f3ria adicional (O(1));</li> <li>N\u00e3o recursivo: N\u00e3o usa pilha de chamadas;</li> <li>Est\u00e1vel no pior caso: Performance consistente;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>N\u00e3o est\u00e1vel: Pode alterar ordem relativa de elementos iguais;</li> <li>N\u00e3o adapt\u00e1vel: Performance n\u00e3o melhora com arrays parcialmente ordenados;</li> <li>Cache-unfriendly: Acesso \u00e0 mem\u00f3ria n\u00e3o sequencial;</li> <li>Constantes altas: Na pr\u00e1tica, mais lento que Quick Sort e Merge Sort;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Quando garantia de O(n log n) \u00e9 cr\u00edtica;</li> <li>Em sistemas com mem\u00f3ria limitada;</li> <li>Para implementa\u00e7\u00f5es onde recurs\u00e3o \u00e9 problem\u00e1tica;</li> <li>Em aplica\u00e7\u00f5es de tempo real onde o pior caso importa;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/heap/#5-aplicacoes-especiais","title":"5. Aplica\u00e7\u00f5es Especiais","text":"<ul> <li>Sistemas embarcados: Por ser in-place e n\u00e3o recursivo;</li> <li>K-way merge: Utilizado em algoritmos de merge externo;</li> <li>Sele\u00e7\u00e3o de k-\u00e9simo elemento: Adapt\u00e1vel para encontrar o k-\u00e9simo maior/menor elemento;</li> <li>Filas de prioridade: Base para implementa\u00e7\u00e3o eficiente de filas de prioridade;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/","title":"Insertion Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Insertion Sort (Ordena\u00e7\u00e3o por Inser\u00e7\u00e3o) \u00e9 um algoritmo de ordena\u00e7\u00e3o simples que funciona construindo uma sequ\u00eancia ordenada um elemento de cada vez. Ele \u00e9 eficiente para conjuntos de dados pequenos ou parcialmente ordenados.</p> <p>Princ\u00edpio fundamental: \"Inserir ordenadamente\" - cada elemento \u00e9 inserido na posi\u00e7\u00e3o correta dentro da parte j\u00e1 ordenada do array.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#2-implementacoes-do-insertion-sort","title":"2. Implementa\u00e7\u00f5es do Insertion Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#21-versao-com-troca-direta","title":"2.1 Vers\u00e3o com Troca Direta","text":"Implementa\u00e7\u00e3o com trocas:<pre><code>void insertion_sort(int v[], int l, int r) {\n    // Percorrer o array a partir do segundo elemento\n    for (int i = l + 1; i &lt;= r; i++) {\n        // Procurar antecessores menores que v[i]\n        for (int j = i; j &gt; l &amp;&amp; v[j] &lt; v[j - 1]; j--) {\n            // Inserir na posi\u00e7\u00e3o correta atrav\u00e9s de trocas\n            exch(v[j], v[j - 1]);\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#22-versao-otimizada-com-deslocamento","title":"2.2 Vers\u00e3o Otimizada com Deslocamento","text":"Implementa\u00e7\u00e3o otimizada:<pre><code>void insertion_sort(int v[], int l, int r) {\n    int elem, i, j;\n\n    // Percorrer o array a partir do segundo elemento\n    for (i = l + 1; i &lt;= r; i++) {\n        // Elemento que ser\u00e1 (re) inserido\n        elem = v[i];\n\n        // Para cada elemento maior que 'elem'\n        for (j = i; j &gt; l &amp;&amp; elem &lt; v[j - 1]; j--) {\n            // \"Puxar\" o maior elemento para a direita\n            v[j] = v[j - 1];\n        }\n\n        // Inserir o elemento na sua posi\u00e7\u00e3o correta\n        v[j] = elem;\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#31-exemplo-com-array-pequeno-versao-otimizada","title":"3.1 Exemplo com Array Pequeno (Vers\u00e3o Otimizada)","text":"Exemplo:<pre><code>Array inicial: [12, 11, 13, 5, 6]\n\nPasso 1 (i=1, elem=11):\n- j=1: 11 &lt; 12? Sim \u2192 v[1] = v[0] \u2192 [12, 12, 13, 5, 6]\n- j=0: j &gt; 0? N\u00e3o \u2192 v[0] = 11 \u2192 [11, 12, 13, 5, 6]\n\nPasso 2 (i=2, elem=13):\n- j=2: 13 &lt; 12? N\u00e3o \u2192 v[2] = 13 \u2192 [11, 12, 13, 5, 6]\n\nPasso 3 (i=3, elem=5):\n- j=3: 5 &lt; 13? Sim \u2192 v[3] = v[2] \u2192 [11, 12, 13, 13, 6]\n- j=2: 5 &lt; 12? Sim \u2192 v[2] = v[1] \u2192 [11, 12, 12, 13, 6]  \n- j=1: 5 &lt; 11? Sim \u2192 v[1] = v[0] \u2192 [11, 11, 12, 13, 6]\n- j=0: j &gt; 0? N\u00e3o \u2192 v[0] = 5 \u2192 [5, 11, 12, 13, 6]\n\nPasso 4 (i=4, elem=6):\n- j=4: 6 &lt; 13? Sim \u2192 v[4] = v[3] \u2192 [5, 11, 12, 13, 13]\n- j=3: 6 &lt; 12? Sim \u2192 v[3] = v[2] \u2192 [5, 11, 12, 12, 13]\n- j=2: 6 &lt; 11? Sim \u2192 v[2] = v[1] \u2192 [5, 11, 11, 12, 13]\n- j=1: 6 &lt; 5? N\u00e3o \u2192 v[1] = 6 \u2192 [5, 6, 11, 12, 13]\n\nArray final ordenado: [5, 6, 11, 12, 13]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#32-visualizacao-grafica","title":"3.2 Visualiza\u00e7\u00e3o Gr\u00e1fica","text":"Implementa\u00e7\u00e3o:<pre><code>Array inicial: [12, 11, 13, 5, 6]\n\nItera\u00e7\u00e3o 1: [11, 12, 13, 5, 6] (inseriu 11)\nItera\u00e7\u00e3o 2: [11, 12, 13, 5, 6] (manteve 13)  \nItera\u00e7\u00e3o 3: [5, 11, 12, 13, 6] (inseriu 5)\nItera\u00e7\u00e3o 4: [5, 6, 11, 12, 13] (inseriu 6)\n\nArray ordenado: [5, 6, 11, 12, 13]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#41-caracteristicas_1","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade Sim Adaptabilidade Sim In-Place SIm Lista Encadeada Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n) Array j\u00e1 ordenado Caso m\u00e9dio O(n\u00b2) Array em ordem aleat\u00f3ria Pior caso O(n\u00b2) Array em ordem inversa"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Simplicidade: F\u00e1cil de implementar e entender;</li> <li>Adaptabilidade: Performance excelente em arrays quase ordenados;</li> <li>Estabilidade: Mant\u00e9m a ordem relativa de elementos iguais;</li> <li>Eficiente em pequenos arrays: Melhor que algoritmos O(n log n) para n &lt; 10-20;</li> <li>Ordena\u00e7\u00e3o in-place: Baixo uso de mem\u00f3ria adicional;</li> <li>Online: Pode ordenar dados \u00e0 medida que s\u00e3o recebidos;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Complexidade quadr\u00e1tica: Ineficiente para arrays grandes;</li> <li>Muitas compara\u00e7\u00f5es/deslocamentos: Pode ser custoso;</li> <li>N\u00e3o escal\u00e1vel: Performance decai rapidamente com o aumento de n;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Arrays pequenos (n &lt; 20)</li> <li>Arrays quase ordenados </li> <li>Implementa\u00e7\u00e3o educacional</li> <li>Quando a estabilidade \u00e9 importante</li> <li>Ordena\u00e7\u00e3o online de dados recebidos sequencialmente</li> <li>Como parte de algoritmos h\u00edbridos como Timsort</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/insertion/#46-comparacao-das-versoes","title":"4.6 Compara\u00e7\u00e3o das Vers\u00f5es","text":"Caracter\u00edstica Vers\u00e3o com Trocas Vers\u00e3o Otimizada N\u00famero de opera\u00e7\u00f5es Mais trocas Menos atribui\u00e7\u00f5es Complexidade O(n\u00b2) O(n\u00b2) Efici\u00eancia Menos eficiente Mais eficiente Uso de mem\u00f3ria O(1) O(1) <p>A vers\u00e3o otimizada \u00e9 geralmente preferida pois reduz o n\u00famero de opera\u00e7\u00f5es de escrita na mem\u00f3ria, movendo elementos apenas uma vez em vez de fazer m\u00faltiplas trocas.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/","title":"Intro Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O IntroSort (Introsort ou Introspective Sort) \u00e9 um algoritmo de ordena\u00e7\u00e3o h\u00edbrido que combina as melhores caracter\u00edsticas do QuickSort, HeapSort e InsertionSort. Desenvolvido por David Musser em 1997, oferece excelente performance na pr\u00e1tica com garantia de complexidade O(n log n) no pior caso.</p> <p>Princ\u00edpio fundamental: \"Combinar efici\u00eancias e evitar defici\u00eancias\" - utiliza QuickSort para efici\u00eancia m\u00e9dia, HeapSort para garantir complexidade \u00f3tima, e InsertionSort para pequenos subarrays.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#2-implementacao-do-introsort","title":"2. Implementa\u00e7\u00e3o do IntroSort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#21-funcao-principal-de-ordenacao","title":"2.1 Fun\u00e7\u00e3o Principal de Ordena\u00e7\u00e3o","text":"Fun\u00e7\u00e3o principal do IntroSort:<pre><code>#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\n// Fun\u00e7\u00e3o auxiliar para trocar elementos\nvoid exch(int &amp;a, int &amp;b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\n// Fun\u00e7\u00e3o auxiliar para compara\u00e7\u00e3o e troca\nvoid compexch(int &amp;a, int &amp;b) {\n    if (b &lt; a) exch(a, b);\n}\n\n// Insertion Sort para pequenos arrays\nvoid insertion_sort(int *v, int l, int r) {\n    for (int i = l + 1; i &lt;= r; i++) {\n        int key = v[i];\n        int j = i - 1;\n        while (j &gt;= l &amp;&amp; v[j] &gt; key) {\n            v[j + 1] = v[j];\n            j--;\n        }\n        v[j + 1] = key;\n    }\n}\n\n// Partition do QuickSort (vers\u00e3o Lomuto)\nint partition(int *v, int l, int r) {\n    int pivot = v[r];\n    int i = l - 1;\n\n    for (int j = l; j &lt; r; j++) {\n        if (v[j] &lt;= pivot) {\n            i++;\n            exch(v[i], v[j]);\n        }\n    }\n    exch(v[i + 1], v[r]);\n    return i + 1;\n}\n\n// Fun\u00e7\u00e3o recursiva principal\nvoid intro(int *v, int l, int r, int maxdepth) {\n    // Caso base: array pequeno \u2192 InsertionSort\n    if (r - l &lt;= 15) {\n        insertion_sort(v, l, r);\n        return;\n    }\n    // Profundidade m\u00e1xima atingida \u2192 HeapSort\n    else if (maxdepth == 0) {\n        std::make_heap(v + l, v + r + 1);\n        std::sort_heap(v + l, v + r + 1);\n        return;\n    }\n    // QuickSort com otimiza\u00e7\u00f5es\n    else {\n        // Mediana de tr\u00eas para escolha do piv\u00f4\n        compexch(v[l], v[(l + r) / 2]);\n        compexch(v[l], v[r]);\n        compexch(v[r], v[(l + r) / 2]);\n\n        int p = partition(v, l, r);\n        intro(v, l, p - 1, maxdepth - 1);\n        intro(v, p + 1, r, maxdepth - 1);\n    }\n}\n\n// Fun\u00e7\u00e3o wrapper principal\nvoid intro_sort(int *v, int l, int r) {\n    if (r &lt;= l) return;\n\n    // Calcula profundidade m\u00e1xima (2 * log2(n))\n    int n = r - l + 1;\n    int maxdepth = 2 * static_cast&lt;int&gt;(std::log2(n));\n\n    intro(v, l, r, maxdepth);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#22-passos-do-algoritmo","title":"2.2 Passos do Algoritmo","text":"<p>Fase 1 - QuickSort: - Divide o array recursivamente usando parti\u00e7\u00e3o; - Usa mediana de tr\u00eas para escolha otimizada do piv\u00f4; - Continua enquanto a profundidade de recurs\u00e3o estiver dentro do limite;</p> <p>Fase 2 - HeapSort: - Se a profundidade de recurs\u00e3o exceder 2 * log\u2082(n); - Garante complexidade O(n log n) no pior caso;</p> <p>Fase 3 - InsertionSort: - Quando os subarrays ficam pequenos (\u2264 15 elementos); - Refina a ordena\u00e7\u00e3o final com algoritmo adaptativo;</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#31-exemplo-com-array","title":"3.1 Exemplo com Array","text":"Exemplo: Array de 20 elementos<pre><code>Array inicial: [5, 2, 8, 3, 9, 1, 6, 4, 7, 0, ...]\n\nPasso 1: QuickSort com mediana de tr\u00eas\n- Escolhe piv\u00f4 otimizado (mediana de primeiro, meio, \u00faltimo)\n- Particiona o array\n- Continua recursivamente\n\nPasso 2: Monitoramento de profundidade\n- Profundidade atual: 0, 1, 2, ... \n- Se profundidade &gt; 2 * log\u2082(20) \u2248 8.6 \u2192 muda para HeapSort\n\nPasso 3: Para subarrays pequenos\n- Quando tamanho \u2264 15 \u2192 aplica InsertionSort\n- Exemplo: subarray [2, 3, 1, 0, 4] \u2192 ordena com InsertionSort\n\nResultado final: Array completamente ordenado\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#32-estrategia-de-transicao","title":"3.2 Estrat\u00e9gia de Transi\u00e7\u00e3o","text":"L\u00f3gica de transi\u00e7\u00e3o entre algoritmos:<pre><code>Tamanho do subarray \u2192 Algoritmo usado\n-------------------------------------\nn \u2264 15           \u2192 Insertion Sort\n15 &lt; n \u2264 limite  \u2192 Quick Sort\nn &gt; limite       \u2192 Heap Sort\n\nLimite = 2 * log2(n) (profundidade m\u00e1xima)\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto IntroSort Estabilidade N\u00e3o Adaptabilidade Parcialmente In-Place Sim H\u00edbrido Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n log n) QuickSort com piv\u00f4 ideal Caso m\u00e9dio O(n log n) Performance pr\u00e1tica excelente Pior caso O(n log n) Garantido pelo HeapSort Complexidade de espa\u00e7o O(log n) Pilha de recurs\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Performance pr\u00e1tica do QuickSort: Eficiente na maioria dos casos;</li> <li>Garantia O(n log n): HeapSort evita o pior caso do QuickSort;</li> <li>Efici\u00eancia para pequenos arrays: InsertionSort para refinamento;</li> <li>Otimizado com mediana de tr\u00eas: Escolha inteligente de piv\u00f4;</li> <li>Padr\u00e3o da ind\u00fastria: Usado em std::sort de C++ STL;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>N\u00e3o est\u00e1vel: Pode alterar ordem relativa de elementos iguais;</li> <li>Implementa\u00e7\u00e3o complexa: Combina tr\u00eas algoritmos diferentes;</li> <li>Overhead de monitoramento: Controle de profundidade adiciona complexidade;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Para ordena\u00e7\u00e3o geral de prop\u00f3sito geral;</li> <li>Quando garantia de O(n log n) \u00e9 necess\u00e1ria;</li> <li>Em bibliotecas e frameworks onde robustez \u00e9 importante;</li> <li>Para dados mistos com caracter\u00edsticas variadas;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/intro/#5-aplicacoes-especiais","title":"5. Aplica\u00e7\u00f5es Especiais","text":"<ul> <li>std::sort na C++ STL: Implementa\u00e7\u00e3o padr\u00e3o de muitas bibliotecas;</li> <li>Sistemas de alto desempenho: Onde robustez e performance s\u00e3o cr\u00edticas;</li> <li>Aplica\u00e7\u00f5es cient\u00edficas: Processamento de dados com tamanhos variados;</li> <li>Frameworks de machine learning: Pr\u00e9-processamento de datasets;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/","title":"Introdu\u00e7\u00e3o aos Algoritmos de Ordena\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#1-definicao","title":"1. Defini\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o s\u00e3o procedimentos sistem\u00e1ticos para reorganizar elementos de uma cole\u00e7\u00e3o em uma ordem espec\u00edfica (crescente, decrescente, alfab\u00e9tica, etc.).</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#2-caracteristicas-dos-algoritmos-de-ordenacao","title":"2. Caracter\u00edsticas dos Algoritmos de Ordena\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#21-complexidade","title":"2.1 Complexidade","text":"<ul> <li>Espacial: Quantidade de mem\u00f3ria adicional necess\u00e1ria</li> <li>Temporal: Tempo de execu\u00e7\u00e3o em fun\u00e7\u00e3o do tamanho da entrada</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#22-estabilidade","title":"2.2 Estabilidade","text":"<p>Um algoritmo \u00e9 est\u00e1vel se mant\u00e9m a posi\u00e7\u00e3o relativa de elementos com chaves iguais. Exemplo: se dois registros t\u00eam a mesma chave, sua ordem original \u00e9 preservada.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#23-adaptabilidade","title":"2.3 Adaptabilidade","text":"<p>Um algoritmo \u00e9 adaptativo se aproveita a ordena\u00e7\u00e3o existente no array de entrada. Algoritmos adaptativos performam melhor em arrays parcialmente ordenados.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#24-in-place","title":"2.4 In-Place","text":"<p>Um algoritmo \u00e9 in-place se n\u00e3o requer mem\u00f3ria adicional significativa al\u00e9m dos pr\u00f3prios dados sendo ordenados (geralmente O(1) de espa\u00e7o extra).</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#3-classificacao-dos-algoritmos-de-ordenacao","title":"3. Classifica\u00e7\u00e3o dos Algoritmos de Ordena\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#31-por-complexidade","title":"3.1 Por Complexidade","text":"Tipo Complexidade Exemplos Quadr\u00e1ticos O(n\u00b2) Bubble Sort, Selection Sort, Insertion Sort Linear\u00edtmicos O(n log n) Quick Sort, Merge Sort, Heap Sort Lineares O(n) Counting Sort, Radix Sort, Bucket Sort"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#32-por-metodo","title":"3.2 Por M\u00e9todo","text":"<ul> <li>Baseados em compara\u00e7\u00e3o: Quick Sort, Merge Sort, Heap Sort</li> <li>N\u00e3o baseados em compara\u00e7\u00e3o: Counting Sort, Radix Sort</li> <li>Baseados em troca: Bubble Sort, Quick Sort  </li> <li>Baseados em sele\u00e7\u00e3o: Selection Sort, Heap Sort</li> <li>Baseados em inser\u00e7\u00e3o: Insertion Sort, Shell Sort</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#4-tabela-comparativa-de-algoritmos","title":"4. Tabela Comparativa de Algoritmos","text":"Algoritmo Complexidade (Pior) Complexidade (M\u00e9dio) Complexidade (Melhor) Adaptabilidade Estabilidade In-Place Tipo Bubble Sort O(n\u00b2) O(n\u00b2) O(n) Sim Sim Sim Compara\u00e7\u00e3o Selection Sort O(n\u00b2) O(n\u00b2) O(n\u00b2) N\u00e3o N\u00e3o Sim Compara\u00e7\u00e3o Insertion Sort O(n\u00b2) O(n\u00b2) O(n) Sim Sim Sim Compara\u00e7\u00e3o Quick Sort O(n\u00b2) O(n log n) O(n log n) N\u00e3o N\u00e3o* Sim Compara\u00e7\u00e3o Merge Sort O(n log n) O(n log n) O(n log n) N\u00e3o Sim N\u00e3o Compara\u00e7\u00e3o Heap Sort O(n log n) O(n log n) O(n log n) N\u00e3o N\u00e3o Sim Compara\u00e7\u00e3o Shell Sort O(n\u00b2) O(n log n) O(n log n) Sim N\u00e3o Sim Compara\u00e7\u00e3o Counting Sort O(n + k) O(n + k) O(n + k) N\u00e3o Sim N\u00e3o N\u00e3o-compara\u00e7\u00e3o Radix Sort (LSD) O(n \u00d7 w) O(n \u00d7 w) O(n \u00d7 w) N\u00e3o Sim N\u00e3o N\u00e3o-compara\u00e7\u00e3o Radix Sort (MSD) O(n \u00d7 w) O(n \u00d7 w) O(n \u00d7 w) N\u00e3o Sim N\u00e3o N\u00e3o-compara\u00e7\u00e3o <p>Nota: Quick Sort pode ser implementado como est\u00e1vel com espa\u00e7o adicional</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#5-complexidade-linear-vs-linearitmica","title":"5. Complexidade Linear vs Linear\u00edtmica","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#51-algoritmos-linearitmicos-on-log-n","title":"5.1 Algoritmos Linear\u00edtmicos (O(n log n))","text":"<ul> <li>Baseados em compara\u00e7\u00e3o por valor de chave;</li> <li>Mais amplos: Podem ser aplicados a diversos tipos de dados;</li> <li>Flex\u00edveis: Funcionam com diferentes tipos de chaves;</li> <li>Exemplos: Quick Sort, Merge Sort, Heap Sort;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#52-algoritmos-lineares-on","title":"5.2 Algoritmos Lineares (O(n))","text":"<ul> <li>Baseados em estrutura da chave (unidades, d\u00edgitos);</li> <li>Mais restritos: Dependem da representa\u00e7\u00e3o dos dados;</li> <li>Espec\u00edficos: Funcionam apenas com tipos num\u00e9ricos ou com chaves espec\u00edficas;</li> <li>Exemplos: Counting Sort, Radix Sort;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#53-trade-offs","title":"5.3 Trade-offs","text":"Aspecto Linear\u00edtmicos Lineares Aplicabilidade \u2b50\u2b50\u2b50\u2b50 (Ampla) \u2b50\u2b50 (Restrita) Requisitos \u2b50\u2b50\u2b50\u2b50 (Poucos) \u2b50 (Espec\u00edficos) Desempenho \u2b50\u2b50\u2b50 (Bom) \u2b50\u2b50\u2b50\u2b50\u2b50 (Excelente) Espa\u00e7o \u2b50\u2b50\u2b50 (Vari\u00e1vel) \u2b50\u2b50 (Maior consumo)"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#6-fatores-na-escolha-do-algoritmo","title":"6. Fatores na Escolha do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#61-tamanho-dos-dados","title":"6.1 Tamanho dos Dados","text":"<ul> <li>Pequenos conjuntos: Insertion Sort, Selection Sort</li> <li>M\u00e9dios conjuntos: Quick Sort, Heap Sort  </li> <li>Grandes conjuntos: Merge Sort, Radix Sort</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#62-estrutura-dos-dados","title":"6.2 Estrutura dos Dados","text":"<ul> <li>Quase ordenados: Insertion Sort, Bubble Sort</li> <li>Aleat\u00f3rios: Quick Sort, Heap Sort</li> <li>Com duplicatas: Algoritmos est\u00e1veis</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#63-restricoes-de-memoria","title":"6.3 Restri\u00e7\u00f5es de Mem\u00f3ria","text":"<ul> <li>Mem\u00f3ria limitada: Algoritmos in-place (Quick Sort, Heap Sort)</li> <li>Mem\u00f3ria abundante: Merge Sort, algoritmos n\u00e3o in-place</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/introducao/#64-tipo-de-dados","title":"6.4 Tipo de Dados","text":"<ul> <li>Num\u00e9ricos: Counting Sort, Radix Sort</li> <li>Gen\u00e9ricos: Algoritmos baseados em compara\u00e7\u00e3o</li> <li>Estruturas complexas: Algoritmos est\u00e1veis</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/","title":"Merge Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Merge Sort (Ordena\u00e7\u00e3o por Mistura) \u00e9 um algoritmo de ordena\u00e7\u00e3o eficiente que segue a abordagem \"dividir para conquistar\". Ele divide recursivamente o array em partes menores, ordena essas partes e depois as combina (merge) para produzir o array ordenado final.</p> <p>Princ\u00edpio fundamental: \"Dividir, ordenar e combinar\" - quebra o problema em subproblemas menores, resolve cada subproblema e combina as solu\u00e7\u00f5es.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#2-implementacao-do-merge-sort","title":"2. Implementa\u00e7\u00e3o do Merge Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#21-funcao-principal-de-ordenacao","title":"2.1 Fun\u00e7\u00e3o Principal de Ordena\u00e7\u00e3o","text":"Fun\u00e7\u00e3o principal do Merge Sort:<pre><code>void merge_sort(int *v, int l, int r) {\n    if (l &gt;= r) return; // Caso base: subarray de tamanho 0 ou 1\n\n    int m = (r + l) / 2; // Ponto m\u00e9dio para divis\u00e3o\n\n    // Divis\u00e3o recursiva\n    merge_sort(v, l, m);     // Ordenar metade esquerda\n    merge_sort(v, m + 1, r); // Ordenar metade direita\n\n    // Combina\u00e7\u00e3o das partes ordenadas\n    merge(v, l, m, r);      // Intercalar as duas metades\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#22-funcao-de-combinacao-merge","title":"2.2 Fun\u00e7\u00e3o de Combina\u00e7\u00e3o (Merge)","text":"Fun\u00e7\u00e3o de intercala\u00e7\u00e3o:<pre><code>void merge(int *v, int l, int m, int r) {\n    int tam = r + 1 - l; // Tamanho do subarray\n    int *aux = malloc(sizeof(int) * tam); // Vetor auxiliar\n\n    int i = l;     // \u00cdndice do subvetor esquerdo\n    int j = m + 1; // \u00cdndice do subvetor direito  \n    int k = 0;     // \u00cdndice do vetor auxiliar\n\n    // Intercalar enquanto ambos os subvetores t\u00eam elementos\n    while (i &lt;= m &amp;&amp; j &lt;= r) {\n        if (v[i] &lt;= v[j]) {\n            aux[k++] = v[i++]; // Elemento da esquerda \u00e9 menor\n        } else {\n            aux[k++] = v[j++]; // Elemento da direita \u00e9 menor\n        }\n    }\n\n    // Copiar elementos restantes do subvetor esquerdo\n    while (i &lt;= m) {\n        aux[k++] = v[i++];\n    }\n\n    // Copiar elementos restantes do subvetor direito\n    while (j &lt;= r) {\n        aux[k++] = v[j++];\n    }\n\n    // Copiar do vetor auxiliar de volta para o original\n    for (k = 0, i = l; i &lt;= r; i++, k++) {\n        v[i] = aux[k];\n    }\n\n    free(aux); // Liberar mem\u00f3ria alocada\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo: [38, 27, 43, 3, 9, 82, 10]<pre><code>Divis\u00e3o:\n[38, 27, 43, 3, 9, 82, 10]\n[38, 27, 43, 3] | [9, 82, 10]\n[38, 27] | [43, 3] | [9, 82] | [10]\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nCombina\u00e7\u00e3o:\n[27, 38] | [3, 43] | [9, 82] | [10]\n[3, 27, 38, 43] | [9, 10, 82]\n[3, 9, 10, 27, 38, 43, 82]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#32-visualizacao-grafica","title":"3.2 Visualiza\u00e7\u00e3o Gr\u00e1fica","text":"Exemplo:<pre><code>Array inicial: [38, 27, 43, 3, 9, 82, 10]\n\nDivis\u00e3o recursiva:\nN\u00edvel 0: [38, 27, 43, 3, 9, 82, 10]\nN\u00edvel 1: [38, 27, 43, 3] | [9, 82, 10]\nN\u00edvel 2: [38, 27] | [43, 3] | [9, 82] | [10]\nN\u00edvel 3: [38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nCombina\u00e7\u00e3o recursiva:\n[27, 38] | [3, 43] | [9, 82] | [10]\n[3, 27, 38, 43] | [9, 10, 82]\n[3, 9, 10, 27, 38, 43, 82]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade N\u00e3o Adaptabilidade Sim In-Place N\u00e3o Lista Encadeada Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n log n) Sempre divide ao meio Caso m\u00e9dio O(n log n) Ordem aleat\u00f3ria Pior caso O(n log n) Ordem inversa ou qualquer Complexidade de espa\u00e7o O(n) Vetor auxiliar"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Complexidade garantida: Sempre O(n log n);</li> <li>Est\u00e1vel: Mant\u00e9m ordem relativa de elementos iguais;</li> <li>Previs\u00edvel: Performance consistente;</li> <li>Bom para dados externos: Funciona bem com arquivos grandes;</li> <li>Paraleliz\u00e1vel: F\u00e1cil de implementar de forma paralela;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Uso de mem\u00f3ria: Requer O(n) de espa\u00e7o adicional;</li> <li>N\u00e3o in-place: Precisa de vetor auxiliar;</li> <li>Overhead de recurs\u00e3o: Chamadas recursivas podem ser custosas;</li> <li>Slower constant factors: Mais lento que Quick Sort na pr\u00e1tica;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/merge/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Quando estabilidade \u00e9 importante;</li> <li>Para ordenar listas encadeadas;</li> <li>Quando performance consistente \u00e9 necess\u00e1ria;</li> <li>Para dados externos ou arquivos grandes;</li> <li>Em implementa\u00e7\u00f5es paralelas;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/","title":"Quick Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Quick Sort (Ordena\u00e7\u00e3o R\u00e1pida) \u00e9 um algoritmo de ordena\u00e7\u00e3o eficiente que segue a abordagem \"dividir para conquistar\". Desenvolvido por Tony Hoare em 1959, \u00e9 um dos algoritmos mais utilizados na pr\u00e1tica devido \u00e0 sua excelente performance.</p> <p>Princ\u00edpio fundamental: \"Selecionar um piv\u00f4, particionar e ordenar recursivamente\" - escolhe um elemento como piv\u00f4, rearranja o array colocando elementos menores \u00e0 esquerda e maiores \u00e0 direita, e aplica recursivamente o processo.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#2-implementacao-do-quick-sort","title":"2. Implementa\u00e7\u00e3o do Quick Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#21-funcao-principal-de-ordenacao","title":"2.1 Fun\u00e7\u00e3o Principal de Ordena\u00e7\u00e3o","text":"Fun\u00e7\u00e3o principal do Quick Sort:<pre><code>void quick_sort(int *v, int l, int r) {\n    // Condi\u00e7\u00e3o de parada: subarray de tamanho 0 ou 1\n    if (r &lt;= l) return;\n\n    // Posicionar o piv\u00f4 e obter sua posi\u00e7\u00e3o final\n    int p = partition(v, l, r);\n\n    // Ordenar recursivamente os subarrays\n    quick_sort(v, l, p - 1); // Elementos menores que o piv\u00f4\n    quick_sort(v, p + 1, r);  // Elementos maiores que o piv\u00f4\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#22-particionamento-com-pivo-a-direita-sedgewick","title":"2.2 Particionamento com Piv\u00f4 \u00e0 Direita (Sedgewick)","text":"Parti\u00e7\u00e3o com piv\u00f4 \u00e0 direita:<pre><code>int partition(int *v, int l, int r) {\n    int pivot = v[r];  // O piv\u00f4 \u00e9 o \u00faltimo elemento\n    int i = l - 1, j = r;\n\n    // Enquanto os \u00edndices n\u00e3o se cruzarem\n    while (i &lt; j) {\n        // Procurar elementos maiores que o piv\u00f4 (da esquerda para direita)\n        while (v[++i] &lt; pivot) ; \n\n        // Procurar elementos menores que o piv\u00f4 (da direita para esquerda)\n        while (v[--j] &gt; pivot &amp;&amp; j &gt; l) ; \n\n        // Se o maior est\u00e1 atr\u00e1s do menor, troca-os\n        if (i &lt; j) {\n            exch(v[i], v[j]); // Troca os elementos\n        }\n    }\n\n    // Posiciona o piv\u00f4 na posi\u00e7\u00e3o correta\n    exch(v[i], v[r]); \n\n    // Retorna a nova posi\u00e7\u00e3o do piv\u00f4\n    return i;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#23-particionamento-com-pivo-a-esquerda-sedgewick","title":"2.3 Particionamento com Piv\u00f4 \u00e0 Esquerda (Sedgewick)","text":"Parti\u00e7\u00e3o com piv\u00f4 \u00e0 esquerda:<pre><code>int partition(int *v, int l, int r) {\n    int pivot = v[l];    // O piv\u00f4 \u00e9 o primeiro elemento\n    int i = l;           // \u00cdndice que avan\u00e7a da esquerda\n    int j = r + 1;       // \u00cdndice que recua da direita\n\n    while (i &lt; j) {\n        // Procurar elementos maiores que o piv\u00f4 (E\u2192D)\n        while (v[++i] &lt; pivot &amp;&amp; i &lt; r) ; \n\n        // Procurar elementos menores que o piv\u00f4 (D\u2192E)\n        while (pivot &lt; v[--j] &amp;&amp; j &gt; l) ; \n\n        // Se os elementos est\u00e3o na ordem errada, troca-os\n        if (i &lt; j) {\n            exch(v[i], v[j]);  \n        }\n    }\n\n    // Posiciona o piv\u00f4 na posi\u00e7\u00e3o correta\n    exch(v[l], v[j]);  \n\n    return j;  // Retorna a posi\u00e7\u00e3o do piv\u00f4\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#31-exemplo-com-array-pequeno-pivo-a-direita","title":"3.1 Exemplo com Array Pequeno (Piv\u00f4 \u00e0 Direita)","text":"Exemplo: [3, 7, 8, 5, 2, 1, 9, 5, 4]<pre><code>Array inicial: [3, 7, 8, 5, 2, 1, 9, 5, 4]\nPiv\u00f4: 4 (\u00faltimo elemento)\n\nPasso 1: i encontra 7 (&gt;4), j encontra 1 (&lt;4) \u2192 Troca: [3, 1, 8, 5, 2, 7, 9, 5, 4]\nPasso 2: i encontra 8 (&gt;4), j encontra 2 (&lt;4) \u2192 Troca: [3, 1, 2, 5, 8, 7, 9, 5, 4]\nPasso 3: i encontra 5 (&gt;4), j encontra 2 \u2192 i &gt; j, para\nPosiciona piv\u00f4: [3, 1, 2, 4, 8, 7, 9, 5, 5]\n\nRecurs\u00e3o: \nEsquerda: [3, 1, 2] \u2192 ordena\nDireita: [8, 7, 9, 5, 5] \u2192 ordena\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#32-visualizacao-do-particionamento","title":"3.2 Visualiza\u00e7\u00e3o do Particionamento","text":"Implementa\u00e7\u00e3o:<pre><code>Array: [3, 7, 8, 5, 2, 1, 9, 5, 4]\nPiv\u00f4: 4\n\ni avan\u00e7a: 3\u2713, 7\u2717 (para em 7)\nj recua: 5\u2713, 9\u2713, 5\u2713, 1\u2717 (para em 1)\nTroca 7\u21941: [3, 1, 8, 5, 2, 7, 9, 5, 4]\n\ni avan\u00e7a: 8\u2717 (para em 8)\nj recua: 2\u2717 (para em 2)\nTroca 8\u21942: [3, 1, 2, 5, 8, 7, 9, 5, 4]\n\ni avan\u00e7a: 5\u2717 (para em 5)\nj recua: 5\u2713, 8\u2713 \u2192 j=2, i=3 \u2192 i&gt;j, para\nTroca piv\u00f4 4\u21945: [3, 1, 2, 4, 8, 7, 9, 5, 5]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade N\u00e3o Adaptabilidade Sim In-Place Sim Lista Encadeada Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n log n) Piv\u00f4 sempre divide ao meio Caso m\u00e9dio O(n log n) Piv\u00f4 escolhido aleatoriamente Pior caso O(n\u00b2) Piv\u00f4 sempre menor/maior elemento Complexidade de espa\u00e7o O(log n) Pilha de recurs\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Muito r\u00e1pido na pr\u00e1tica: Constant factors menores;</li> <li>Ordena\u00e7\u00e3o in-place: Baixo uso de mem\u00f3ria adicional;</li> <li>Cache-friendly: Bom uso da hierarquia de mem\u00f3ria;</li> <li>Paraleliz\u00e1vel: Pode ser implementado de forma paralela;</li> <li>Adapt\u00e1vel: Performance melhora com arrays parcialmente ordenados;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>N\u00e3o est\u00e1vel: Pode alterar ordem relativa de elementos iguais;</li> <li>Pior caso O(n\u00b2): Performance degrada com piv\u00f4s ruins;</li> <li>Dependente da escolha do piv\u00f4: Performance varia com a estrat\u00e9gia;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Para arrays grandes na mem\u00f3ria principal;</li> <li>Quando velocidade \u00e9 cr\u00edtica;</li> <li>Para implementa\u00e7\u00f5es gerais de ordena\u00e7\u00e3o;</li> <li>Quando mem\u00f3ria \u00e9 limitada;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#5-estrategias-de-escolha-do-pivo","title":"5. Estrat\u00e9gias de Escolha do Piv\u00f4","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#51-mediana-de-tres-otimizacao-comum","title":"5.1 Mediana de Tr\u00eas (Otimiza\u00e7\u00e3o Comum)","text":"Escolha do piv\u00f4 por mediana de tr\u00eas:<pre><code>int median_of_three(int *v, int l, int r) {\n    int m = (l + r) / 2;\n\n    // Ordena v[l], v[m], v[r]\n    if (v[l] &gt; v[m]) exch(v[l], v[m]);\n    if (v[l] &gt; v[r]) exch(v[l], v[r]);\n    if (v[m] &gt; v[r]) exch(v[m], v[r]);\n\n    // Coloca a mediana na posi\u00e7\u00e3o r-1\n    exch(v[m], v[r - 1]);\n    return v[r - 1];\n}\n\nint partition_median(int *v, int l, int r) {\n    int pivot = median_of_three(v, l, r);\n    int i = l, j = r - 1;\n\n    while (true) {\n        while (v[++i] &lt; pivot) ;\n        while (v[--j] &gt; pivot) ;\n        if (i &lt; j) {\n            exch(v[i], v[j]);\n        } else {\n            break;\n        }\n    }\n    exch(v[i], v[r - 1]);\n    return i;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/quick/#52-outras-estrategias","title":"5.2 Outras Estrat\u00e9gias","text":"<ul> <li>Primeiro elemento: Simples mas vulner\u00e1vel;</li> <li>\u00daltimo elemento: Similar ao primeiro;</li> <li>Elemento central: Melhor que extremos;</li> <li>Aleat\u00f3rio: Boa performance esperada;</li> <li>Mediana de tr\u00eas: Excelente performance pr\u00e1tica;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/","title":"Radix Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Radix Sort (Ordena\u00e7\u00e3o por Raiz) \u00e9 um algoritmo de ordena\u00e7\u00e3o n\u00e3o comparativo que decomp\u00f5e as chaves em partes menores (d\u00edgitos, bytes ou caracteres) e ordena os elementos com base nessas partes. \u00c9 particularmente eficiente para ordenar n\u00fameros inteiros grandes e strings.</p> <p>Princ\u00edpio fundamental: \"Decompor, ordenar por partes e combinar\" - decomp\u00f5e a chave em d\u00edgitos/bytes, ordena de forma est\u00e1vel a partir do d\u00edgito menos ou mais significativo, e combina os resultados.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#2-implementacao-do-radix-sort","title":"2. Implementa\u00e7\u00e3o do Radix Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#21-radix-sort-lsd-least-significant-digit","title":"2.1 Radix Sort LSD (Least Significant Digit)","text":"Radix Sort LSD para inteiros:<pre><code>#define bytesword 4  // Tamanho de um int (4 bytes)\n#define bitsbyte 8   // Bits por byte\n#define R (1 &lt;&lt; bitsbyte)  // Tamanho do alfabeto (256)\n\n// Macro para extrair o d\u00edgito/byte na posi\u00e7\u00e3o D\n#define digit(N, D) (((N) &gt;&gt; ((D) * bitsbyte)) &amp; (R - 1))\n\nvoid radix_sortLSD(int *v, int l, int r) {\n    int i, w, k;\n    int n = r - l + 1;\n    int *aux = new int[n];\n    int *count = new int[R + 1];\n\n    // Processa cada byte (do menos significativo ao mais significativo)\n    for (w = 0; w &lt; bytesword; w++) {\n        // Zera o array de contagem\n        for (i = 0; i &lt;= R; i++) count[i] = 0;\n\n        // Fase 1: Contar frequ\u00eancias do byte atual\n        for (i = l; i &lt;= r; i++) count[digit(v[i], w) + 1]++;\n\n        // Fase 2: Calcular posi\u00e7\u00f5es acumuladas\n        for (k = 1; k &lt; R; k++) count[k] += count[k - 1];\n\n        // Fase 3: Distribuir elementos no array auxiliar\n        for (i = l; i &lt;= r; i++) aux[count[digit(v[i], w)]++] = v[i];\n\n        // Fase 4: Copiar de volta para o array original\n        for (i = l; i &lt;= r; i++) v[i] = aux[i - l];\n    }\n\n    delete[] aux;\n    delete[] count;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#22-radix-sort-msd-most-significant-digit","title":"2.2 Radix Sort MSD (Most Significant Digit)","text":"Radix Sort MSD para strings:<pre><code>#define maxstring 100  // Tamanho m\u00e1ximo da string\n#define R 256          // Tamanho do alfabeto ASCII\n\nvoid radixMSD(char a[][maxstring], int l, int r, int d) {\n    if (r &lt;= l) return;\n\n    int n = r - l + 1;\n    char (*aux)[maxstring] = new char[n][maxstring];\n    int *count = new int[R + 2]();  // +2 para seguran\u00e7a\n\n    // Contar frequ\u00eancias do caractere na posi\u00e7\u00e3o d\n    for (int i = l; i &lt;= r; i++) {\n        int pos = (unsigned char)a[i][d] + 1;\n        count[pos]++;\n    }\n\n    // Calcular posi\u00e7\u00f5es acumuladas\n    for (int i = 1; i &lt;= R + 1; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Distribuir strings no array auxiliar\n    for (int i = l; i &lt;= r; i++) {\n        int pos = (unsigned char)a[i][d];\n        strcpy(aux[count[pos]++], a[i]);\n    }\n\n    // Copiar de volta para o array original\n    for (int i = l; i &lt;= r; i++) {\n        strcpy(a[i], aux[i - l]);\n    }\n\n    // Recurs\u00e3o para cada subgrupo (exceto grupo de strings terminadas)\n    for (int i = 1; i &lt; R; i++) {\n        int start = l + count[i - 1];\n        int end = l + count[i] - 1;\n        if (start &lt; end) {\n            radixMSD(a, start, end, d + 1);\n        }\n    }\n\n    delete[] aux;\n    delete[] count;\n}\n\n// Fun\u00e7\u00e3o wrapper para MSD\nvoid radix_sortMSD(char a[][maxstring], int l, int r) {\n    radixMSD(a, l, r, 0);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#31-exemplo-lsd-com-numeros","title":"3.1 Exemplo LSD com N\u00fameros","text":"Exemplo LSD: [170, 45, 75, 90, 802, 24, 2, 66]<pre><code>Array inicial: [170, 45, 75, 90, 802, 24, 2, 66]\n\nOrdena\u00e7\u00e3o por unidade (d\u00edgito menos significativo):\n802, 002, 024, 045, 066, 170, 075, 090\n\nOrdena\u00e7\u00e3o por dezena:\n002, 024, 045, 066, 075, 090, 170, 802\n\nOrdena\u00e7\u00e3o por centena (d\u00edgito mais significativo):\n002, 024, 045, 066, 075, 090, 170, 802\n\nResultado final: [2, 24, 45, 66, 75, 90, 170, 802]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#32-exemplo-msd-com-strings","title":"3.2 Exemplo MSD com Strings","text":"<p>```cpp title=\"Exemplo MSD: [\"aab\", \"bba\", \"aaa\", \"baaa\"]\" Array inicial: [\"aab\", \"bba\", \"aaa\", \"baaa\"]</p> <p>Primeira passagem (primeiro caractere): Grupo 'a': [\"aab\", \"aaa\"] Grupo 'b': [\"bba\", \"baaa\"]</p> <p>Segunda passagem (segundo caractere): Grupo 'a' \u2192 \"aab\", \"aaa\" \u2192 ordenado por segundo caractere Grupo 'b' \u2192 \"bba\", \"baaa\" \u2192 ordenado por segundo caractere</p> <p>Resultado final: [\"aaa\", \"aab\", \"baaa\", \"bba\"] ```</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto LSD Radix Sort MSD Radix Sort Estabilidade Sim N\u00e3o Adaptabilidade N\u00e3o Parcialmente In-Place N\u00e3o N\u00e3o N\u00e3o Comparativo Sim Sim"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(w \u00d7 n) w = tamanho da chave, n = n\u00famero de elementos Caso m\u00e9dio O(w \u00d7 n) Performance consistente Pior caso O(w \u00d7 n) Garantido em todos os casos Complexidade de espa\u00e7o O(n + R) Array auxiliar + array de contagem"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Complexidade linear O(w \u00d7 n): Muito r\u00e1pido para chaves de tamanho fixo;</li> <li>N\u00e3o comparativo: N\u00e3o depende de compara\u00e7\u00f5es entre elementos;</li> <li>Eficiente para grandes datasets: Performance previs\u00edvel;</li> <li>Est\u00e1vel (LSD): Mant\u00e9m ordem relativa de elementos iguais;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>N\u00e3o in-place: Requer mem\u00f3ria adicional O(n + R);</li> <li>Apenas para tipos espec\u00edficos: Limitado a chaves que podem ser decompostas;</li> <li>Ineficiente para chaves longas: Se w &gt;&gt; n, torna-se ineficiente;</li> <li>Dependente da base: Performance varia com o tamanho do alfabeto R;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Para ordenar inteiros com tamanho fixo;</li> <li>Para ordenar strings com padr\u00f5es espec\u00edficos;</li> <li>Quando w \u00e9 pequeno e conhecido;</li> <li>Em aplica\u00e7\u00f5es de processamento de dados onde chaves s\u00e3o uniformes;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/radix/#5-aplicacoes-especiais","title":"5. Aplica\u00e7\u00f5es Especiais","text":"<ul> <li>Ordena\u00e7\u00e3o de inteiros grandes: CPFs, n\u00fameros de s\u00e9rie, etc.;</li> <li>Processamento de strings: Dicion\u00e1rios, \u00edndices de texto;</li> <li>Banco de dados: Ordena\u00e7\u00e3o de chaves prim\u00e1rias;</li> <li>Computa\u00e7\u00e3o gr\u00e1fica: Ordena\u00e7\u00e3o de pixels/vertices;</li> <li>Compress\u00e3o de dados: Ordena\u00e7\u00e3o para algoritmos de compress\u00e3o;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/","title":"Selection Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Selection Sort (Ordena\u00e7\u00e3o por Sele\u00e7\u00e3o) \u00e9 um algoritmo de ordena\u00e7\u00e3o simples que funciona selecionando repetidamente o menor (ou maior) elemento da parte n\u00e3o ordenada do array e movendo-o para a posi\u00e7\u00e3o correta.</p> <p>Princ\u00edpio fundamental: \"Selecionar e posicionar\" - a cada itera\u00e7\u00e3o, encontra-se o menor elemento restante e coloca-o na posi\u00e7\u00e3o correta.</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#2-implementacao-do-selection-sort","title":"2. Implementa\u00e7\u00e3o do Selection Sort","text":"Implementa\u00e7\u00e3o:<pre><code>void selection_sort(int v[], int l, int r) {\n    int menor;\n\n    for (int i = l; i &lt; r; i++) {         // Loop externo: O(n)\n        menor = i;                         // Assume que o atual \u00e9 o menor\n\n        // Encontra o menor elemento na parte n\u00e3o ordenada\n        for (int j = i + 1; j &lt;= r; j++) { // Loop interno: O(n)\n            if (v[j] &lt; v[menor]) {         // Compara\u00e7\u00e3o\n                menor = j;                 // Atualiza o \u00edndice do menor\n            }\n        }\n\n        // Troca o menor elemento com o elemento na posi\u00e7\u00e3o i\n        if (i != menor) {\n            int temp = v[i];               // Troca: O(1)\n            v[i] = v[menor];\n            v[menor] = temp;\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo:<pre><code>Array inicial: [64, 25, 12, 22, 11]\n\nPasso 1 (i=0):\n- Encontrar menor: 11 (\u00edndice 4)\n- Trocar v[0] (64) com v[4] (11)\n- Array: [11, 25, 12, 22, 64]\n\nPasso 2 (i=1):\n- Encontrar menor: 12 (\u00edndice 2)  \n- Trocar v[1] (25) com v[2] (12)\n- Array: [11, 12, 25, 22, 64]\n\nPasso 3 (i=2):\n- Encontrar menor: 22 (\u00edndice 3)\n- Trocar v[2] (25) com v[3] (22)\n- Array: [11, 12, 22, 25, 64]\n\nPasso 4 (i=3):\n- Encontrar menor: 25 (\u00edndice 3)\n- Sem troca necess\u00e1ria\n- Array final ordenado: [11, 12, 22, 25, 64]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#32-visualizacao-grafica","title":"3.2 Visualiza\u00e7\u00e3o Gr\u00e1fica","text":"Implementa\u00e7\u00e3o:<pre><code>Array inicial: [64, 25, 12, 22, 11]\n\nItera\u00e7\u00e3o 0: [64, 25, 12, 22, 11] \u2192 Menor: 11 \u2192 Troca: [11, 25, 12, 22, 64]\nItera\u00e7\u00e3o 1: [11, 25, 12, 22, 64] \u2192 Menor: 12 \u2192 Troca: [11, 12, 25, 22, 64]  \nItera\u00e7\u00e3o 2: [11, 12, 25, 22, 64] \u2192 Menor: 22 \u2192 Troca: [11, 12, 22, 25, 64]\nItera\u00e7\u00e3o 3: [11, 12, 22, 25, 64] \u2192 Menor: 25 \u2192 Sem troca\n\nArray ordenado: [11, 12, 22, 25, 64]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#41-caracteristicas_1","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade N\u00e3o Adaptabilidade N\u00e3o In-Place Sim Lista Encadeada N\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n\u00b2) Array j\u00e1 ordenado Caso m\u00e9dio O(n\u00b2) Array em ordem aleat\u00f3ria Pior caso O(n\u00b2) Array em ordem inversa"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Simplicidade: F\u00e1cil de implementar e entender;</li> <li>Baixo overhead: Pouca mem\u00f3ria adicional necess\u00e1ria;</li> <li>Poucas trocas: Apenas n-1 trocas no m\u00e1ximo;</li> <li>\u00datil para arrays pequenos ou quase ordenados;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Complexidade quadr\u00e1tica: Ineficiente para arrays grandes;</li> <li>N\u00e3o adaptativo: Performance n\u00e3o melhora com arrays parcialmente ordenados;</li> <li>N\u00e3o est\u00e1vel: N\u00e3o mant\u00e9m ordem relativa de elementos iguais;</li> <li>Pouco eficiente: Comparado a algoritmos O(n log n);</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/selection/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Arrays muito pequenos (n &lt; 20)</li> <li>Mem\u00f3ria extremamente limitada </li> <li>Implementa\u00e7\u00e3o educacional</li> <li>Quando trocas s\u00e3o custosas (em termos de hardware)</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/","title":"Shell Sort","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>O Shell Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o que generaliza o Insertion Sort, permitindo a troca de elementos que est\u00e3o distantes uns dos outros. Desenvolvido por Donald Shell em 1959, \u00e9 uma melhoria significativa sobre algoritmos de ordena\u00e7\u00e3o simples.</p> <p>Princ\u00edpio fundamental: \"Ordena\u00e7\u00e3o por incrementos decrescentes\" - o algoritmo realiza v\u00e1rias passadas pelo array com intervalos (gaps) cada vez menores, at\u00e9 que o intervalo seja 1 (equivalente ao Insertion Sort).</p>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#2-implementacao-do-shell-sort","title":"2. Implementa\u00e7\u00e3o do Shell Sort","text":"Implementa\u00e7\u00e3o:<pre><code>void shell_sort(int v[], int l, int r) {\n    int h = 1; // h - dist\u00e2ncia (gap)\n\n    // Calcular o maior gap poss\u00edvel usando a sequ\u00eancia 3x+1\n    while (h &lt; (r - l + 1) / 3) {\n        h = 3 * h + 1;\n    }\n\n    // Reduzir gradualmente o gap at\u00e9 1\n    while (h &gt;= 1) {\n        // Aplicar insertion sort para cada subarray com gap h\n        for (int i = l + h; i &lt;= r; i++) {\n            // Ordenar por inser\u00e7\u00e3o com gap h\n            for (int j = i; j &gt;= l + h &amp;&amp; v[j] &lt; v[j - h]; j -= h) {\n                exch(v[j], v[j - h]);\n            }\n        }\n        h = h / 3; // Reduzir o gap\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#31-exemplo-com-array-pequeno","title":"3.1 Exemplo com Array Pequeno","text":"Exemplo:<pre><code>Array inicial: [64, 34, 25, 12, 22, 11, 90, 8]\n\nPasso 1: Calcular h m\u00e1ximo\n- h inicial: 1\n- h = 4 (sequ\u00eancia: 1, 4, 13... mas 13 &gt; 8/3, ent\u00e3o h=4)\n\nPasso 2: h = 4\nSubarrays com gap 4: \n- [64, 22, 90] \u2192 ordenado: [22, 64, 90]\n- [34, 11, 8] \u2192 ordenado: [8, 11, 34]  \n- [25, 12] \u2192 ordenado: [12, 25]\nArray ap\u00f3s h=4: [22, 8, 12, 11, 64, 34, 90, 25]\n\nPasso 3: h = 1\nAplicar insertion sort normal:\nArray final ordenado: [8, 11, 12, 22, 25, 34, 64, 90]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#32-visualizacao-grafica","title":"3.2 Visualiza\u00e7\u00e3o Gr\u00e1fica","text":"Implementa\u00e7\u00e3o:<pre><code>Array inicial: [64, 34, 25, 12, 22, 11, 90, 8]\n\nh=4: \n- Subarray 1: [64, 22, 90] \u2192 [22, 64, 90]\n- Subarray 2: [34, 11, 8] \u2192 [8, 11, 34]\n- Subarray 3: [25, 12] \u2192 [12, 25]\nResultado: [22, 8, 12, 11, 64, 34, 90, 25]\n\nh=1: Insertion Sort completo\nResultado final: [8, 11, 12, 22, 25, 34, 64, 90]\n</code></pre>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#4-analise-do-algoritmo","title":"4. An\u00e1lise do Algoritmo","text":""},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Quick Sort Estabilidade Sim Adaptabilidade N\u00e3o In-Place Sim Lista Encadeada N\u00e3o"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#42-complexidade","title":"4.2 Complexidade","text":"Caso Complexidade Descri\u00e7\u00e3o Melhor caso O(n log n) Sempre divide ao meio Caso m\u00e9dio O(n^3/2) Ordem aleat\u00f3ria Pior caso O(n\u00b2) Ordem inversa ou qualquer Complexidade de espa\u00e7o O(n) Vetor auxiliar"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Melhoria significativa sobre Insertion Sort para arrays grandes;</li> <li>Eficiente para arrays m\u00e9dios (n \u2248 1000-10000);</li> <li>Ordena\u00e7\u00e3o in-place: Baixo uso de mem\u00f3ria adicional;</li> <li>F\u00e1cil de implementar;</li> <li>Bom desempenho pr\u00e1tico apesar da complexidade te\u00f3rica;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Complexidade dif\u00edcil de analisar matematicamente;</li> <li>N\u00e3o est\u00e1vel: Pode alterar ordem relativa de elementos iguais;</li> <li>Performance varia com a sequ\u00eancia de gaps escolhida;</li> <li>N\u00e3o \u00e9 \u00f3timo: Existem algoritmos O(n log n) mais eficientes;</li> </ul>"},{"location":"disciplinas/EDA1/Algoritmos%20de%20ordenacao/shell/#45-quando-escolher","title":"4.5 Quando Escolher","text":"<ul> <li>Arrays de tamanho m\u00e9dio (100-10000 elementos);</li> <li>Quando mem\u00f3ria \u00e9 limitada;</li> <li>Implementa\u00e7\u00f5es educacionais;</li> <li>Como pr\u00e9-processamento para outros algoritmos;</li> </ul>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/","title":"Listas Duplamente Encadeadas em C","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>As listas duplamente encadeadas s\u00e3o estruturas de dados onde cada n\u00f3 armazena: - A informa\u00e7\u00e3o do elemento; - Ponteiro para o n\u00f3 anterior; - Ponteiro para o pr\u00f3ximo n\u00f3;</p> <p>Caracter\u00edsticas principais:</p> <ul> <li>\u00datil quando ocorrem muitas inser\u00e7\u00f5es e remo\u00e7\u00f5es, especialmente de elementos intermedi\u00e1rios;</li> <li>Permite navega\u00e7\u00e3o bidirecional (para frente e para tr\u00e1s);</li> <li>O n\u00f3 anterior do primeiro elemento e o pr\u00f3ximo do \u00faltimo elemento s\u00e3o NULL;</li> </ul> <p></p>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#21-definicao-do-no","title":"2.1 Defini\u00e7\u00e3o do N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>typedef struct node {\n    int info;           // Informa\u00e7\u00e3o armazenada no n\u00f3\n    struct node *ant;   // Ponteiro para o n\u00f3 anterior\n    struct node *prox;  // Ponteiro para o pr\u00f3ximo n\u00f3\n} no;\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#22-cabeca-da-lista","title":"2.2 Cabe\u00e7a da Lista","text":"Implementa\u00e7\u00e3o:<pre><code>typedef struct head {\n    int tam;           // Tamanho da lista (n\u00famero de elementos)\n    no *primeiro;      // Ponteiro para o primeiro n\u00f3 da lista\n    no *ultimo;        // Ponteiro para o \u00faltimo n\u00f3 da lista\n} cabeca;\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#3-operacoes-basicas","title":"3. Opera\u00e7\u00f5es B\u00e1sicas","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#31-inserir-no-inicio","title":"3.1 Inserir no In\u00edcio","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_inicio(cabeca *lista, no *elem) {\n    elem-&gt;ant = NULL;                // Novo elemento n\u00e3o tem anterior (ser\u00e1 o primeiro)\n    elem-&gt;prox = lista-&gt;primeiro;    // Novo elemento aponta para o atual primeiro\n\n    if (lista-&gt;primeiro != NULL) {\n        lista-&gt;primeiro-&gt;ant = elem; // Atual primeiro agora tem novo elemento como anterior\n    } else {\n        lista-&gt;ultimo = elem;        // Se lista estava vazia, novo elemento tamb\u00e9m \u00e9 o \u00faltimo\n    }\n\n    lista-&gt;primeiro = elem;          // Cabe\u00e7a agora aponta para o novo elemento\n    lista-&gt;tam++;                    // Incrementa tamanho da lista\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#32-inserir-apos-um-no","title":"3.2 Inserir ap\u00f3s um N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_depois(cabeca *lista, no *ref, no *elem) {\n    elem-&gt;ant = ref;                 // Novo n\u00f3 aponta para refer\u00eancia como anterior\n    elem-&gt;prox = ref-&gt;prox;          // Novo n\u00f3 aponta para pr\u00f3ximo da refer\u00eancia\n\n    ref-&gt;prox = elem;                // Refer\u00eancia agora aponta para novo n\u00f3\n\n    if (elem-&gt;prox != NULL) {\n        elem-&gt;prox-&gt;ant = elem;      // Atualiza anterior do pr\u00f3ximo n\u00f3\n    } else {\n        lista-&gt;ultimo = elem;        // Se n\u00e3o h\u00e1 pr\u00f3ximo, novo n\u00f3 \u00e9 o \u00faltimo\n    }\n\n    lista-&gt;tam++;                    // Incrementa tamanho da lista\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#33-inserir-antes-de-um-no","title":"3.3 Inserir antes de um N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_antes(cabeca *lista, no *ref, no *elem) {\n    elem-&gt;ant = ref-&gt;ant;            // Novo n\u00f3 aponta para anterior da refer\u00eancia\n    elem-&gt;prox = ref;                // Novo n\u00f3 aponta para refer\u00eancia\n\n    ref-&gt;ant = elem;                 // Refer\u00eancia agora aponta para novo n\u00f3 como anterior\n\n    if (elem-&gt;ant != NULL) {\n        elem-&gt;ant-&gt;prox = elem;      // Atualiza pr\u00f3ximo do n\u00f3 anterior\n    } else {\n        lista-&gt;primeiro = elem;      // Se n\u00e3o h\u00e1 anterior, novo n\u00f3 \u00e9 o primeiro\n    }\n\n    lista-&gt;tam++;                    // Incrementa tamanho da lista\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#34-inserir-no-fim","title":"3.4 Inserir no Fim","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_fim(cabeca *lista, no *elem) {\n    elem-&gt;ant = lista-&gt;ultimo;       // Novo n\u00f3 aponta para \u00faltimo atual\n    elem-&gt;prox = NULL;               // Novo n\u00f3 ser\u00e1 o \u00faltimo (pr\u00f3ximo = NULL)\n\n    if (lista-&gt;ultimo != NULL) {\n        lista-&gt;ultimo-&gt;prox = elem;  // \u00daltimo atual aponta para novo n\u00f3\n    } else {\n        lista-&gt;primeiro = elem;      // Se lista estava vazia, novo n\u00f3 \u00e9 o primeiro\n    }\n\n    lista-&gt;ultimo = elem;            // Atualiza ponteiro para \u00faltimo\n    lista-&gt;tam++;                    // Incrementa tamanho da lista\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#35-remover-no","title":"3.5 Remover N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>void remover_no(cabeca *lista, no *lixo) {\n    // Atualiza ponteiros dos n\u00f3s vizinhos\n    if (lixo-&gt;ant != NULL) {\n        lixo-&gt;ant-&gt;prox = lixo-&gt;prox; // Anterior aponta para pr\u00f3ximo\n    } else {\n        lista-&gt;primeiro = lixo-&gt;prox; // Se era primeiro, atualiza cabe\u00e7a\n    }\n\n    if (lixo-&gt;prox != NULL) {\n        lixo-&gt;prox-&gt;ant = lixo-&gt;ant; // Pr\u00f3ximo aponta para anterior\n    } else {\n        lista-&gt;ultimo = lixo-&gt;ant;   // Se era \u00faltimo, atualiza cabe\u00e7a\n    }\n\n    lista-&gt;tam--;                    // Decrementa tamanho da lista\n    free(lixo);                      // Libera mem\u00f3ria do n\u00f3 removido\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#4-funcoes-auxiliares","title":"4. Fun\u00e7\u00f5es Auxiliares","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#41-criar-lista-vazia","title":"4.1 Criar Lista Vazia","text":"Implementa\u00e7\u00e3o:<pre><code>cabeca *criar_lista() {\n    cabeca *nova_lista = (cabeca *)malloc(sizeof(cabeca));\n    nova_lista-&gt;tam = 0;\n    nova_lista-&gt;primeiro = NULL;\n    nova_lista-&gt;ultimo = NULL;\n    return nova_lista;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#42-criar-novo-no","title":"4.2 Criar Novo N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>no *criar_no(int valor) {\n    no *novo_no = (no *)malloc(sizeof(no));\n    novo_no-&gt;info = valor;\n    novo_no-&gt;ant = NULL;\n    novo_no-&gt;prox = NULL;\n    return novo_no;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#43-imprimir-lista-frente-para-tras","title":"4.3 Imprimir Lista (Frente para Tr\u00e1s)","text":"Implementa\u00e7\u00e3o:<pre><code>void imprimir_frente(cabeca *lista) {\n    no *atual = lista-&gt;primeiro;\n    printf(\"Lista (frente): \");\n    while (atual != NULL) {\n        printf(\"%d \", atual-&gt;info);\n        atual = atual-&gt;prox;\n    }\n    printf(\"\\n\");\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#44-imprimir-lista-tras-para-frente","title":"4.4 Imprimir Lista (Tr\u00e1s para Frente)","text":"Implementa\u00e7\u00e3o:<pre><code>void imprimir_tras(cabeca *lista) {\n    no *atual = lista-&gt;ultimo;\n    printf(\"Lista (tr\u00e1s): \");\n    while (atual != NULL) {\n        printf(\"%d \", atual-&gt;info);\n        atual = atual-&gt;ant;\n    }\n    printf(\"\\n\");\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#45-buscar-elemento","title":"4.5 Buscar Elemento","text":"Implementa\u00e7\u00e3o:<pre><code>no *buscar_elemento(cabeca *lista, int valor) {\n    no *atual = lista-&gt;primeiro;\n\n    while (atual != NULL) {\n        if (atual-&gt;info == valor) {\n            return atual;\n        }\n        atual = atual-&gt;prox;\n    }\n\n    return NULL; // Elemento n\u00e3o encontrado\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#46-liberar-memoria-da-lista","title":"4.6 Liberar Mem\u00f3ria da Lista","text":"Implementa\u00e7\u00e3o:<pre><code>void liberar_lista(cabeca *lista) {\n    no *atual = lista-&gt;primeiro;\n    no *proximo;\n\n    while (atual != NULL) {\n        proximo = atual-&gt;prox;\n        free(atual);\n        atual = proximo;\n    }\n\n    free(lista);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#5-exemplo-de-uso-completo","title":"5. Exemplo de Uso Completo","text":"Implementa\u00e7\u00e3o:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Estruturas e fun\u00e7\u00f5es definidas acima...\n\nint main() {\n    // Criar lista vazia\n    cabeca *minha_lista = criar_lista();\n\n    // Inserir elementos\n    no *n1 = criar_no(10);\n    no *n2 = criar_no(20);\n    no *n3 = criar_no(30);\n\n    inserir_inicio(minha_lista, n1);\n    inserir_fim(minha_lista, n3);\n    inserir_depois(minha_lista, n1, n2);\n\n    // Imprimir lista\n    printf(\"Tamanho da lista: %d\\n\", minha_lista-&gt;tam);\n    imprimir_frente(minha_lista);\n    imprimir_tras(minha_lista);\n\n    // Buscar e remover elemento\n    no *encontrado = buscar_elemento(minha_lista, 20);\n    if (encontrado != NULL) {\n        printf(\"Elemento 20 encontrado!\\n\");\n        remover_no(minha_lista, encontrado);\n    }\n\n    // Imprimir lista ap\u00f3s remo\u00e7\u00e3o\n    printf(\"Ap\u00f3s remo\u00e7\u00e3o - Tamanho: %d\\n\", minha_lista-&gt;tam);\n    imprimir_frente(minha_lista);\n\n    // Liberar mem\u00f3ria\n    liberar_lista(minha_lista);\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#6-complexidade-das-operacoes","title":"6. Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Complexidade Descri\u00e7\u00e3o Inserir no in\u00edcio O(1) Inser\u00e7\u00e3o constante Inserir no fim O(1) Com ponteiro para \u00faltimo Inserir ap\u00f3s n\u00f3 O(1) Inser\u00e7\u00e3o constante Inserir antes de n\u00f3 O(1) Inser\u00e7\u00e3o constante Remover n\u00f3 O(1) Remo\u00e7\u00e3o constante Buscar elemento O(n) Busca sequencial Acessar por posi\u00e7\u00e3o O(n) Percorre at\u00e9 a posi\u00e7\u00e3o Navega\u00e7\u00e3o bidirecional O(1) Acesso imediato a anterior/pr\u00f3ximo"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/duplaEncadeada/#7-vantagens-e-desvantagens","title":"7. Vantagens e Desvantagens","text":"<p>As listas duplamente encadeadas s\u00e3o ideais para aplica\u00e7\u00f5es que requerem navega\u00e7\u00e3o bidirecional e opera\u00e7\u00f5es frequentes de inser\u00e7\u00e3o/remo\u00e7\u00e3o em qualquer posi\u00e7\u00e3o da lista.</p> <p>Vantagens:</p> <ul> <li>Navega\u00e7\u00e3o bidirecional eficiente</li> <li>Inser\u00e7\u00f5es/remo\u00e7\u00f5es em qualquer posi\u00e7\u00e3o com O(1)</li> <li>Mais flex\u00edvel que listas simplesmente encadeadas</li> </ul> <p>Desvantagens:</p> <ul> <li>Consumo maior de mem\u00f3ria (dois ponteiros por n\u00f3)</li> <li>Implementa\u00e7\u00e3o mais complexa</li> <li>Maior overhead nas opera\u00e7\u00f5es</li> </ul>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/","title":"Listas Simplesmente Encadeadas","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#11-listas-estaticas-arrays","title":"1.1 Listas Est\u00e1ticas (Arrays)","text":"<ul> <li>Espa\u00e7o consecutivo na mem\u00f3ria RAM;</li> <li>Acesso f\u00e1cil atrav\u00e9s de \u00edndices;</li> <li>Nome corresponde ao endere\u00e7o de mem\u00f3ria do primeiro elemento;</li> <li>Vantagem: F\u00e1cil acesso (O(1) para acesso por \u00edndice);  </li> <li>Desvantagem: Dif\u00edcil manipula\u00e7\u00e3o (inser\u00e7\u00e3o/remo\u00e7\u00e3o requer deslocamento de elementos - O(n));</li> </ul>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#12-listas-simplesmente-encadeadas","title":"1.2 Listas Simplesmente Encadeadas","text":"<p>\u00c9 uma sequ\u00eancia de c\u00e9lulas onde cada c\u00e9lula cont\u00e9m:</p> <ul> <li>O conte\u00fado armazenado</li> <li>O endere\u00e7o da c\u00e9lula seguinte</li> </ul> <p>A sequ\u00eancia termina quando uma c\u00e9lula aponta para NULL.  O endere\u00e7o de uma lista encadeada \u00e9 o endere\u00e7o de sua primeira c\u00e9lula.</p>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#21-definicao-do-no","title":"2.1 Defini\u00e7\u00e3o do N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>// Op\u00e7\u00e3o 1: Struct b\u00e1sica\nstruct node {\n    int conteudo;              // conte\u00fado dessa c\u00e9lula\n    struct node *proximo;      // endere\u00e7o da pr\u00f3xima c\u00e9lula\n};\n\n// Op\u00e7\u00e3o 2: Com typedef\ntypedef struct node no;\nstruct node {\n    int conteudo;\n    no *proximo;\n};\n\n// Op\u00e7\u00e3o 3: Mais comum\ntypedef struct node {\n    int conteudo;\n    struct node *proximo;\n} no;\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#22-cabeca-da-lista","title":"2.2 Cabe\u00e7a da Lista","text":"<p>Estrutura que armazena metadados sobre a lista para melhor gerenciamento:</p> Implementa\u00e7\u00e3o:<pre><code>typedef struct head {\n    int num_itens;    // n\u00famero de elementos na lista\n    no *primeiro;     // ponteiro para o primeiro n\u00f3\n    no *ultimo;       // ponteiro para o \u00faltimo n\u00f3\n} cabeca;\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#3-operacoes-basicas","title":"3. Opera\u00e7\u00f5es B\u00e1sicas","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#31-inserir-no-inicio","title":"3.1 Inserir no In\u00edcio","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_inicio(cabeca *lista, no *novo_no) {\n    novo_no-&gt;proximo = lista-&gt;primeiro;\n    lista-&gt;primeiro = novo_no;\n\n    lista-&gt;num_itens++;\n    if (novo_no-&gt;proximo == NULL) {\n        lista-&gt;ultimo = novo_no;\n    }\n}\n\n// Exemplo de uso:\nint main() {\n    no *item = (no *)malloc(sizeof(no)); \n    item-&gt;proximo = NULL;\n    item-&gt;conteudo = 1;\n\n    cabeca *lista = (cabeca *)malloc(sizeof(cabeca)); \n    lista-&gt;primeiro = NULL;\n    lista-&gt;ultimo = NULL;\n    lista-&gt;num_itens = 0;\n\n    inserir_inicio(lista, item); \n\n    printf(\"N\u00famero de itens: %d\\n\", lista-&gt;num_itens);\n    printf(\"Primeiro elemento: %d\\n\", lista-&gt;primeiro-&gt;conteudo);\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#32-inserir-apos-um-no","title":"3.2 Inserir ap\u00f3s um N\u00f3","text":"Implementa\u00e7\u00e3o:<pre><code>void inserir_apos(cabeca *lista, no *referencia, no *novo_no) {\n    novo_no-&gt;proximo = referencia-&gt;proximo;\n    referencia-&gt;proximo = novo_no;\n\n    lista-&gt;num_itens++;\n    if (novo_no-&gt;proximo == NULL) {\n        lista-&gt;ultimo = novo_no;\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#33-inserir-no-fim","title":"3.3 Inserir no Fim","text":"<p> Implementa\u00e7\u00e3o:<pre><code>void inserir_fim(cabeca *lista, no *novo_no) {\n    if (lista-&gt;primeiro == NULL) {\n        lista-&gt;primeiro = novo_no;\n    } else {\n        lista-&gt;ultimo-&gt;proximo = novo_no;\n    }\n\n    lista-&gt;ultimo = novo_no;\n    novo_no-&gt;proximo = NULL;\n    lista-&gt;num_itens++;\n}\n</code></pre></p>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#34-remover-do-inicio","title":"3.4 Remover do In\u00edcio","text":"<p> Implementa\u00e7\u00e3o:<pre><code>void remover_inicio(cabeca *lista) {\n    if (lista-&gt;primeiro == NULL) return;\n\n    no *lixo = lista-&gt;primeiro;\n    lista-&gt;primeiro = lixo-&gt;proximo;\n\n    // Atualiza metadados\n    lista-&gt;num_itens--;\n    if (lista-&gt;primeiro == NULL) {\n        lista-&gt;ultimo = NULL;\n    }\n\n    free(lixo);\n}\n</code></pre></p>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#35-remover-no-especifico","title":"3.5 Remover N\u00f3 Espec\u00edfico","text":"Implementa\u00e7\u00e3o:<pre><code>void remover_no(cabeca *lista, no *alvo) {\n    if (lista-&gt;primeiro == NULL) return;\n\n    // Caso especial: remover o primeiro n\u00f3\n    if (lista-&gt;primeiro == alvo) {\n        remover_inicio(lista);\n        return;\n    }\n\n    // Encontrar o n\u00f3 anterior ao alvo\n    no *anterior = lista-&gt;primeiro;\n    while (anterior != NULL &amp;&amp; anterior-&gt;proximo != alvo) {\n        anterior = anterior-&gt;proximo;\n    }\n\n    if (anterior != NULL) {\n        anterior-&gt;proximo = alvo-&gt;proximo;\n        lista-&gt;num_itens--;\n\n        if (alvo-&gt;proximo == NULL) {\n            lista-&gt;ultimo = anterior;\n        }\n\n        free(alvo);\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#4-operacoes-de-consulta","title":"4. Opera\u00e7\u00f5es de Consulta","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#41-imprimir-todos-os-elementos","title":"4.1 Imprimir Todos os Elementos","text":"Implementa\u00e7\u00e3o:<pre><code>void imprimir_lista(no *inicio) {\n    no *atual;\n    for (atual = inicio; atual != NULL; atual = atual-&gt;proximo) {\n        printf(\"%d -&gt; \", atual-&gt;conteudo);\n    }\n    printf(\"NULL\\n\");\n}\n\n// Exemplo de uso:\nint main() {\n    cabeca *lista = criar_lista();\n\n    // Adicionar elementos...\n    imprimir_lista(lista-&gt;primeiro);\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#42-buscar-um-elemento","title":"4.2 Buscar um Elemento","text":"Implementa\u00e7\u00e3o:<pre><code>no *buscar_elemento(int valor, no *inicio) {\n    no *atual = inicio;\n\n    while (atual != NULL &amp;&amp; atual-&gt;conteudo != valor) {\n        atual = atual-&gt;proximo;\n    }\n\n    return atual; // Retorna NULL se n\u00e3o encontrou\n}\n\n// Exemplo de uso:\nint main() {\n    cabeca *lista = criar_lista();\n\n    // Adicionar elementos...\n    no *resultado = buscar_elemento(42, lista-&gt;primeiro);\n\n    if (resultado != NULL) {\n        printf(\"Elemento encontrado: %d\\n\", resultado-&gt;conteudo);\n    } else {\n        printf(\"Elemento n\u00e3o encontrado\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#5-funcoes-auxiliares","title":"5. Fun\u00e7\u00f5es Auxiliares","text":""},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#51-criar-lista-vazia","title":"5.1 Criar Lista Vazia","text":"Implementa\u00e7\u00e3o:<pre><code>cabeca *criar_lista() {\n    cabeca *nova_lista = (cabeca *)malloc(sizeof(cabeca));\n    nova_lista-&gt;primeiro = NULL;\n    nova_lista-&gt;ultimo = NULL;\n    nova_lista-&gt;num_itens = 0;\n    return nova_lista;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#52-verificar-se-lista-esta-vazia","title":"5.2 Verificar se Lista est\u00e1 Vazia","text":"Implementa\u00e7\u00e3o:<pre><code>int lista_vazia(cabeca *lista) {\n    return lista-&gt;primeiro == NULL;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#53-liberar-memoria-da-lista","title":"5.3 Liberar Mem\u00f3ria da Lista","text":"Implementa\u00e7\u00e3o:<pre><code>void liberar_lista(cabeca *lista) {\n    no *atual = lista-&gt;primeiro;\n    no *proximo;\n\n    while (atual != NULL) {\n        proximo = atual-&gt;proximo;\n        free(atual);\n        atual = proximo;\n    }\n\n    free(lista);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#6-complexidade-das-operacoes","title":"6. Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Complexidade Descri\u00e7\u00e3o Inserir no in\u00edcio O(1) Inser\u00e7\u00e3o constante Inserir no fim O(1) Com ponteiro para \u00faltimo Inserir ap\u00f3s n\u00f3 O(1) Inser\u00e7\u00e3o constante Remover do in\u00edcio O(1) Remo\u00e7\u00e3o constante Remover n\u00f3 espec\u00edfico O(n) Precisa encontrar n\u00f3 anterior Buscar elemento O(n) Busca sequencial Acessar por \u00edndice O(n) Percorre at\u00e9 a posi\u00e7\u00e3o Imprimir lista O(n) Percorre todos os elementos"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#7-vantagens-e-desvantagens","title":"7. Vantagens e Desvantagens","text":"<p>As listas simplesmente encadeadas s\u00e3o ideais para situa\u00e7\u00f5es onde inser\u00e7\u00f5es/remo\u00e7\u00f5es frequentes s\u00e3o necess\u00e1rias, especialmente no in\u00edcio da lista, e quando o tamanho total \u00e9 desconhecido ou vari\u00e1vel.</p>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#71-vantagens","title":"7.1 Vantagens","text":"<ul> <li>Inser\u00e7\u00e3o/remo\u00e7\u00e3o eficiente no in\u00edcio (O(1));</li> <li>Tamanho din\u00e2mico (cresce conforme necessidade);</li> <li>N\u00e3o desperdi\u00e7a mem\u00f3ria com capacidade ociosa;</li> </ul>"},{"location":"disciplinas/EDA1/Listas%20Encadeadas/simplesEncadeada/#71-desvantagens","title":"7.1 Desvantagens","text":"<ul> <li>Acesso sequencial (n\u00e3o h\u00e1 acesso aleat\u00f3rio);</li> <li>Consumo extra de mem\u00f3ria para ponteiros;</li> <li>Maior complexidade de implementa\u00e7\u00e3o;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/","title":"\u00c1rvores Bin\u00e1rias de Busca (ABB)","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma \u00c1rvore Bin\u00e1ria de Busca (ABB) \u00e9 uma estrutura de dados que combina a flexibilidade da inser\u00e7\u00e3o em listas encadeadas com a efici\u00eancia da busca em vetores ordenados. Ela permite a busca bin\u00e1ria a partir da raiz, mantendo os elementos organizados de forma hier\u00e1rquica.</p> <p>Princ\u00edpio fundamental: Para qualquer n\u00f3: - Todas as chaves na sub\u00e1rvore esquerda s\u00e3o menores que a chave do n\u00f3; - Todas as chaves na sub\u00e1rvore direita s\u00e3o maiores que a chave do n\u00f3;</p>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#2-estrutura-e-propriedades","title":"2. Estrutura e Propriedades","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#21-caracteristicas-principais","title":"2.1 Caracter\u00edsticas Principais","text":"<ul> <li>Combina flexibilidade de inser\u00e7\u00e3o com efici\u00eancia de busca;</li> <li>Permite busca bin\u00e1ria a partir da raiz;</li> <li>Todo n\u00f3 n\u00e3o-terminal tem no m\u00e1ximo 2 filhos;</li> <li>N\u00f3s folha apontam para NULL (n\u00f3s externos);</li> <li>Chave de cada n\u00f3 \u00e9 maior que todas as chaves da sua sub\u00e1rvore esquerda;</li> <li>Chave de cada n\u00f3 \u00e9 menor que todas as chaves da sua sub\u00e1rvore direita;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#22-visualizacao","title":"2.2 Visualiza\u00e7\u00e3o","text":"<p>Ordem de inser\u00e7\u00e3o: 4, 1, 9, 2, 11, 6, 3, 7, 12, 8, 5, 10</p>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#3-implementacao-da-abb","title":"3. Implementa\u00e7\u00e3o da ABB","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#31-definicoes-e-macros","title":"3.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para ABB:<pre><code>#define info(A) (A.info)\n#define key(A) (A.chave)\n#define less(A, B) ((A) &lt; (B))\n#define eq(A, B) ((A) == (B))\n#define exch(A, B) { Item t = A; A = B; B = t; }\n#define compexch(A, B) if(less(B, A)) exch(A, B)\n\ntypedef int Key;\n\ntypedef struct data Item;\nstruct data {\n    Key chave;\n    char info[100];\n};\n\ntypedef struct node STnode;\nstruct node {\n    Item item;\n    STnode *esq, *dir;\n    STnode *pai;  // Opcional: ponteiro para o pai\n};\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#32-criacao-de-no","title":"3.2 Cria\u00e7\u00e3o de N\u00f3","text":"Fun\u00e7\u00e3o para criar novo n\u00f3:<pre><code>STnode *new(Item x, STnode *e, STnode *d) {\n    STnode *no = malloc(sizeof(STnode));\n    no-&gt;esq = e;\n    no-&gt;dir = d;\n    no-&gt;item = x;\n    no-&gt;pai = NULL;  // Inicialmente sem pai\n    return no;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#4-operacoes-basicas","title":"4. Opera\u00e7\u00f5es B\u00e1sicas","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#41-busca-em-abb","title":"4.1 Busca em ABB","text":"Busca recursiva em ABB:<pre><code>STnode *STsearch(STnode *no, Key v) {\n    // Condi\u00e7\u00e3o de parada: n\u00f3 nulo ou chave encontrada\n    if (no == NULL || eq(v, key(no-&gt;item)))\n        return no;\n\n    // Buscar na sub\u00e1rvore esquerda se v for menor\n    if (less(v, key(no-&gt;item)))\n        return STsearch(no-&gt;esq, v);\n    else\n        return STsearch(no-&gt;dir, v);\n}\n\n// Vers\u00e3o iterativa da busca\nSTnode *STsearch_iterativo(STnode *no, Key v) {\n    while (no != NULL &amp;&amp; !eq(v, key(no-&gt;item))) {\n        if (less(v, key(no-&gt;item)))\n            no = no-&gt;esq;\n        else\n            no = no-&gt;dir;\n    }\n    return no;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#42-insercao-em-abb","title":"4.2 Inser\u00e7\u00e3o em ABB","text":"Inser\u00e7\u00e3o recursiva em ABB:<pre><code>STnode *STinsert(STnode *no, Item item) {\n    // Condi\u00e7\u00e3o de parada: alcan\u00e7ou n\u00f3 externo\n    if (no == NULL)\n        return new(item, NULL, NULL);\n\n    Key novo = key(item);\n    Key atual = key(no-&gt;item);\n\n    // Decidir onde inserir\n    if (less(novo, atual)) {\n        no-&gt;esq = STinsert(no-&gt;esq, item);\n        if (no-&gt;esq != NULL) no-&gt;esq-&gt;pai = no;\n    } else {\n        no-&gt;dir = STinsert(no-&gt;dir, item);\n        if (no-&gt;dir != NULL) no-&gt;dir-&gt;pai = no;\n    }\n\n    return no;\n}\n\n// Exemplo de uso\nint main(int argc, char *argv[]) {\n    STnode *tree = NULL;\n    int n = 10;  // N\u00famero de elementos\n\n    for (int i = 0; i &lt; n; i++) {\n        Item v;\n        printf(\"Digite chave e info: \");\n        scanf(\"%d %s\", &amp;v.chave, v.info);\n        tree = STinsert(tree, v);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#43-remocao-em-abb","title":"4.3 Remo\u00e7\u00e3o em ABB","text":"Remo\u00e7\u00e3o em ABB:<pre><code>STnode *STdelete(STnode *no, Key remove) {\n    if (no == NULL) return NULL;  // Chave n\u00e3o encontrada\n\n    Key atual = key(no-&gt;item);\n\n    // Procurar o n\u00f3 a ser removido\n    if (less(remove, atual)) {\n        no-&gt;esq = STdelete(no-&gt;esq, remove);\n    } else if (less(atual, remove)) {\n        no-&gt;dir = STdelete(no-&gt;dir, remove);\n    } else {\n        // N\u00f3 encontrado - eq(atual, remove)\n\n        // Caso 1: N\u00f3 com apenas um filho ou nenhum\n        if (no-&gt;esq == NULL) {\n            STnode *temp = no-&gt;dir;\n            free(no);\n            return temp;\n        } else if (no-&gt;dir == NULL) {\n            STnode *temp = no-&gt;esq;\n            free(no);\n            return temp;\n        }\n\n        // Caso 2: N\u00f3 com dois filhos\n        // Encontrar sucessor (menor valor na sub\u00e1rvore direita)\n        STnode *temp = minimo(no-&gt;dir);\n\n        // Copiar dados do sucessor para este n\u00f3\n        no-&gt;item = temp-&gt;item;\n\n        // Remover o sucessor\n        no-&gt;dir = STdelete(no-&gt;dir, key(temp-&gt;item));\n    }\n\n    return no;\n}\n\n// Fun\u00e7\u00e3o auxiliar para encontrar o n\u00f3 m\u00ednimo\nSTnode *minimo(STnode *no) {\n    STnode *atual = no;\n    while (atual != NULL &amp;&amp; atual-&gt;esq != NULL)\n        atual = atual-&gt;esq;\n    return atual;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#44-operacoes-auxiliares","title":"4.4 Opera\u00e7\u00f5es Auxiliares","text":"Opera\u00e7\u00f5es auxiliares para ABB:<pre><code>// Encontrar n\u00f3 m\u00ednimo (menor chave)\nSTnode *minimo(STnode *no) {\n    if (no == NULL) return NULL;\n    while (no-&gt;esq != NULL)\n        no = no-&gt;esq;\n    return no;\n}\n\n// Encontrar n\u00f3 m\u00e1ximo (maior chave)\nSTnode *maximo(STnode *no) {\n    if (no == NULL) return NULL;\n    while (no-&gt;dir != NULL)\n        no = no-&gt;dir;\n    return no;\n}\n\n// Encontrar sucessor (pr\u00f3ximo n\u00f3 em ordem)\nSTnode *sucessor(STnode *no) {\n    if (no == NULL) return NULL;\n\n    // Se h\u00e1 sub\u00e1rvore direita, sucessor \u00e9 o m\u00ednimo dela\n    if (no-&gt;dir != NULL)\n        return minimo(no-&gt;dir);\n\n    // Caso contr\u00e1rio, subir at\u00e9 encontrar um ancestral\n    // que seja filho esquerdo\n    STnode *pai = no-&gt;pai;\n    while (pai != NULL &amp;&amp; no == pai-&gt;dir) {\n        no = pai;\n        pai = pai-&gt;pai;\n    }\n    return pai;\n}\n\n// Encontrar predecessor (n\u00f3 anterior em ordem)\nSTnode *predecessor(STnode *no) {\n    if (no == NULL) return NULL;\n\n    // Se h\u00e1 sub\u00e1rvore esquerda, predecessor \u00e9 o m\u00e1ximo dela\n    if (no-&gt;esq != NULL)\n        return maximo(no-&gt;esq);\n\n    // Caso contr\u00e1rio, subir at\u00e9 encontrar um ancestral\n    // que seja filho direito\n    STnode *pai = no-&gt;pai;\n    while (pai != NULL &amp;&amp; no == pai-&gt;esq) {\n        no = pai;\n        pai = pai-&gt;pai;\n    }\n    return pai;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#5-analise-de-complexidade","title":"5. An\u00e1lise de Complexidade","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#51-complexidade-das-operacoes","title":"5.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Melhor Caso Caso M\u00e9dio Pior Caso Busca O(log n) O(log n) O(n) Inser\u00e7\u00e3o O(log n) O(log n) O(n) Remo\u00e7\u00e3o O(log n) O(log n) O(n) M\u00ednimo/M\u00e1ximo O(log n) O(log n) O(n) Sucessor/Predecessor O(1) O(1) O(n)"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#52-fatores-que-influenciam-a-performance","title":"5.2 Fatores que Influenciam a Performance","text":"<ul> <li>\u00c1rvore balanceada: Altura \u2248 log\u2082n, opera\u00e7\u00f5es O(log n);</li> <li>\u00c1rvore degenerada: Altura = n, opera\u00e7\u00f5es O(n);</li> <li>Ordem de inser\u00e7\u00e3o: Inser\u00e7\u00f5es ordenadas criam \u00e1rvores degeneradas;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#6-vantagens-e-desvantagens","title":"6. Vantagens e Desvantagens","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#61-vantagens","title":"6.1 Vantagens","text":"<ul> <li>Busca eficiente: O(log n) em \u00e1rvores balanceadas;</li> <li>Inser\u00e7\u00e3o/Remo\u00e7\u00e3o: Mais eficiente que arrays ordenados;</li> <li>Flexibilidade: Tamanho din\u00e2mico;</li> <li>Ordena\u00e7\u00e3o: Percursos inordem retornam elementos ordenados;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#62-desvantagens","title":"6.2 Desvantagens","text":"<ul> <li>Desbalanceamento: Pode degenerar para lista encadeada;</li> <li>Complexidade: Implementa\u00e7\u00e3o mais complexa que arrays;</li> <li>Overhead: Armazenamento de ponteiros;</li> <li>Balanceamento: Necessidade de algoritmos AVL ou Red-Black;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvoreDebusca/#7-aplicacoes","title":"7. Aplica\u00e7\u00f5es","text":"<ul> <li>Bancos de dados: \u00cdndices para busca r\u00e1pida;</li> <li>Compiladores: Tabelas de s\u00edmbolos;</li> <li>Sistemas operacionais: Escalonamento de processos;</li> <li>Redes: Roteamento de pacotes;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/","title":"\u00c1rvores","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma \u00c1rvore \u00e9 uma estrutura de dados n\u00e3o-linear hier\u00e1rquica composta por n\u00f3s conectados por arestas. Cada \u00e1rvore possui um n\u00f3 raiz (topo) e sub\u00e1rvores formadas pelos filhos do n\u00f3 raiz.</p> <p>Princ\u00edpio fundamental: \"Um para muitos\" - cada n\u00f3 pode ter zero ou mais filhos, mas apenas um pai (exceto a raiz, que n\u00e3o tem pai).</p>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#2-terminologia-e-genealogia","title":"2. Terminologia e Genealogia","text":"<ul> <li>Raiz: N\u00f3 superior sem pai (A);</li> <li>Pai e filho: B \u00e9 pai de E e F;</li> <li>Irm\u00e3os: B, C e D s\u00e3o irm\u00e3os (mesmo pai);</li> <li>Ancestrais: G, D, A s\u00e3o os ancestrais de L;</li> <li>Descendentes: E, F s\u00e3o descendentes de B;</li> <li>N\u00edvel: A tem n\u00edvel 0; B, C, D t\u00eam n\u00edvel 1; E, F, G, H t\u00eam n\u00edvel 2;</li> <li>Altura: A \u00e1rvore do exemplo tem altura 4 (n\u00famero de n\u00edveis);</li> <li>Folha/N\u00f3 terminal/N\u00f3 externo: I, J, K, L, H, C s\u00e3o folhas (sem filhos);</li> <li>N\u00f3 interno: N\u00f3s com pelo menos um filho (A, B, D, E, F, G);</li> <li>Grau de um n\u00f3: N\u00famero de filhos (B tem grau 2);</li> <li>Grau de uma \u00e1rvore: M\u00e1ximo grau entre todos os n\u00f3s (a \u00e1rvore do exemplo tem grau 3);</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#3-arvore-binaria","title":"3. \u00c1rvore Bin\u00e1ria","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#31-caracteristicas","title":"3.1 Caracter\u00edsticas","text":"<ul> <li>M\u00e1ximo de 2 filhos por n\u00f3 (grau m\u00e1ximo = 2);</li> <li>Formada por uma raiz e sub\u00e1rvores bin\u00e1rias;</li> <li>Ordem dos filhos \u00e9 importante (esquerda vs direita);</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#32-classificacao","title":"3.2 Classifica\u00e7\u00e3o","text":"<ul> <li>\u00c1rvore Estritamente Bin\u00e1ria: N\u00f3s t\u00eam 0 ou 2 filhos;</li> <li>\u00c1rvore Bin\u00e1ria Quase Completa: Todas as folhas est\u00e3o no n\u00edvel d ou d-1;</li> <li>\u00c1rvore Bin\u00e1ria Completa: Todas as folhas est\u00e3o em um mesmo n\u00edvel;</li> <li>\u00c1rvore Bin\u00e1ria Cheia: \u00c9 uma \u00e1rvore estritamente bin\u00e1ria e completa;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#33-propriedades","title":"3.3 Propriedades","text":"<ul> <li>Se h\u00e1 N n\u00f3s internos, ent\u00e3o a \u00e1rvore tem:<ul> <li>N + 1 n\u00f3s externos/folhas;</li> </ul> </li> <li>Se a altura \u00e9 h, ent\u00e3o a \u00e1rvore tem:<ul> <li>No m\u00ednimo h n\u00f3s internos;</li> <li>No m\u00e1ximo 2^h - 1 n\u00f3s internos;</li> </ul> </li> <li>N\u00famero m\u00e1ximo de n\u00f3s no n\u00edvel k: 2^k;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#4-implementacao-de-arvores-binarias","title":"4. Implementa\u00e7\u00e3o de \u00c1rvores Bin\u00e1rias","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#41-estrutura-de-dados","title":"4.1 Estrutura de Dados","text":"Estrutura de n\u00f3 para \u00e1rvore bin\u00e1ria:<pre><code>typedef int Item;\n\ntypedef struct node no;\nstruct node\n{\n    Item item;\n    no *pai;\n    no *esq, *dir;\n};\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#42-operacoes-basicas","title":"4.2 Opera\u00e7\u00f5es B\u00e1sicas","text":"Cria\u00e7\u00e3o e opera\u00e7\u00f5es b\u00e1sicas:<pre><code>// Criar uma \u00e1rvore com raiz x e sub\u00e1rvores esquerda/direita\nno *criar_arvore(Item x, no *p, no *e, no *d)\n{\n    no *raiz = malloc(sizeof(no));\n    raiz-&gt;pai = p;\n    raiz-&gt;esq = e;\n    raiz-&gt;dir = d;\n    raiz-&gt;item = x;\n    return raiz;\n}\n\n// Encontrar av\u00f4 de um n\u00f3\nno *avo(no *elemento) {\n    if ((elemento != NULL) &amp;&amp; (elemento-&gt;pai != NULL))\n        return elemento-&gt;pai-&gt;pai;\n    return NULL;\n}\n\n// Encontrar tio de um n\u00f3\nno *tio(no *elemento) {\n    no *vo = avo(elemento);\n    if (vo == NULL) return NULL;\n\n    if (elemento-&gt;pai == vo-&gt;esq)\n        return vo-&gt;dir;\n    return vo-&gt;esq;\n}\n\n// Encontrar irm\u00e3o de um n\u00f3\nno *irmao(no *elemento) {\n    if ((elemento != NULL) &amp;&amp; (elemento-&gt;pai != NULL)) {\n        if (elemento == elemento-&gt;pai-&gt;esq)\n            return elemento-&gt;pai-&gt;dir;\n        return elemento-&gt;pai-&gt;esq;\n    }\n    return NULL;\n}\n\n// Buscar elemento na \u00e1rvore (busca linear)\nno *busca_linear(no *raiz, Item v) {\n    if (raiz == NULL) return NULL;\n    if (raiz-&gt;item == v) return raiz;\n\n    no *encontrado = busca_linear(raiz-&gt;esq, v);\n    if (encontrado) return encontrado;\n\n    return busca_linear(raiz-&gt;dir, v);\n}\n\n// Contar n\u00famero de n\u00f3s\nint numero_nos(no *raiz) {\n    if (raiz == NULL) return 0;\n    return 1 + numero_nos(raiz-&gt;esq) + numero_nos(raiz-&gt;dir);\n}\n\n// Calcular altura da \u00e1rvore\nint altura(no *raiz) {\n    if (raiz == NULL) return 0;\n    return 1 + fmax(altura(raiz-&gt;esq), altura(raiz-&gt;dir));\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#5-percursos-em-arvores-binarias","title":"5. Percursos em \u00c1rvores Bin\u00e1rias","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#51-percursos-em-profundidade-recursivos","title":"5.1 Percursos em Profundidade (Recursivos)","text":"<ul> <li>Pr\u00e9-ordem: 2, 5, 3, 8, 4, 7, 1, 9, 6.  </li> <li>In-ordem: 3, 5, 4, 8, 2, 1, 9, 7, 6.  </li> <li>P\u00f3s-ordem: 3, 4, 8, 5, 9, 1, 6, 7, 2.</li> </ul> Percursos em profundidade (recursivos):<pre><code>// Pr\u00e9-ordem: Raiz \u2192 Esquerda \u2192 Direita\nvoid preordem(no *raiz) {\n    if (raiz != NULL) {\n        printf(\"%d \", raiz-&gt;item); // Processa raiz\n        preordem(raiz-&gt;esq);       // Sub\u00e1rvore esquerda\n        preordem(raiz-&gt;dir);       // Sub\u00e1rvore direita\n    }\n}\n\n// Inordem: Esquerda \u2192 Raiz \u2192 Direita\nvoid inordem(no *raiz) {\n    if (raiz != NULL) {\n        inordem(raiz-&gt;esq);        // Sub\u00e1rvore esquerda\n        printf(\"%d \", raiz-&gt;item); // Processa raiz\n        inordem(raiz-&gt;dir);        // Sub\u00e1rvore direita\n    }\n}\n\n// P\u00f3s-ordem: Esquerda \u2192 Direita \u2192 Raiz\nvoid posordem(no *raiz) {\n    if (raiz != NULL) {\n        posordem(raiz-&gt;esq);       // Sub\u00e1rvore esquerda\n        posordem(raiz-&gt;dir);       // Sub\u00e1rvore direita\n        printf(\"%d \", raiz-&gt;item); // Processa raiz\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#52-percurso-em-largura","title":"5.2 Percurso em Largura","text":"<ul> <li>Ordem: 2, 5, 7, 3, 8, 1, 6, 4, 9</li> </ul> Percurso em largura usando fila:<pre><code>// Estrutura de fila simplificada para o exemplo\ntypedef struct {\n    no **itens;\n    int frente, tras, capacidade;\n} Fila;\n\nFila* criar_fila(int capacidade) {\n    Fila *f = malloc(sizeof(Fila));\n    f-&gt;itens = malloc(capacidade * sizeof(no*));\n    f-&gt;frente = f-&gt;tras = 0;\n    f-&gt;capacidade = capacidade;\n    return f;\n}\n\nvoid enfileira(Fila *f, no *item) {\n    f-&gt;itens[f-&gt;tras] = item;\n    f-&gt;tras = (f-&gt;tras + 1) % f-&gt;capacidade;\n}\n\nno* desenfileira(Fila *f) {\n    no *item = f-&gt;itens[f-&gt;frente];\n    f-&gt;frente = (f-&gt;frente + 1) % f-&gt;capacidade;\n    return item;\n}\n\nint fila_vazia(Fila *f) {\n    return f-&gt;frente == f-&gt;tras;\n}\n\n// Percurso em largura (BFS)\nvoid percurso_em_largura(no *raiz) {\n    if (raiz == NULL) return;\n\n    Fila *f = criar_fila(100);\n    enfileira(f, raiz);\n\n    while (!fila_vazia(f)) {\n        no *atual = desenfileira(f);\n        printf(\"%d \", atual-&gt;item);\n\n        if (atual-&gt;esq != NULL) enfileira(f, atual-&gt;esq);\n        if (atual-&gt;dir != NULL) enfileira(f, atual-&gt;dir);\n    }\n\n    free(f-&gt;itens);\n    free(f);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#6-analise-da-estrutura","title":"6. An\u00e1lise da Estrutura","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#61-caracteristicas","title":"6.1 Caracter\u00edsticas","text":"Aspecto \u00c1rvore Bin\u00e1ria Organiza\u00e7\u00e3o Hier\u00e1rquica Acesso Eficiente para busca (se balanceada) Pol\u00edtica Hier\u00e1rquica (pai-filho) Flexibilidade Din\u00e2mica, tamanho vari\u00e1vel"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#62-complexidade","title":"6.2 Complexidade","text":"Opera\u00e7\u00e3o \u00c1rvore Balanceada \u00c1rvore Degenerada Busca O(log n) O(n) Inser\u00e7\u00e3o O(log n) O(n) Remo\u00e7\u00e3o O(log n) O(n) Percursos O(n) O(n) Espa\u00e7o O(n) O(n)"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#63-vantagens","title":"6.3 Vantagens","text":"<ul> <li>Busca eficiente: O(log n) em \u00e1rvores balanceadas;</li> <li>Hierarquia natural: Representa rela\u00e7\u00f5es hier\u00e1rquicas;</li> <li>Flexibilidade: Inser\u00e7\u00f5es e remo\u00e7\u00f5es eficientes;</li> <li>Ordena\u00e7\u00e3o: Percursos fornecem diferentes ordens;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#64-desvantagens","title":"6.4 Desvantagens","text":"<ul> <li>Complexidade: Implementa\u00e7\u00e3o mais complexa que estruturas lineares;</li> <li>Balanceamento: Necessidade de algoritmos de balanceamento;</li> <li>Overhead: Ponteiros consomem mem\u00f3ria adicional;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#65-quando-utilizar","title":"6.5 Quando Utilizar","text":"<ul> <li>Busca eficiente: Quando precisa buscar elementos rapidamente;</li> <li>Dados hier\u00e1rquicos: Para representar estruturas organizacionais;</li> <li>\u00c1rvores de decis\u00e3o: Em algoritmos de machine learning;</li> <li>Indexa\u00e7\u00e3o: Em bancos de dados e sistemas de arquivos;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/arvores/#7-aplicacoes-comuns","title":"7. Aplica\u00e7\u00f5es Comuns","text":"<ul> <li>Sistemas de arquivos: Diret\u00f3rios e subdiret\u00f3rios;</li> <li>DOM (Document Object Model): Estrutura de documentos HTML/XML;</li> <li>\u00c1rvores de decis\u00e3o: Em intelig\u00eancia artificial;</li> <li>Compress\u00e3o de dados: \u00c1rvores de Huffman;</li> <li>Bancos de dados: \u00cdndices em B-trees;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/","title":"Filas (Queues)","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#tipos-abstratos-de-dados-tad","title":"Tipos Abstratos de Dados (TAD)","text":"<p>uma maneira de organizar e estruturar dados, fornecendo uma interface clara para interagir com eles enquanto esconde os detalhes da implementa\u00e7\u00e3o. As principais estruturas de dados s\u00e3o:</p> <ol> <li>Filas;</li> <li>Pilhas;</li> <li>\u00c1rvores;</li> </ol>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma Fila \u00e9 uma estrutura de dados linear que segue o princ\u00edpio FIFO (First In, First Out) - o primeiro elemento a entrar \u00e9 o primeiro a sair. \u00c9 an\u00e1loga a uma fila de pessoas esperando em um banco ou supermercado.</p> <p>Princ\u00edpio fundamental: \"Inser\u00e7\u00f5es no fim, remo\u00e7\u00f5es no in\u00edcio\" - novos elementos s\u00e3o adicionados no final da fila e elementos s\u00e3o removidos apenas do in\u00edcio.</p>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#2-implementacoes-de-filas","title":"2. Implementa\u00e7\u00f5es de Filas","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#21-fila-estatica-circular","title":"2.1 Fila Est\u00e1tica Circular","text":"Implementa\u00e7\u00e3o de fila est\u00e1tica circular:<pre><code>#define N 7\nint fila[N];\nint p, u;  // p: \u00edndice do primeiro elemento, u: \u00edndice do pr\u00f3ximo espa\u00e7o vazio\n\nvoid criar_fila() {\n    p = u = 0;\n}\n\nint vazia() {\n    return p == u;\n}\n\nint cheia() {\n    return (u + 1) % N == p;  // Deixa uma posi\u00e7\u00e3o vazia para distinguir cheia de vazia\n}\n\n// Adi\u00e7\u00e3o no fim da fila\nvoid enfileira(int y) {\n    if (cheia()) {\n        printf(\"Fila cheia!\\n\");\n        return;\n    }\n    fila[u] = y;\n    u = (u + 1) % N;  // Avan\u00e7a circularmente\n}\n\n// Remo\u00e7\u00e3o no in\u00edcio da fila \nint desenfileira() {\n    if (vazia()) {\n        printf(\"Fila vazia!\\n\");\n        return -1;\n    }\n    int x = fila[p];\n    p = (p + 1) % N;  // Avan\u00e7a circularmente\n    return x;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#22-fila-dinamica-com-array","title":"2.2 Fila Din\u00e2mica com Array","text":"Implementa\u00e7\u00e3o de fila din\u00e2mica:<pre><code>typedef int Item;\n\ntypedef struct {\n    Item *item;       // Ponteiro para o array de itens\n    int capacidade;   // Capacidade m\u00e1xima da fila\n    int primeiro;     // \u00cdndice do primeiro elemento\n    int ultimo;       // \u00cdndice do pr\u00f3ximo espa\u00e7o vazio\n    int tamanho;      // N\u00famero atual de elementos\n} Fila;\n\nFila *criar(int capacidade) {\n    Fila *f = malloc(sizeof(Fila));\n    f-&gt;item = malloc(capacidade * sizeof(Item));\n    f-&gt;capacidade = capacidade;\n    f-&gt;primeiro = f-&gt;ultimo = f-&gt;tamanho = 0;\n    return f;\n}\n\nint vazia(Fila *f) {\n    return f-&gt;tamanho == 0;\n}\n\nint cheia(Fila *f) {\n    return f-&gt;tamanho == f-&gt;capacidade;\n}\n\nvoid enfileira(Fila *f, Item y) {\n    if (cheia(f)) {\n        printf(\"Fila cheia!\\n\");\n        return;\n    }\n    f-&gt;item[f-&gt;ultimo] = y;\n    f-&gt;ultimo = (f-&gt;ultimo + 1) % f-&gt;capacidade;\n    f-&gt;tamanho++;\n}\n\nItem desenfileira(Fila *f) {\n    if (vazia(f)) {\n        printf(\"Fila vazia!\\n\");\n        return -1;\n    }\n    Item x = f-&gt;item[f-&gt;primeiro];\n    f-&gt;primeiro = (f-&gt;primeiro + 1) % f-&gt;capacidade;\n    f-&gt;tamanho--;\n    return x;\n}\n\nvoid destruir(Fila *f) {\n    free(f-&gt;item);\n    free(f);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#23-fila-com-lista-encadeada","title":"2.3 Fila com Lista Encadeada","text":"Implementa\u00e7\u00e3o com lista encadeada:<pre><code>typedef int Item;\n\ntypedef struct no {\n    Item info;\n    struct no *prox;\n} No;\n\ntypedef struct {\n    No *inicio;    // Ponteiro para o primeiro elemento\n    No *fim;       // Ponteiro para o \u00faltimo elemento\n    int tamanho;   // N\u00famero de elementos na fila\n} Fila;\n\nFila *criar() {\n    Fila *f = malloc(sizeof(Fila));\n    f-&gt;inicio = f-&gt;fim = NULL;\n    f-&gt;tamanho = 0;\n    return f;\n}\n\nint vazia(Fila *f) {\n    return f-&gt;inicio == NULL;\n}\n\nvoid enfileira(Fila *f, Item x) {\n    No *novo = malloc(sizeof(No));\n    novo-&gt;info = x;\n    novo-&gt;prox = NULL;\n\n    if (vazia(f)) {\n        f-&gt;inicio = f-&gt;fim = novo;\n    } else {\n        f-&gt;fim-&gt;prox = novo;\n        f-&gt;fim = novo;\n    }\n    f-&gt;tamanho++;\n}\n\nItem desenfileira(Fila *f) {\n    if (vazia(f)) {\n        printf(\"Fila vazia!\\n\");\n        return -1;\n    }\n\n    No *remover = f-&gt;inicio;\n    Item x = remover-&gt;info;\n\n    f-&gt;inicio = remover-&gt;prox;\n    if (f-&gt;inicio == NULL) {  // Fila ficou vazia\n        f-&gt;fim = NULL;\n    }\n\n    free(remover);\n    f-&gt;tamanho--;\n    return x;\n}\n\nvoid destruir(Fila *f) {\n    while (!vazia(f)) {\n        desenfileira(f);\n    }\n    free(f);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#31-exemplo-com-fila-estatica-circular","title":"3.1 Exemplo com Fila Est\u00e1tica Circular","text":"Opera\u00e7\u00f5es em uma fila circular de tamanho 5:<pre><code>criar_fila() \u2192 p=0, u=0, fila: [ ] [ ] [ ] [ ] [ ]\n\nenfileira(10) \u2192 p=0, u=1, fila: [10] [ ] [ ] [ ] [ ]\nenfileira(20) \u2192 p=0, u=2, fila: [10] [20] [ ] [ ] [ ]\nenfileira(30) \u2192 p=0, u=3, fila: [10] [20] [30] [ ] [ ]\nenfileira(40) \u2192 p=0, u=4, fila: [10] [20] [30] [40] [ ]\n\ndesenfileira() \u2192 retorna 10, p=1, u=4, fila: [10] [20] [30] [40] [ ]\ndesenfileira() \u2192 retorna 20, p=2, u=4, fila: [10] [20] [30] [40] [ ]\n\nenfileira(50) \u2192 p=2, u=0, fila: [50] [20] [30] [40] [ ]\nenfileira(60) \u2192 p=2, u=1, fila: [50] [60] [30] [40] [ ]\n\ndesenfileira() \u2192 retorna 30, p=3, u=1, fila: [50] [60] [30] [40] [ ]\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#32-visualizacao-da-fila-encadeada","title":"3.2 Visualiza\u00e7\u00e3o da Fila Encadeada","text":"Opera\u00e7\u00f5es em fila encadeada:<pre><code>criar() \u2192 inicio=NULL, fim=NULL, tamanho=0\n\nenfileira(10):\ninicio \u2192 [10|\u2022] \u2192 NULL\nfim --------------\u2191\n\nenfileira(20):\ninicio \u2192 [10|\u2022] \u2192 [20|\u2022] \u2192 NULL\nfim ----------------------\u2191\n\nenfileira(30):\ninicio \u2192 [10|\u2022] \u2192 [20|\u2022] \u2192 [30|\u2022] \u2192 NULL\nfim ------------------------------\u2191\n\ndesenfileira() \u2192 remove 10:\ninicio \u2192 [20|\u2022] \u2192 [30|\u2022] \u2192 NULL\nfim ----------------------\u2191\n\ndesenfileira() \u2192 remove 20:\ninicio \u2192 [30|\u2022] \u2192 NULL\nfim ------------\u2191\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#4-analise-da-estrutura","title":"4. An\u00e1lise da Estrutura","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Fila Organiza\u00e7\u00e3o Linear Acesso Restrito (apenas extremidades) Pol\u00edtica FIFO (First In, First Out) Flexibilidade Tamanho fixo ou din\u00e2mico"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#42-complexidade","title":"4.2 Complexidade","text":"Opera\u00e7\u00e3o Array Est\u00e1tico Lista Encadeada Enfileirar O(1) O(1) Desenfileirar O(1) O(1) Acessar frente O(1) O(1) Buscar elemento O(n) O(n) Espa\u00e7o O(n) O(n)"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Efici\u00eancia: Opera\u00e7\u00f5es b\u00e1sicas em tempo constante;</li> <li>Simplicidade: Implementa\u00e7\u00e3o direta e intuitiva;</li> <li>Previsibilidade: Comportamento determin\u00edstico;</li> <li>Versatilidade: M\u00faltiplas implementa\u00e7\u00f5es poss\u00edveis;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Acesso limitado: S\u00f3 \u00e9 poss\u00edvel acessar os extremos;</li> <li>Busca ineficiente: O(n) para encontrar elementos espec\u00edficos;</li> <li>Tamanho fixo: Nas implementa\u00e7\u00f5es com array est\u00e1tico;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#45-quando-utilizar","title":"4.5 Quando Utilizar","text":"<ul> <li>Processamento em ordem: Quando a ordem de processamento deve ser a ordem de chegada;</li> <li>Sistemas de buffer: Para gerenciar tarefas ou requisi\u00e7\u00f5es pendentes;</li> <li>Algoritmos de busca: Como em busca em largura (BFS);</li> <li>Sincroniza\u00e7\u00e3o: Em sistemas concorrentes para comunica\u00e7\u00e3o entre processos;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#5-aplicacoes-praticas","title":"5. Aplica\u00e7\u00f5es Pr\u00e1ticas","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#51-sistema-de-impressao","title":"5.1 Sistema de Impress\u00e3o","text":"Simula\u00e7\u00e3o de fila de impress\u00e3o:<pre><code>Fila *fila_impressao = criar(100);\n\n// Adicionar documentos \u00e0 fila\nvoid adicionar_documento(char *doc) {\n    enfileira(fila_impressao, doc);\n    printf(\"Documento '%s' adicionado \u00e0 fila\\n\", doc);\n}\n\n// Processar impress\u00e3o\nvoid processar_impressao() {\n    while (!vazia(fila_impressao)) {\n        char *doc = desenfileira(fila_impressao);\n        printf(\"Imprimindo: %s\\n\", doc);\n        // Simular tempo de impress\u00e3o\n        sleep(2);\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#52-busca-em-largura-bfs","title":"5.2 Busca em Largura (BFS)","text":"Implementa\u00e7\u00e3o do BFS usando fila:<pre><code>void bfs(Grafo *g, int inicio) {\n    int *visitado = calloc(g-&gt;n, sizeof(int));\n    Fila *f = criar(g-&gt;n);\n\n    visitado[inicio] = 1;\n    enfileira(f, inicio);\n\n    while (!vazia(f)) {\n        int vertice = desenfileira(f);\n        printf(\"Visitando v\u00e9rtice %d\\n\", vertice);\n\n        for (int i = 0; i &lt; g-&gt;n; i++) {\n            if (g-&gt;adj[vertice][i] &amp;&amp; !visitado[i]) {\n                visitado[i] = 1;\n                enfileira(f, i);\n            }\n        }\n    }\n\n    destruir(f);\n    free(visitado);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/filas/#53-outras-aplicacoes-comuns","title":"5.3 Outras Aplica\u00e7\u00f5es Comuns","text":"<ul> <li>Sistema de atendimento: Banco, supermercado, call center;</li> <li>Buffer de rede: Pacotes s\u00e3o processados na ordem de chegada;</li> <li>Escalonamento de processos: Em sistemas operacionais;</li> <li>Simula\u00e7\u00e3o de eventos: Modelagem de sistemas do mundo real;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/","title":"Pilhas (Stacks)","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma Pilha \u00e9 uma estrutura de dados linear que segue o princ\u00edpio LIFO (Last In, First Out) - o \u00faltimo elemento a entrar \u00e9 o primeiro a sair. \u00c9 an\u00e1loga a uma pilha de pratos ou livros.</p> <p>Princ\u00edpio fundamental: \"Inser\u00e7\u00f5es e remo\u00e7\u00f5es ocorrem apenas no topo\" - novos elementos s\u00e3o adicionados no topo da pilha e elementos s\u00e3o removidos apenas do topo.</p>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#2-implementacoes-de-pilhas","title":"2. Implementa\u00e7\u00f5es de Pilhas","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#21-pilha-estatica-com-array","title":"2.1 Pilha Est\u00e1tica com Array","text":"Implementa\u00e7\u00e3o de pilha est\u00e1tica:<pre><code>#define MAX 100\n\ntypedef int Item;\n\ntypedef struct {\n    Item itens[MAX];\n    int topo;\n} Pilha;\n\nvoid criar_pilha(Pilha *p) {\n    p-&gt;topo = 0;\n}\n\nint vazia(Pilha *p) {\n    return p-&gt;topo == 0;\n}\n\nint cheia(Pilha *p) {\n    return p-&gt;topo == MAX;\n}\n\nvoid empilhar(Pilha *p, Item item) {\n    if (cheia(p)) {\n        printf(\"Pilha cheia!\\n\");\n        return;\n    }\n    p-&gt;itens[p-&gt;topo++] = item;\n}\n\nItem desempilhar(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n    return p-&gt;itens[--p-&gt;topo];\n}\n\nItem topo(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n    return p-&gt;itens[p-&gt;topo - 1];\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#22-pilha-dinamica-com-array","title":"2.2 Pilha Din\u00e2mica com Array","text":"Implementa\u00e7\u00e3o de pilha din\u00e2mica:<pre><code>typedef int Item;\n\ntypedef struct {\n    Item *itens;      // Ponteiro para o array de itens\n    int capacidade;   // Capacidade m\u00e1xima da pilha\n    int topo;         // \u00cdndice do pr\u00f3ximo espa\u00e7o vazio\n} Pilha;\n\nPilha *criar(int capacidade) {\n    Pilha *p = malloc(sizeof(Pilha));\n    p-&gt;itens = malloc(capacidade * sizeof(Item));\n    p-&gt;capacidade = capacidade;\n    p-&gt;topo = 0;\n    return p;\n}\n\nint vazia(Pilha *p) {\n    return p-&gt;topo == 0;\n}\n\nint cheia(Pilha *p) {\n    return p-&gt;topo == p-&gt;capacidade;\n}\n\nvoid empilhar(Pilha *p, Item item) {\n    if (cheia(p)) {\n        printf(\"Pilha cheia!\\n\");\n        return;\n    }\n    p-&gt;itens[p-&gt;topo++] = item;\n}\n\nItem desempilhar(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n    return p-&gt;itens[--p-&gt;topo];\n}\n\nItem topo(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n    return p-&gt;itens[p-&gt;topo - 1];\n}\n\nvoid destruir(Pilha *p) {\n    free(p-&gt;itens);\n    free(p);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#23-pilha-com-lista-encadeada","title":"2.3 Pilha com Lista Encadeada","text":"Implementa\u00e7\u00e3o com lista encadeada:<pre><code>typedef int Item;\n\ntypedef struct no {\n    Item info;\n    struct no *prox;\n} No;\n\ntypedef struct {\n    No *topo;      // Ponteiro para o topo da pilha\n    int tamanho;   // N\u00famero de elementos na pilha\n} Pilha;\n\nPilha *criar() {\n    Pilha *p = malloc(sizeof(Pilha));\n    p-&gt;topo = NULL;\n    p-&gt;tamanho = 0;\n    return p;\n}\n\nint vazia(Pilha *p) {\n    return p-&gt;topo == NULL;\n}\n\nvoid empilhar(Pilha *p, Item x) {\n    No *novo = malloc(sizeof(No));\n    novo-&gt;info = x;\n    novo-&gt;prox = p-&gt;topo;  // Novo n\u00f3 aponta para o antigo topo\n    p-&gt;topo = novo;        // Topo agora \u00e9 o novo n\u00f3\n    p-&gt;tamanho++;\n}\n\nItem desempilhar(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n\n    No *remover = p-&gt;topo;\n    Item x = remover-&gt;info;\n\n    p-&gt;topo = remover-&gt;prox;  // Topo agora \u00e9 o pr\u00f3ximo elemento\n    free(remover);\n    p-&gt;tamanho--;\n\n    return x;\n}\n\nItem topo(Pilha *p) {\n    if (vazia(p)) {\n        printf(\"Pilha vazia!\\n\");\n        return -1;\n    }\n    return p-&gt;topo-&gt;info;\n}\n\nvoid destruir(Pilha *p) {\n    while (!vazia(p)) {\n        desempilhar(p);\n    }\n    free(p);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#3-funcionamento-passo-a-passo","title":"3. Funcionamento Passo a Passo","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#31-exemplo-com-pilha-estatica","title":"3.1 Exemplo com Pilha Est\u00e1tica","text":"Opera\u00e7\u00f5es em uma pilha:<pre><code>criar_pilha() \u2192 topo=0, pilha: [ ] [ ] [ ] [ ] [ ]\n\nempilhar(10) \u2192 topo=1, pilha: [10] [ ] [ ] [ ] [ ]\nempilhar(20) \u2192 topo=2, pilha: [10] [20] [ ] [ ] [ ]\nempilhar(30) \u2192 topo=3, pilha: [10] [20] [30] [ ] [ ]\n\ndesempilhar() \u2192 retorna 30, topo=2, pilha: [10] [20] [30] [ ] [ ]\ndesempilhar() \u2192 retorna 20, topo=1, pilha: [10] [20] [30] [ ] [ ]\n\nempilhar(40) \u2192 topo=2, pilha: [10] [40] [30] [ ] [ ]\nempilhar(50) \u2192 topo=3, pilha: [10] [40] [50] [ ] [ ]\n\ntopo() \u2192 retorna 50, topo=3, pilha: [10] [40] [50] [ ] [ ]\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#32-visualizacao-da-pilha-encadeada","title":"3.2 Visualiza\u00e7\u00e3o da Pilha Encadeada","text":"Opera\u00e7\u00f5es em pilha encadeada:<pre><code>criar() \u2192 topo=NULL, tamanho=0\n\nempilhar(10):\ntopo \u2192 [10|\u2022] \u2192 NULL\n\nempilhar(20):\ntopo \u2192 [20|\u2022] \u2192 [10|\u2022] \u2192 NULL\n\nempilhar(30):\ntopo \u2192 [30|\u2022] \u2192 [20|\u2022] \u2192 [10|\u2022] \u2192 NULL\n\ndesempilhar() \u2192 remove 30:\ntopo \u2192 [20|\u2022] \u2192 [10|\u2022] \u2192 NULL\n\ndesempilhar() \u2192 remove 20:\ntopo \u2192 [10|\u2022] \u2192 NULL\n\ntopo() \u2192 retorna 10\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#4-analise-da-estrutura","title":"4. An\u00e1lise da Estrutura","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#41-caracteristicas","title":"4.1 Caracter\u00edsticas","text":"Aspecto Pilha Organiza\u00e7\u00e3o Linear Acesso Restrito (apenas topo) Pol\u00edtica LIFO (Last In, First Out) Flexibilidade Tamanho fixo ou din\u00e2mico"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#42-complexidade","title":"4.2 Complexidade","text":"Opera\u00e7\u00e3o Array Est\u00e1tico Lista Encadeada Empilhar O(1) O(1) Desempilhar O(1) O(1) Consultar topo O(1) O(1) Buscar elemento O(n) O(n) Espa\u00e7o O(n) O(n)"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Efici\u00eancia: Opera\u00e7\u00f5es b\u00e1sicas em tempo constante;</li> <li>Simplicidade: Implementa\u00e7\u00e3o direta e intuitiva;</li> <li>Gerenciamento de mem\u00f3ria: Uso eficiente de recursos;</li> <li>Versatilidade: M\u00faltiplas aplica\u00e7\u00f5es em computa\u00e7\u00e3o;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Acesso limitado: S\u00f3 \u00e9 poss\u00edvel acessar o elemento do topo;</li> <li>Busca ineficiente: O(n) para encontrar elementos espec\u00edficos;</li> <li>Tamanho fixo: Nas implementa\u00e7\u00f5es com array est\u00e1tico;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#45-quando-utilizar","title":"4.5 Quando Utilizar","text":"<ul> <li>Gerenciamento de mem\u00f3ria: Pilha de execu\u00e7\u00e3o em programas;</li> <li>Algoritmos recursivos: Substitui\u00e7\u00e3o de recurs\u00e3o por itera\u00e7\u00e3o;</li> <li>Navega\u00e7\u00e3o em sistemas: Hist\u00f3rico de navega\u00e7\u00e3o em browsers;</li> <li>Processamento de linguagens: An\u00e1lise sint\u00e1tica e balanceamento;</li> <li>Backtracking: Explora\u00e7\u00e3o sistem\u00e1tica de possibilidades;</li> </ul>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#5-aplicacoes-praticas","title":"5. Aplica\u00e7\u00f5es Pr\u00e1ticas","text":""},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#51-balanceamento-de-parenteses","title":"5.1 Balanceamento de Par\u00eanteses","text":"Verificador de express\u00f5es balanceadas:<pre><code>int balanceado(char *expressao) {\n    Pilha *p = criar(strlen(expressao));\n\n    for (int i = 0; expressao[i] != '\\0'; i++) {\n        if (expressao[i] == '(' || expressao[i] == '[' || expressao[i] == '{') {\n            empilhar(p, expressao[i]);\n        } else if (expressao[i] == ')' || expressao[i] == ']' || expressao[i] == '}') {\n            if (vazia(p)) {\n                destruir(p);\n                return 0;\n            }\n\n            char topo_char = desempilhar(p);\n            if ((expressao[i] == ')' &amp;&amp; topo_char != '(') ||\n                (expressao[i] == ']' &amp;&amp; topo_char != '[') ||\n                (expressao[i] == '}' &amp;&amp; topo_char != '{')) {\n                destruir(p);\n                return 0;\n            }\n        }\n    }\n\n    int resultado = vazia(p);\n    destruir(p);\n    return resultado;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#52-conversao-de-infixo-para-posfixo","title":"5.2 Convers\u00e3o de Infixo para P\u00f3sfixo","text":"Convers\u00e3o de nota\u00e7\u00e3o:<pre><code>char *infixo_para_posfixo(char *infixo) {\n    Pilha *p = criar(strlen(infixo));\n    char *posfixo = malloc((strlen(infixo) + 1) * sizeof(char));\n    int j = 0;\n\n    for (int i = 0; infixo[i] != '\\0'; i++) {\n        if (isdigit(infixo[i])) {\n            posfixo[j++] = infixo[i];\n        } else if (infixo[i] == '(') {\n            empilhar(p, infixo[i]);\n        } else if (infixo[i] == ')') {\n            while (!vazia(p) &amp;&amp; topo(p) != '(') {\n                posfixo[j++] = desempilhar(p);\n            }\n            desempilhar(p); // Remove '('\n        } else { // Operador\n            while (!vazia(p) &amp;&amp; precedencia(topo(p)) &gt;= precedencia(infixo[i])) {\n                posfixo[j++] = desempilhar(p);\n            }\n            empilhar(p, infixo[i]);\n        }\n    }\n\n    while (!vazia(p)) {\n        posfixo[j++] = desempilhar(p);\n    }\n    posfixo[j] = '\\0';\n\n    destruir(p);\n    return posfixo;\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#53-busca-em-profundidade-dfs","title":"5.3 Busca em Profundidade (DFS)","text":"Implementa\u00e7\u00e3o do DFS usando pilha:<pre><code>void dfs(Grafo *g, int inicio) {\n    int *visitado = calloc(g-&gt;n, sizeof(int));\n    Pilha *p = criar(g-&gt;n);\n\n    visitado[inicio] = 1;\n    empilhar(p, inicio);\n\n    while (!vazia(p)) {\n        int vertice = desempilhar(p);\n        printf(\"Visitando v\u00e9rtice %d\\n\", vertice);\n\n        for (int i = 0; i &lt; g-&gt;n; i++) {\n            if (g-&gt;adj[vertice][i] &amp;&amp; !visitado[i]) {\n                visitado[i] = 1;\n                empilhar(p, i);\n            }\n        }\n    }\n\n    destruir(p);\n    free(visitado);\n}\n</code></pre>"},{"location":"disciplinas/EDA1/Tipos%20Abstratos%20de%20Dados/pilhas/#54-outras-aplicacoes-comuns","title":"5.4 Outras Aplica\u00e7\u00f5es Comuns","text":"<ul> <li>Sistema de undo/redo: Em editores de texto e imagem;</li> <li>Avalia\u00e7\u00e3o de express\u00f5es p\u00f3sfixas: Calculadoras;</li> <li>Chamadas de fun\u00e7\u00e3o: Pilha de execu\u00e7\u00e3o em programas;</li> <li>Navegador web: Hist\u00f3rico de p\u00e1ginas visitadas;</li> <li>Compiladores: An\u00e1lise sint\u00e1tica e gera\u00e7\u00e3o de c\u00f3digo;</li> </ul>"},{"location":"disciplinas/EDA2/arvore23/","title":"\u00c1rvore 2-3 - Implementa\u00e7\u00e3o e An\u00e1lise","text":""},{"location":"disciplinas/EDA2/arvore23/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma \u00c1rvore 2-3 \u00e9 uma \u00e1rvore de busca balanceada que permite n\u00f3s com 1 ou 2 chaves, garantindo que todas as folhas estejam no mesmo n\u00edvel.</p> <p>Princ\u00edpio fundamental:  - N\u00f3 2: 1 chave, 2 filhos (esquerdo e direito) - N\u00f3 3: 2 chaves, 3 filhos (esquerdo, meio e direito) - N\u00f3s folha est\u00e3o sempre no mesmo n\u00edvel - Balanceamento autom\u00e1tico atrav\u00e9s de opera\u00e7\u00f5es de divis\u00e3o durante inser\u00e7\u00f5es</p>"},{"location":"disciplinas/EDA2/arvore23/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/arvore23/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para \u00c1rvore 2-3:<pre><code>typedef int Key;  // Tipo da chave\n\n// Estrutura do item (chave + dados)\ntypedef struct {\n    Key k;        // Chave\n    // data d;    // Dados associados (pode ser expandido)\n} Item;\n\n#define NULL_ITEM {0}  // Item nulo\n#define NULL_KEY 0     // Chave nula\n\n// Macros para manipula\u00e7\u00e3o de itens\n#define key(A) ((A).k)\n#define less(A, B) (key(A) &lt; key(B))\n#define eq(A, B) (key(A) == key(B))\n</code></pre>"},{"location":"disciplinas/EDA2/arvore23/#22-estrutura-do-no","title":"2.2 Estrutura do N\u00f3","text":"Estrutura do n\u00f3 da \u00c1rvore 2-3:<pre><code>typedef struct TTNode *link;\n\nstruct TTNode {\n    Item item1;    // Primeiro item (sempre presente)\n    Item item2;    // Segundo item (apenas em n\u00f3s 3)\n    link l;        // Ponteiro para filho esquerdo\n    link m;        // Ponteiro para filho do meio (apenas em n\u00f3s 3)\n    link r;        // Ponteiro para filho direito\n    int n;         // N\u00famero de itens no n\u00f3 (1 ou 2)\n};\n\n// Vari\u00e1veis globais\nlink h;  // Raiz da \u00e1rvore\nlink z;  // N\u00f3 sentinela (representa folhas vazias/nulo)\n</code></pre>"},{"location":"disciplinas/EDA2/arvore23/#3-implementacao-das-operacoes","title":"3. Implementa\u00e7\u00e3o das Opera\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/arvore23/#31-inicializacao-e-utilidades","title":"3.1 Inicializa\u00e7\u00e3o e Utilidades","text":"Inicializa\u00e7\u00e3o e fun\u00e7\u00f5es auxiliares:<pre><code>// Criar um novo n\u00f3 2\nlink NEW2(Item item, link l, link r) {\n    link x = malloc(sizeof(struct TTNode));\n    x-&gt;item1 = item;\n    x-&gt;item2 = NULL_ITEM;\n    x-&gt;l = l;\n    x-&gt;m = z;\n    x-&gt;r = r;\n    x-&gt;n = 1;\n    return x;\n}\n\n// Criar um novo n\u00f3 3\nlink NEW3(Item item1, Item item2, link l, link m, link r) {\n    link x = malloc(sizeof(struct TTNode));\n    x-&gt;item1 = item1;\n    x-&gt;item2 = item2;\n    x-&gt;l = l;\n    x-&gt;m = m;\n    x-&gt;r = r;\n    x-&gt;n = 2;\n    return x;\n}\n\n// Inicializar a \u00e1rvore\nvoid TT_init() {\n    z = NEW2(NULL_ITEM, NULL, NULL);  // N\u00f3 sentinela\n    h = z;  // Raiz inicial aponta para sentinela\n}\n\n// Verifica se a \u00e1rvore est\u00e1 vazia\nint TT_empty() {\n    return h == z;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvore23/#32-busca","title":"3.2 Busca","text":"Busca em \u00c1rvore 2-3:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de busca\nItem TT_search(Key k) {\n    return searchR(h, k);\n}\n\n// Fun\u00e7\u00e3o recursiva de busca\nItem searchR(link r, Key k) {\n    if (r == z)  // N\u00e3o encontrado\n        return NULL_ITEM;\n\n    if (r-&gt;n == 1) {  // N\u00f3 2\n        if (eq(k, key(r-&gt;item1)))\n            return r-&gt;item1;\n        else if (less(k, key(r-&gt;item1)))\n            return searchR(r-&gt;l, k);\n        else\n            return searchR(r-&gt;r, k);\n    } else {  // N\u00f3 3\n        if (eq(k, key(r-&gt;item1)) || eq(k, key(r-&gt;item2)))\n            return eq(k, key(r-&gt;item1)) ? r-&gt;item1 : r-&gt;item2;\n        else if (less(k, key(r-&gt;item1)))\n            return searchR(r-&gt;l, k);\n        else if (less(k, key(r-&gt;item2)))\n            return searchR(r-&gt;m, k);\n        else\n            return searchR(r-&gt;r, k);\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvore23/#33-insercao","title":"3.3 Inser\u00e7\u00e3o","text":"<p> - Exemplo: ACEHLMPRSX</p> Inser\u00e7\u00e3o com divis\u00e3o de n\u00f3s:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de inser\u00e7\u00e3o\nvoid TT_insert(Item item) {\n    link temp = z;\n    h = insertR(h, item, &amp;temp);\n    if (temp != z) {  // Raiz foi dividida\n        h = NEW2(temp-&gt;item1, h, temp);\n    }\n}\n\n// Fun\u00e7\u00e3o recursiva de inser\u00e7\u00e3o\nlink insertR(link r, Item item, link *temp) {\n    if (r == z) {  // Folha encontrada\n        *temp = z;\n        return NEW2(item, z, z);\n    }\n\n    Key k = key(item);\n\n    if (r-&gt;n == 1) {  // N\u00f3 2\n        if (less(k, key(r-&gt;item1))) {\n            link new_child = insertR(r-&gt;l, item, temp);\n            if (*temp == z) {\n                r-&gt;l = new_child;\n                return r;\n            } else {  // Precisa transformar em n\u00f3 3\n                return NEW3((*temp)-&gt;item1, r-&gt;item1, \n                           new_child, (*temp)-&gt;r, r-&gt;r);\n            }\n        } else {\n            link new_child = insertR(r-&gt;r, item, temp);\n            if (*temp == z) {\n                r-&gt;r = new_child;\n                return r;\n            } else {  // Precisa transformar em n\u00f3 3\n                return NEW3(r-&gt;item1, (*temp)-&gt;item1, \n                           r-&gt;l, (*temp)-&gt;l, new_child);\n            }\n        }\n    } else {  // N\u00f3 3 - tratamento mais complexo\n        // Implementa\u00e7\u00e3o simplificada - divide o n\u00f3\n        if (less(k, key(r-&gt;item1))) {\n            // Inser\u00e7\u00e3o \u00e0 esquerda\n        } else if (less(k, key(r-&gt;item2))) {\n            // Inser\u00e7\u00e3o no meio\n        } else {\n            // Inser\u00e7\u00e3o \u00e0 direita\n        }\n        // L\u00f3gica de divis\u00e3o do n\u00f3 3\n    }\n    return r;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvore23/#4-analise-de-performance","title":"4. An\u00e1lise de Performance","text":""},{"location":"disciplinas/EDA2/arvore23/#41-complexidade-das-operacoes","title":"4.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Melhor Caso Caso M\u00e9dio Pior Caso Busca O(1) O(log n) O(log n) Inser\u00e7\u00e3o O(1) O(log n) O(log n) Remo\u00e7\u00e3o O(1) O(log n) O(log n) Travessia O(n) O(n) O(n)"},{"location":"disciplinas/EDA2/arvore23/#5-consideracoes-finais","title":"5. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/arvore23/#51-quando-usar-arvore-2-3","title":"5.1 Quando Usar \u00c1rvore 2-3","text":"<ul> <li>Dados din\u00e2micos com busca frequente: Garante O(log n) mesmo com inser\u00e7\u00f5es/remo\u00e7\u00f5es</li> <li>Aplica\u00e7\u00f5es cr\u00edticas: Onde performance consistente \u00e9 essencial</li> <li>Dados parcialmente ordenados: Excelente resist\u00eancia a dados sequenciais</li> </ul>"},{"location":"disciplinas/EDA2/arvore23/#52-alternativas-e-evolucoes","title":"5.2 Alternativas e Evolu\u00e7\u00f5es","text":"<ul> <li>\u00c1rvores Red-Black: Implementa\u00e7\u00e3o mais eficiente com propriedades similares</li> <li>\u00c1rvores B/B+: Generaliza\u00e7\u00e3o para armazenamento em disco</li> <li>\u00c1rvores AVL: Balanceamento mais rigoroso para aplica\u00e7\u00f5es espec\u00edficas</li> </ul>"},{"location":"disciplinas/EDA2/arvore23/#53-aplicacoes-praticas","title":"5.3 Aplica\u00e7\u00f5es Pr\u00e1ticas","text":"<ul> <li>Sistemas de arquivos: Estruturas de diret\u00f3rios</li> <li>Bancos de dados: \u00cdndices balanceados</li> <li>Compiladores: Tabelas de s\u00edmbolos</li> <li>Sistemas operacionais: Gerenciamento de mem\u00f3ria</li> </ul>"},{"location":"disciplinas/EDA2/arvoreBin/","title":"\u00c1rvore Bin\u00e1ria de Busca (BST) - Implementa\u00e7\u00e3o Avan\u00e7ada","text":""},{"location":"disciplinas/EDA2/arvoreBin/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma \u00c1rvore Bin\u00e1ria de Busca (BST) \u00e9 uma estrutura de dados que permite a busca bin\u00e1ria a partir da raiz, mantendo os elementos organizados de forma hier\u00e1rquica com base em suas chaves.</p> <p>Princ\u00edpio fundamental: Para qualquer n\u00f3: - Todos os n\u00f3s na sub\u00e1rvore esquerda t\u00eam chaves menores; - Todos os n\u00f3s na sub\u00e1rvore direita t\u00eam chaves maiores;</p>"},{"location":"disciplinas/EDA2/arvoreBin/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/arvoreBin/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para BST:<pre><code>typedef int Key;  // Tipo da chave\n\n// Estrutura do item (chave + dados)\ntypedef struct {\n    Key k;        // Chave\n    // data d;    // Dados associados (pode ser expandido)\n} Item;\n\n#define NULL_ITEM {0}  // Item nulo\n\n// Macros para manipula\u00e7\u00e3o de itens\n#define key(A) ((A).k)\n#define less(A, B) (key(A) &lt; key(B))\n#define eq(A, B) (key(A) == key(B))\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#22-estrutura-do-no","title":"2.2 Estrutura do N\u00f3","text":"Estrutura do n\u00f3 da BST:<pre><code>typedef struct STNode *link;\n\nstruct STNode {\n    Item item;    // Item armazenado\n    link l;       // Ponteiro para filho esquerdo\n    link r;       // Ponteiro para filho direito\n    int N;        // Tamanho da sub\u00e1rvore (n\u00f3 atual + filhos)\n};\n\n// Vari\u00e1veis globais\nlink h;  // Raiz da \u00e1rvore\nlink z;  // N\u00f3 sentinela (representa folhas vazias/nulo)\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#3-implementacao-das-operacoes","title":"3. Implementa\u00e7\u00e3o das Opera\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/arvoreBin/#31-inicializacao-e-utilidades","title":"3.1 Inicializa\u00e7\u00e3o e Utilidades","text":"Inicializa\u00e7\u00e3o e fun\u00e7\u00f5es auxiliares:<pre><code>// Criar um novo n\u00f3\nlink NEW(Item item, link l, link r, int N) {\n    link x = malloc(sizeof(struct STNode));\n    x-&gt;item = item;\n    x-&gt;l = l;\n    x-&gt;r = r;\n    x-&gt;N = N;\n    return x;\n}\n\n// Inicializar a \u00e1rvore\nvoid ST_init() {\n    z = NEW(NULL_ITEM, NULL, NULL, 0);  // N\u00f3 sentinela\n    h = z;  // Raiz inicial aponta para sentinela\n}\n\n// Retorna o n\u00famero de n\u00f3s da \u00e1rvore\nint ST_count() {\n    return h-&gt;N;\n}\n\n// Verifica se a \u00e1rvore est\u00e1 vazia\nint ST_empty() {\n    return h == z;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#32-insercao","title":"3.2 Inser\u00e7\u00e3o","text":"Inser\u00e7\u00e3o recursiva:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de inser\u00e7\u00e3o\nvoid ST_insert(Item item) {\n    h = insertR(h, item);\n}\n\n// Fun\u00e7\u00e3o recursiva de inser\u00e7\u00e3o\nlink insertR(link r, Item item) {\n    if (r == z)  // Encontrou posi\u00e7\u00e3o de inser\u00e7\u00e3o\n        return NEW(item, z, z, 1);\n\n    Key k = key(item);\n    Key t = key(r-&gt;item);\n\n    if (less(k, t)) {\n        r-&gt;l = insertR(r-&gt;l, item);\n    } else {\n        r-&gt;r = insertR(r-&gt;r, item);\n    }\n\n    r-&gt;N++;  // Atualiza contador de n\u00f3s\n    return r;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#33-busca","title":"3.3 Busca","text":"Busca recursiva:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de busca\nItem ST_search(Key k) {\n    return searchR(h, k);\n}\n\n// Fun\u00e7\u00e3o recursiva de busca\nItem searchR(link r, Key k) {\n    if (r == z)  // N\u00e3o encontrado\n        return NULL_ITEM;\n\n    Key t = key(r-&gt;item);\n\n    if (eq(k, t))\n        return r-&gt;item;\n    else if (less(k, t))\n        return searchR(r-&gt;l, k);\n    else\n        return searchR(r-&gt;r, k);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#34-travessia-e-ordenacao","title":"3.4 Travessia e Ordena\u00e7\u00e3o","text":"Travessia in-order (ordenada):<pre><code>// Fun\u00e7\u00e3o de visita (pode ser personalizada)\nvoid visit(Item i) {\n    printf(\"%d \", key(i));  // Exemplo: imprime a chave\n}\n\n// Travessia in-order recursiva\nvoid sortR(link r, void (*visit)(Item)) {\n    if (r == z) return;\n\n    sortR(r-&gt;l, visit);  // Visita sub\u00e1rvore esquerda\n    visit(r-&gt;item);      // Visita n\u00f3 atual\n    sortR(r-&gt;r, visit);  // Visita sub\u00e1rvore direita\n}\n\n// Fun\u00e7\u00e3o p\u00fablica para ordena\u00e7\u00e3o\nvoid ST_sort(void (*visit)(Item)) {\n    sortR(h, visit);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#35-exemplo-de-uso","title":"3.5 Exemplo de Uso","text":"Exemplo de uso da BST:<pre><code>int main() {\n    ST_init();  // Inicializa \u00e1rvore\n\n    // Insere alguns itens\n    Item items[] = {{5}, {3}, {7}, {2}, {4}, {6}, {8}};\n    for (int i = 0; i &lt; 7; i++) {\n        ST_insert(items[i]);\n    }\n\n    printf(\"N\u00famero de n\u00f3s: %d\\n\", ST_count());\n    printf(\"Elementos em ordem: \");\n    ST_sort(visit);  // Imprime: 2 3 4 5 6 7 8\n\n    // Busca por uma chave\n    Key busca = 4;\n    Item resultado = ST_search(busca);\n    if (key(resultado) != 0) {\n        printf(\"\\nEncontrado: %d\\n\", key(resultado));\n    } else {\n        printf(\"\\nN\u00e3o encontrado: %d\\n\", busca);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/arvoreBin/#4-analise-de-performance","title":"4. An\u00e1lise de Performance","text":""},{"location":"disciplinas/EDA2/arvoreBin/#41-complexidade-das-operacoes","title":"4.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Melhor Caso Caso M\u00e9dio Pior Caso Busca O(1) O(log n) O(n) Inser\u00e7\u00e3o O(1) O(log n) O(n) Remo\u00e7\u00e3o O(1) O(log n) O(n) Travessia O(n) O(n) O(n)"},{"location":"disciplinas/EDA2/arvoreBin/#42-propriedades-estatisticas","title":"4.2 Propriedades Estat\u00edsticas","text":"<ul> <li>Busca bem-sucedida: \u22481.39 log\u2082N compara\u00e7\u00f5es em m\u00e9dia;</li> <li>Busca mal-sucedida: \u22481.39 log\u2082N compara\u00e7\u00f5es em m\u00e9dia;</li> <li>Altura m\u00e9dia: \u22481.39 log\u2082N para \u00e1rvores aleat\u00f3rias;</li> </ul>"},{"location":"disciplinas/EDA2/arvoreBin/#43-problemas-e-limitacoes","title":"4.3 Problemas e Limita\u00e7\u00f5es","text":"<ul> <li>Desbalanceamento: Inser\u00e7\u00f5es ordenadas criam \u00e1rvores degeneradas (lista encadeada);</li> <li>Performance no pior caso: Opera\u00e7\u00f5es tornam-se O(n);</li> <li>Mem\u00f3ria: Overhead de ponteiros e contadores;</li> </ul>"},{"location":"disciplinas/EDA2/arvoreBin/#5-consideracoes-finais","title":"5. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/arvoreBin/#51-quando-usar-bst","title":"5.1 Quando Usar BST","text":"<ul> <li>Dados din\u00e2micos: Inser\u00e7\u00f5es e remo\u00e7\u00f5es frequentes;</li> <li>Busca ordenada: Necessidade de percurso ordenado;</li> <li>Mem\u00f3ria dispon\u00edvel: Overhead aceit\u00e1vel de ponteiros;</li> </ul>"},{"location":"disciplinas/EDA2/arvoreBin/#52-alternativas","title":"5.2 Alternativas","text":"<ul> <li>Hash Tables: Melhor para busca exata (O(1) average);</li> <li>Arrays ordenados: Melhor para dados est\u00e1ticos;</li> <li>\u00c1rvores balanceadas: AVL, Red-Black, B-Trees para grandes datasets;</li> </ul>"},{"location":"disciplinas/EDA2/hash/","title":"Tabela Hash - Implementa\u00e7\u00e3o e An\u00e1lise","text":""},{"location":"disciplinas/EDA2/hash/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma Tabela Hash \u00e9 uma estrutura de dados que mapeia chaves a valores usando uma fun\u00e7\u00e3o hash, permitindo acesso r\u00e1pido aos dados com complexidade m\u00e9dia O(1).</p> <p>Princ\u00edpio fundamental:  - Fun\u00e7\u00e3o hash: Transforma uma chave em um \u00edndice da tabela - Colis\u00f5es: Quando duas chaves diferentes produzem o mesmo \u00edndice - Tratamento de colis\u00f5es: Estrat\u00e9gias para resolver conflitos (encadeamento, endere\u00e7amento aberto)</p>"},{"location":"disciplinas/EDA2/hash/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/hash/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para Tabela Hash:<pre><code>typedef int Key;  // Tipo da chave\n\n// Estrutura do item (chave + dados)\ntypedef struct {\n    Key k;        // Chave\n    // data d;    // Dados associados (pode ser expandido)\n} Item;\n\n#define NULL_ITEM {0}      // Item nulo\n#define NULL_KEY 0         // Chave nula\n\n// Macros para manipula\u00e7\u00e3o de itens\n#define key(A) ((A).k)\n#define less(A, B) (key(A) &lt; key(B))\n#define eq(A, B) (key(A) == key(B))\n\n// Constantes\n#define MAX_COL 10         // M\u00e1ximo de colis\u00f5es permitidas\n#define LOAD_FACTOR 0.75   // Fator de carga para redimensionamento\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#22-estruturas-para-diferentes-implementacoes","title":"2.2 Estruturas para Diferentes Implementa\u00e7\u00f5es","text":"Estrutura para Encadeamento Separado:<pre><code>typedef struct ListNode *link;\n\nstruct ListNode {\n    Item item;\n    link next;\n};\n\ntypedef struct {\n    link *heads;    // Vetor de listas encadeadas\n    int M;          // Tamanho da tabela\n    int N;          // N\u00famero de elementos\n} HashTableChaining;\n\nlink z;  // N\u00f3 sentinela\n</code></pre> Estrutura para Endere\u00e7amento Aberto:<pre><code>typedef struct {\n    Item *table;    // Vetor de itens\n    int M;          // Tamanho da tabela\n    int N;          // N\u00famero de elementos\n} HashTableOpen;\n\n// Estados dos slots\n#define EMPTY 0\n#define OCCUPIED 1\n#define DELETED 2\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#3-implementacao-das-operacoes","title":"3. Implementa\u00e7\u00e3o das Opera\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/hash/#31-funcoes-hash","title":"3.1 Fun\u00e7\u00f5es Hash","text":"Diversas fun\u00e7\u00f5es hash:<pre><code>// Hash modular para inteiros\nint hash_int(Key k, int M) {\n    return k % M;\n}\n\n// Hash para strings (m\u00e9todo de Horner)\nint hash_string(char *v, int M) {\n    int h = 0, a = 127;\n    for (; *v != '\\0'; v++)\n        h = (a * h + *v) % M;\n    return h;\n}\n\n// Hash universal para inteiros\nint hash_universal(Key k, int M) {\n    // Coeficientes aleat\u00f3rios (exemplo)\n    static int a = 12345, b = 67890, p = 999983;\n    return ((a * k + b) % p) % M;\n}\n\n// Fun\u00e7\u00e3o hash principal\nint hash(Key k, int M) {\n    return hash_int(k, M);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#32-encadeamento-separado","title":"3.2 Encadeamento Separado","text":"Implementa\u00e7\u00e3o com listas encadeadas:<pre><code>// Inicializa\u00e7\u00e3o\nvoid HT_init_chaining(HashTableChaining *ht, int size) {\n    ht-&gt;M = size;\n    ht-&gt;N = 0;\n    ht-&gt;heads = malloc(size * sizeof(link));\n    z = malloc(sizeof(struct ListNode));\n    z-&gt;next = z;\n\n    for (int i = 0; i &lt; size; i++) {\n        ht-&gt;heads[i] = malloc(sizeof(struct ListNode));\n        ht-&gt;heads[i]-&gt;next = z;\n        ht-&gt;heads[i]-&gt;item = NULL_ITEM;\n    }\n}\n\n// Inser\u00e7\u00e3o\nvoid HT_insert_chaining(HashTableChaining *ht, Item item) {\n    int h = hash(key(item), ht-&gt;M);\n    link current = ht-&gt;heads[h]-&gt;next;\n    link prev = ht-&gt;heads[h];\n\n    // Verifica se j\u00e1 existe\n    while (current != z) {\n        if (eq(key(current-&gt;item), key(item))) {\n            current-&gt;item = item;  // Atualiza\n            return;\n        }\n        prev = current;\n        current = current-&gt;next;\n    }\n\n    // Insere novo n\u00f3\n    link new_node = malloc(sizeof(struct ListNode));\n    new_node-&gt;item = item;\n    new_node-&gt;next = z;\n    prev-&gt;next = new_node;\n    ht-&gt;N++;\n}\n\n// Busca\nItem HT_search_chaining(HashTableChaining *ht, Key k) {\n    int h = hash(k, ht-&gt;M);\n    link current = ht-&gt;heads[h]-&gt;next;\n\n    while (current != z) {\n        if (eq(key(current-&gt;item), k))\n            return current-&gt;item;\n        current = current-&gt;next;\n    }\n\n    return NULL_ITEM;\n}\n\n// Remo\u00e7\u00e3o\nvoid HT_remove_chaining(HashTableChaining *ht, Key k) {\n    int h = hash(k, ht-&gt;M);\n    link current = ht-&gt;heads[h]-&gt;next;\n    link prev = ht-&gt;heads[h];\n\n    while (current != z) {\n        if (eq(key(current-&gt;item), k)) {\n            prev-&gt;next = current-&gt;next;\n            free(current);\n            ht-&gt;N--;\n            return;\n        }\n        prev = current;\n        current = current-&gt;next;\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#33-enderecamento-aberto-com-sondagem-linear","title":"3.3 Endere\u00e7amento Aberto com Sondagem Linear","text":"Implementa\u00e7\u00e3o com endere\u00e7amento aberto:<pre><code>// Inicializa\u00e7\u00e3o\nvoid HT_init_open(HashTableOpen *ht, int size) {\n    ht-&gt;M = size;\n    ht-&gt;N = 0;\n    ht-&gt;table = malloc(size * sizeof(Item));\n\n    for (int i = 0; i &lt; size; i++) {\n        ht-&gt;table[i] = NULL_ITEM;\n    }\n}\n\n// Inser\u00e7\u00e3o\nint HT_insert_open(HashTableOpen *ht, Item item) {\n    if (ht-&gt;N &gt;= ht-&gt;M * LOAD_FACTOR) {\n        HT_resize(ht, ht-&gt;M * 2);\n    }\n\n    int h = hash(key(item), ht-&gt;M);\n    int c = MAX_COL;\n\n    while (c &gt; 0 &amp;&amp; key(ht-&gt;table[h]) != NULL_KEY) {\n        if (eq(key(ht-&gt;table[h]), key(item))) {\n            ht-&gt;table[h] = item;  // Atualiza\n            return 1;\n        }\n        h = (h + 1) % ht-&gt;M;\n        c--;\n    }\n\n    if (c == 0) return 0;  // Muitas colis\u00f5es\n\n    ht-&gt;table[h] = item;\n    ht-&gt;N++;\n    return 1;\n}\n\n// Busca\nItem HT_search_open(HashTableOpen *ht, Key k) {\n    int h = hash(k, ht-&gt;M);\n    int c = MAX_COL;\n\n    while (c &gt; 0 &amp;&amp; key(ht-&gt;table[h]) != NULL_KEY) {\n        if (eq(key(ht-&gt;table[h]), k))\n            return ht-&gt;table[h];\n        h = (h + 1) % ht-&gt;M;\n        c--;\n    }\n\n    return NULL_ITEM;\n}\n\n// Remo\u00e7\u00e3o\nvoid HT_remove_open(HashTableOpen *ht, Key k) {\n    int h = hash(k, ht-&gt;M);\n    int c = MAX_COL;\n\n    while (c &gt; 0 &amp;&amp; key(ht-&gt;table[h]) != NULL_KEY) {\n        if (eq(key(ht-&gt;table[h]), k)) {\n            ht-&gt;table[h] = NULL_ITEM;\n            ht-&gt;N--;\n            return;\n        }\n        h = (h + 1) % ht-&gt;M;\n        c--;\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#34-double-hashing","title":"3.4 Double Hashing","text":"Implementa\u00e7\u00e3o com double hashing:<pre><code>// Segunda fun\u00e7\u00e3o hash\nint hash2(Key k) {\n    return (k % 97) + 1;  // Nunca retorna 0\n}\n\n// Inser\u00e7\u00e3o com double hashing\nint HT_insert_double(HashTableOpen *ht, Item item) {\n    if (ht-&gt;N &gt;= ht-&gt;M * LOAD_FACTOR) {\n        HT_resize(ht, ht-&gt;M * 2);\n    }\n\n    int h1 = hash(key(item), ht-&gt;M);\n    int h2 = hash2(key(item));\n    int h = h1;\n    int c = MAX_COL;\n\n    while (c &gt; 0 &amp;&amp; key(ht-&gt;table[h]) != NULL_KEY) {\n        if (eq(key(ht-&gt;table[h]), key(item))) {\n            ht-&gt;table[h] = item;\n            return 1;\n        }\n        h = (h + h2) % ht-&gt;M;\n        c--;\n    }\n\n    if (c == 0) return 0;\n\n    ht-&gt;table[h] = item;\n    ht-&gt;N++;\n    return 1;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#35-redimensionamento-da-tabela","title":"3.5 Redimensionamento da Tabela","text":"Redimensionamento:<pre><code>void HT_resize(HashTableOpen *ht, int new_size) {\n    Item *old_table = ht-&gt;table;\n    int old_M = ht-&gt;M;\n\n    // Nova tabela\n    ht-&gt;table = malloc(new_size * sizeof(Item));\n    ht-&gt;M = new_size;\n    ht-&gt;N = 0;\n\n    // Inicializa nova tabela\n    for (int i = 0; i &lt; new_size; i++) {\n        ht-&gt;table[i] = NULL_ITEM;\n    }\n\n    // Reinsere todos os elementos\n    for (int i = 0; i &lt; old_M; i++) {\n        if (key(old_table[i]) != NULL_KEY) {\n            HT_insert_open(ht, old_table[i]);\n        }\n    }\n\n    free(old_table);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/hash/#6-consideracoes-finais","title":"6. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/hash/#61-quando-usar-tabela-hash","title":"6.1 Quando Usar Tabela Hash","text":"<ul> <li>Acesso r\u00e1pido: Quando O(1) \u00e9 cr\u00edtico</li> <li>Chaves \u00fanicas: Dicion\u00e1rios, caches, bancos de dados</li> <li>Dados din\u00e2micos: Muitas inser\u00e7\u00f5es/remo\u00e7\u00f5es</li> </ul>"},{"location":"disciplinas/EDA2/hash/#62-escolha-da-implementacao","title":"6.2 Escolha da Implementa\u00e7\u00e3o","text":"<ul> <li>Encadeamento: Simplicidade, dados imprevis\u00edveis</li> <li>Sondagem Linear: Mem\u00f3ria limitada, dados conhecidos</li> <li>Double Hashing: Performance consistente, evitar clusteriza\u00e7\u00e3o</li> </ul>"},{"location":"disciplinas/EDA2/hash/#63-boas-praticas","title":"6.3 Boas Pr\u00e1ticas","text":"<ul> <li>Tamanho primo: Para distribui\u00e7\u00e3o uniforme</li> <li>Monitorar fator de carga: Redimensionar quando \u03b1 &gt; 0.75</li> <li>Fun\u00e7\u00e3o hash robusta: Minimizar colis\u00f5es</li> <li>Teste de performance: Avaliar com dados reais</li> </ul>"},{"location":"disciplinas/EDA2/hash/#64-aplicacoes-praticas","title":"6.4 Aplica\u00e7\u00f5es Pr\u00e1ticas","text":"<ul> <li>Bancos de dados: \u00cdndices hash</li> <li>Caches: Mem\u00f3ria cache, cache de DNS</li> <li>Compiladores: Tabelas de s\u00edmbolos</li> <li>Sistemas de arquivos: Diret\u00f3rios r\u00e1pidos</li> <li>Roteamento: Tables de roteamento em redes</li> </ul>"},{"location":"disciplinas/EDA2/redblack/","title":"\u00c1rvores Rubro-Negras Esquerdistas (Left-Leaning Red-Black Trees - LLRBT)","text":""},{"location":"disciplinas/EDA2/redblack/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>As \u00c1rvores Rubro-Negras Esquerdistas (ARNE) s\u00e3o uma implementa\u00e7\u00e3o espec\u00edfica de \u00e1rvores rubro-negras que mant\u00eam todos os links vermelhos inclinados para a esquerda, simplificando a implementa\u00e7\u00e3o enquanto mant\u00e9m as propriedades de balanceamento.</p> <p>Princ\u00edpio fundamental: Representa\u00e7\u00e3o de \u00e1rvores 2-3 usando \u00e1rvores bin\u00e1rias com links coloridos: - Links negros: Links normais da \u00e1rvore bin\u00e1ria - Links vermelhos: Links \"horizontais\" que conectam n\u00f3s do mesmo n\u00edvel l\u00f3gico (representando n\u00f3s 3 da \u00e1rvore 2-3)</p> <p> Estrutura de uma BST Red Black</p>"},{"location":"disciplinas/EDA2/redblack/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/redblack/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para ARNE:<pre><code>typedef int Key;  // Tipo da chave\n\n// Estrutura do item (chave + dados)\ntypedef struct {\n    Key k;        // Chave\n    // data d;    // Dados associados (pode ser expandido)\n} Item;\n\n#define NULL_ITEM {0}  // Item nulo\n\n// Macros para manipula\u00e7\u00e3o de itens\n#define key(A) ((A).k)\n#define less(A, B) (key(A) &lt; key(B))\n#define eq(A, B) (key(A) == key(B))\n\n// Cores dos links\n#define RED 0\n#define BLACK 1\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#22-estrutura-do-no","title":"2.2 Estrutura do N\u00f3","text":"Estrutura do n\u00f3 da ARNE:<pre><code>typedef struct STNode *link;\n\nstruct STNode {\n    Item item;    // Item armazenado\n    link l;       // Ponteiro para filho esquerdo\n    link r;       // Ponteiro para filho direito\n    int N;        // Tamanho da sub\u00e1rvore (n\u00f3 atual + filhos)\n    int color;    // Cor do link que aponta para este n\u00f3 (RED ou BLACK)\n};\n\n// Vari\u00e1veis globais\nlink h;  // Raiz da \u00e1rvore\nlink z;  // N\u00f3 sentinela (representa folhas vazias/nulo)\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#3-implementacao-das-operacoes","title":"3. Implementa\u00e7\u00e3o das Opera\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/redblack/#31-inicializacao-e-utilidades","title":"3.1 Inicializa\u00e7\u00e3o e Utilidades","text":"Inicializa\u00e7\u00e3o e fun\u00e7\u00f5es auxiliares:<pre><code>// Criar um novo n\u00f3\nlink NEW(Item item, link l, link r, int N) {\n    link x = malloc(sizeof(struct STNode));\n    x-&gt;item = item;\n    x-&gt;l = l;\n    x-&gt;r = r;\n    x-&gt;N = N;\n    x-&gt;color = RED;  // Novos n\u00f3s come\u00e7am com link rubro\n    return x;\n}\n\n// Inicializar a \u00e1rvore\nvoid ST_init() {\n    z = NEW(NULL_ITEM, NULL, NULL, 0);  // N\u00f3 sentinela\n    z-&gt;color = BLACK;  // Sentinela sempre negra\n    h = z;  // Raiz inicial aponta para sentinela\n}\n\n// Verifica se um link \u00e9 vermelho\nint isRed(link x) {\n    if (x == z) return 0;  // Links para sentinela s\u00e3o considerados negros\n    return x-&gt;color == RED;\n}\n\n// Retorna o n\u00famero de n\u00f3s da \u00e1rvore\nint ST_count() {\n    return h-&gt;N;\n}\n\n// Verifica se a \u00e1rvore est\u00e1 vazia\nint ST_empty() {\n    return h == z;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#32-operacoes-de-rotacao-e-ajuste","title":"3.2 Opera\u00e7\u00f5es de Rota\u00e7\u00e3o e Ajuste","text":"<ul> <li>Rota\u00e7\u00e3o Esquerda (Anti-hor\u00e1ria):|<ul> <li>Usada quando h\u00e1 um link rubro \u00e0 direita;</li> <li>Como funciona:<ul> <li>Rota\u00e7\u00e3o para esquerda da subwarvore</li> <li>Continua vermelho</li> </ul> </li> </ul> </li> <li>Rota\u00e7\u00e3o Direita (Hor\u00e1ria):<ul> <li>Usada quando h\u00e1 dois links rubros consecutivos \u00e0 esquerda;</li> <li>Como funciona:<ul> <li>Rota\u00e7ao da subarvore para direita</li> <li>No superior fica vermelho</li> </ul> </li> </ul> </li> <li>Invers\u00e3o de Cores:<ul> <li>Simula a divis\u00e3o de um n\u00f3 triplo tempor\u00e1rio em uma \u00e1rvore 2-3;</li> <li>Remove a cor rubra dos dois filhos de um n\u00f3 e torna o link que aponta para o n\u00f3 rubro;</li> <li>Efeito: \"Empurra\" a cor rubra para cima na \u00e1rvore;</li> </ul> </li> </ul> Rota\u00e7\u00f5es e invers\u00e3o de cores:<pre><code>// Rota\u00e7\u00e3o esquerda (anti-hor\u00e1ria)\nlink rotateLeft(link r) {\n    link x = r-&gt;r;          // Filho direito sobe\n    r-&gt;r = x-&gt;l;           // Adota sub\u00e1rvore esquerda de x\n    x-&gt;l = r;              // r vira filho esquerdo de x\n    x-&gt;color = r-&gt;color;   // Herda a cor de r\n    r-&gt;color = RED;        // Novo link para r \u00e9 rubro\n    x-&gt;N = r-&gt;N;           // Atualiza contagem de n\u00f3s\n    r-&gt;N = 1 + r-&gt;l-&gt;N + r-&gt;r-&gt;N; // Recalcula N para r\n    return x;\n}\n\n// Rota\u00e7\u00e3o direita (hor\u00e1ria)\nlink rotateRight(link r) {\n    link x = r-&gt;l;          // Filho esquerdo sobe\n    r-&gt;l = x-&gt;r;           // Adota sub\u00e1rvore direita de x\n    x-&gt;r = r;              // r vira filho direito de x\n    x-&gt;color = r-&gt;color;   // Herda a cor de r\n    r-&gt;color = RED;        // Novo link para r \u00e9 rubro\n    x-&gt;N = r-&gt;N;           // Atualiza contagem de n\u00f3s\n    r-&gt;N = 1 + r-&gt;l-&gt;N + r-&gt;r-&gt;N; // Recalcula N para r\n    return x;\n}\n\n// Invers\u00e3o de cores (split de n\u00f3 4)\nvoid flipColors(link r) {\n    r-&gt;l-&gt;color = BLACK;   // Filhos tornam-se negros\n    r-&gt;r-&gt;color = BLACK;\n    r-&gt;color = RED;        // Link para r torna-se rubro\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#33-insercao","title":"3.3 Inser\u00e7\u00e3o","text":""},{"location":"disciplinas/EDA2/redblack/#331-funcionamento","title":"3.3.1 Funcionamento","text":"<ul> <li>Insere um novo n\u00f3 com link rubro, simulando a adi\u00e7\u00e3o em uma \u00e1rvore 2-3;</li> <li>Ajusta a \u00e1rvore com rota\u00e7\u00f5es e invers\u00f5es de cores para manter as propriedades da ARNE;</li> <li>Casos:<ol> <li>N\u00f3 simples: Novo n\u00f3 \u00e9 pendurado com link rubro (pode exigir ajustes);</li> <li>N\u00f3 duplo: Forma um n\u00f3 triplo tempor\u00e1rio, que \u00e9 dividido com invers\u00e3o de cores;</li> </ol> </li> </ul>"},{"location":"disciplinas/EDA2/redblack/#332-passo-a-passo","title":"3.3.2 Passo a Passo","text":"<ul> <li>Insere recursivamente como em uma BST, pendurando o novo n\u00f3 com link rubro;</li> <li>Ap\u00f3s a inser\u00e7\u00e3o, verifica viola\u00e7\u00f5es das propriedades:<ul> <li>Link rubro \u00e0 direita: Rota\u00e7\u00e3o esquerda;</li> <li>Dois links rubros \u00e0 esquerda: Rota\u00e7\u00e3o direita;</li> <li>Dois filhos rubros: Invers\u00e3o de cores;</li> </ul> </li> <li>Atualiza a contagem de n\u00f3s (N);</li> <li>Garante que a raiz seja negra;</li> </ul> Inser\u00e7\u00e3o com balanceamento:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de inser\u00e7\u00e3o\nvoid ST_insert(Item item) {\n    h = insertR(h, item);\n    h-&gt;color = BLACK;  // Raiz sempre negra\n}\n\n// Fun\u00e7\u00e3o recursiva de inser\u00e7\u00e3o\nlink insertR(link r, Item item) {\n    if (r == z)  // Encontrou posi\u00e7\u00e3o de inser\u00e7\u00e3o\n        return NEW(item, z, z, 1);\n\n    Key k = key(item);\n    Key t = key(r-&gt;item);\n\n    // Inser\u00e7\u00e3o recursiva\n    if (less(k, t)) {\n        r-&gt;l = insertR(r-&gt;l, item);\n    } else {\n        r-&gt;r = insertR(r-&gt;r, item);\n    }\n\n    // Balanceamento p\u00f3s-inser\u00e7\u00e3o\n    r = fixUp(r);\n    r-&gt;N = 1 + r-&gt;l-&gt;N + r-&gt;r-&gt;N;  // Atualiza contador\n    return r;\n}\n\n// Corrige viola\u00e7\u00f5es das propriedades ARNE\nlink fixUp(link r) {\n    // Corrige link vermelho \u00e0 direita\n    if (isRed(r-&gt;r) &amp;&amp; !isRed(r-&gt;l))\n        r = rotateLeft(r);\n\n    // Corrige dois links vermelhos consecutivos \u00e0 esquerda\n    if (isRed(r-&gt;l) &amp;&amp; isRed(r-&gt;l-&gt;l))\n        r = rotateRight(r);\n\n    // Corrige dois filhos vermelhos (n\u00f3 4)\n    if (isRed(r-&gt;l) &amp;&amp; isRed(r-&gt;r))\n        flipColors(r);\n\n    return r;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#333-insercao-manual","title":"3.3.3 Inser\u00e7\u00e3o Manual","text":"<p> Exemplo: ASERCH</p>"},{"location":"disciplinas/EDA2/redblack/#34-busca","title":"3.4 Busca","text":"Busca recursiva:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de busca\nItem ST_search(Key k) {\n    return searchR(h, k);\n}\n\n// Fun\u00e7\u00e3o recursiva de busca\nItem searchR(link r, Key k) {\n    if (r == z)  // N\u00e3o encontrado\n        return NULL_ITEM;\n\n    Key t = key(r-&gt;item);\n\n    if (eq(k, t))\n        return r-&gt;item;\n    else if (less(k, t))\n        return searchR(r-&gt;l, k);\n    else\n        return searchR(r-&gt;r, k);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#35-travessia-e-ordenacao","title":"3.5 Travessia e Ordena\u00e7\u00e3o","text":"Travessia in-order:<pre><code>// Fun\u00e7\u00e3o de visita\nvoid visit(Item i) {\n    printf(\"%d \", key(i));\n}\n\n// Travessia in-order recursiva\nvoid sortR(link r, void (*visit)(Item)) {\n    if (r == z) return;\n\n    sortR(r-&gt;l, visit);  // Visita sub\u00e1rvore esquerda\n    visit(r-&gt;item);      // Visita n\u00f3 atual\n    sortR(r-&gt;r, visit);  // Visita sub\u00e1rvore direita\n}\n\n// Fun\u00e7\u00e3o p\u00fablica para ordena\u00e7\u00e3o\nvoid ST_sort(void (*visit)(Item)) {\n    sortR(h, visit);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#36-exemplo-de-uso","title":"3.6 Exemplo de Uso","text":"Exemplo de uso da ARNE:<pre><code>int main() {\n    ST_init();  // Inicializa \u00e1rvore\n\n    // Insere elementos: A S E R C H\n    Item items[] = {{1}, {19}, {5}, {18}, {3}, {8}};\n    char labels[] = {'A','S','E','R','C','H'};\n\n    for (int i = 0; i &lt; 6; i++) {\n        ST_insert(items[i]);\n        printf(\"Inserido: %c (%d)\\n\", labels[i], key(items[i]));\n    }\n\n    printf(\"N\u00famero de n\u00f3s: %d\\n\", ST_count());\n    printf(\"Elementos em ordem: \");\n    ST_sort(visit);  // Imprime em ordem crescente\n\n    // Busca por uma chave\n    Key busca = 5;\n    Item resultado = ST_search(busca);\n    if (key(resultado) != 0) {\n        printf(\"\\nEncontrado: %d\\n\", key(resultado));\n    } else {\n        printf(\"\\nN\u00e3o encontrado: %d\\n\", busca);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/redblack/#4-analise-de-performance","title":"4. An\u00e1lise de Performance","text":""},{"location":"disciplinas/EDA2/redblack/#41-complexidade-das-operacoes","title":"4.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Melhor Caso Caso M\u00e9dio Pior Caso Busca O(1) O(log n) O(log n) Inser\u00e7\u00e3o O(1) O(log n) O(log n) Remo\u00e7\u00e3o O(1) O(log n) O(log n) Travessia O(n) O(n) O(n)"},{"location":"disciplinas/EDA2/redblack/#42-propriedades-de-balanceamento","title":"4.2 Propriedades de Balanceamento","text":"<ul> <li>Altura m\u00e1xima: \u2264 2 log\u2082(n + 1)</li> <li>Balanceamento perfeito: Todos os caminhos da raiz \u00e0s folhas t\u00eam o mesmo n\u00famero de links negros</li> <li>Links vermelhos: Nunca dois links vermelhos consecutivos e sempre inclinados \u00e0 esquerda</li> </ul>"},{"location":"disciplinas/EDA2/redblack/#43-vantagens-sobre-bst-comum","title":"4.3 Vantagens sobre BST Comum","text":"<ul> <li>Balanceamento garantido: Sempre O(log n) para todas as opera\u00e7\u00f5es</li> <li>Performance consistente: N\u00e3o degrada com dados ordenados</li> <li>Efici\u00eancia de mem\u00f3ria: Overhead m\u00ednimo (apenas 1 bit por n\u00f3 para cor)</li> </ul>"},{"location":"disciplinas/EDA2/redblack/#44-comparacao-com-outras-estruturas","title":"4.4 Compara\u00e7\u00e3o com Outras Estruturas","text":"Caracter\u00edstica BST Simples \u00c1rvore 2-3 ARNE Balanceamento N\u00e3o garantido Garantido Garantido Altura m\u00e1xima O(n) O(log n) O(log n) Complexidade Simples Complexa Moderada Overhead Baixo Alto Baixo"},{"location":"disciplinas/EDA2/redblack/#5-consideracoes-finais","title":"5. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/redblack/#51-quando-usar-arne","title":"5.1 Quando Usar ARNE","text":"<ul> <li>Aplica\u00e7\u00f5es de alto desempenho: Onde O(log n) garantido \u00e9 essencial</li> <li>Dados din\u00e2micos: Muitas inser\u00e7\u00f5es/remo\u00e7\u00f5es com busca frequente</li> <li>Mem\u00f3ria limitada: Overhead menor que \u00e1rvores 2-3</li> <li>Dados ordenados: Excelente resist\u00eancia a sequ\u00eancias ordenadas</li> </ul>"},{"location":"disciplinas/EDA2/redblack/#52-aplicacoes-praticas","title":"5.2 Aplica\u00e7\u00f5es Pr\u00e1ticas","text":"<ul> <li>Bancos de dados: \u00cdndices prim\u00e1rios e secund\u00e1rios</li> <li>Sistemas de arquivos: Estruturas de diret\u00f3rios</li> <li>Compiladores: Tabelas de s\u00edmbolos eficientes</li> <li>Bibliotecas padr\u00e3o: Implementa\u00e7\u00e3o de mapas e conjuntos ordenados</li> </ul>"},{"location":"disciplinas/EDA2/skipList/","title":"Skip List - Implementa\u00e7\u00e3o e An\u00e1lise","text":""},{"location":"disciplinas/EDA2/skipList/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma Skip List \u00e9 uma estrutura de dados probabil\u00edstica que consiste em m\u00faltiplas listas encadeadas ordenadas, permitindo busca eficiente com complexidade m\u00e9dia O(log n).</p> <p>Princ\u00edpio fundamental: Utiliza m\u00faltiplos n\u00edveis de listas encadeadas, onde: - N\u00edvel 0: Cont\u00e9m todos os elementos em ordem - N\u00edveis superiores: Cont\u00eam subconjuntos dos elementos, servindo como \"pistas expressas\" para busca r\u00e1pida - Altura probabil\u00edstica: Cada elemento tem uma probabilidade de aparecer em n\u00edveis superiores</p> <p> Estrutura de uma Skip List</p>"},{"location":"disciplinas/EDA2/skipList/#2-estrutura-de-dados","title":"2. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/skipList/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para Skip List:<pre><code>typedef int Key;  // Tipo da chave\n\n// Estrutura do item (chave + dados)\ntypedef struct {\n    Key k;        // Chave\n    // data d;    // Dados associados (pode ser expandido)\n} Item;\n\n#define NULL_ITEM {0}  // Item nulo\n\n// Macros para manipula\u00e7\u00e3o de itens\n#define key(A) ((A).k)\n#define less(A, B) (key(A) &lt; key(B))\n#define eq(A, B) (key(A) == key(B))\n\n// Constantes\n#define LG_N_MAX 16     // N\u00famero m\u00e1ximo de n\u00edveis\n#define RAND_MAX 32767  // Valor m\u00e1ximo para rand()\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#22-estrutura-do-no","title":"2.2 Estrutura do N\u00f3","text":"Estrutura do n\u00f3 da Skip List:<pre><code>typedef struct STNode *link;\n\nstruct STNode {\n    Item item;       // Item armazenado\n    link *links;     // Vetor de ponteiros para pr\u00f3ximos n\u00f3s (um por n\u00edvel)\n    int sz;          // N\u00famero de links/n\u00edveis do n\u00f3\n};\n\n// Vari\u00e1veis globais\nlink head;  // N\u00f3 cabe\u00e7a (in\u00edcio da lista)\nlink z;     // N\u00f3 sentinela (fim da lista)\nint N;      // N\u00famero de elementos na lista\nint lgN;    // N\u00famero atual de n\u00edveis\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#3-implementacao-das-operacoes","title":"3. Implementa\u00e7\u00e3o das Opera\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/skipList/#31-inicializacao-e-utilidades","title":"3.1 Inicializa\u00e7\u00e3o e Utilidades","text":"Inicializa\u00e7\u00e3o e fun\u00e7\u00f5es auxiliares:<pre><code>// Criar um novo n\u00f3 com k n\u00edveis\nlink NEW(Item item, int k) {\n    link x = malloc(sizeof(struct STNode));\n    x-&gt;item = item;\n    x-&gt;links = malloc(k * sizeof(link));\n    x-&gt;sz = k;\n\n    // Inicializa todos os links apontando para sentinela\n    for (int i = 0; i &lt; k; i++)\n        x-&gt;links[i] = z;\n\n    return x;\n}\n\n// Inicializar a Skip List\nvoid ST_init(int max) {\n    N = 0;\n    lgN = 0;\n    z = NEW(NULL_ITEM, 0);  // N\u00f3 sentinela (sem links)\n    head = NEW(NULL_ITEM, LG_N_MAX + 1);  // N\u00f3 cabe\u00e7a com m\u00e1ximo de n\u00edveis\n\n    // Inicializa todos os links do cabe\u00e7a apontando para sentinela\n    for (int i = 0; i &lt;= LG_N_MAX; i++)\n        head-&gt;links[i] = z;\n}\n\n// Fun\u00e7\u00e3o para determinar aleatoriamente o n\u00famero de n\u00edveis de um novo n\u00f3\nint randX() {\n    int i, j, t = rand();\n\n    // Determina quantos n\u00edveis o novo n\u00f3 ter\u00e1\n    for (i = 1, j = 2; i &lt; LG_N_MAX; i++, j *= 2) {\n        if (t &gt; RAND_MAX / j) break;\n    }\n\n    // Atualiza lgN se necess\u00e1rio\n    if (i &gt; lgN) lgN = i;\n\n    return i;\n}\n\n// Retorna o n\u00famero de elementos\nint ST_count() {\n    return N;\n}\n\n// Verifica se a lista est\u00e1 vazia\nint ST_empty() {\n    return N == 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#32-busca","title":"3.2 Busca","text":"Busca recursiva:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de busca\nItem ST_search(Key v) {\n    return searchR(head, v, lgN);\n}\n\n// Fun\u00e7\u00e3o recursiva de busca\nItem searchR(link t, Key v, int k) {\n    if (t == z)  // Chegou ao fim da lista\n        return NULL_ITEM;\n\n    Key tk = key(t-&gt;links[k]-&gt;item);\n\n    if (eq(tk, v))  // Encontrou a chave\n        return t-&gt;links[k]-&gt;item;\n\n    if (t-&gt;links[k] == z) {  // Fim da lista neste n\u00edvel\n        if (k &gt; 0) \n            return searchR(t, v, k - 1);  // Desce um n\u00edvel\n        else \n            return NULL_ITEM;  // N\u00e3o encontrado\n    }\n\n    if (less(v, tk)) {  // Chave \u00e9 menor, desce um n\u00edvel\n        if (k &gt; 0) \n            return searchR(t, v, k - 1);\n        else \n            return NULL_ITEM;\n    }\n\n    return searchR(t-&gt;links[k], v, k);  // Continua no mesmo n\u00edvel\n}\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#33-insercao","title":"3.3 Inser\u00e7\u00e3o","text":"Inser\u00e7\u00e3o recursiva:<pre><code>// Fun\u00e7\u00e3o p\u00fablica de inser\u00e7\u00e3o\nvoid ST_insert(Item item) {\n    link x = NEW(item, randX());  // Cria novo n\u00f3 com altura aleat\u00f3ria\n    insertR(head, x, lgN);       // Insere recursivamente\n    N++;                         // Incrementa contador\n}\n\n// Fun\u00e7\u00e3o recursiva de inser\u00e7\u00e3o\nvoid insertR(link t, link x, int k) {\n    Key v = key(x-&gt;item);\n\n    if (less(v, key(t-&gt;links[k]-&gt;item))) {\n        // Insere neste n\u00edvel se o novo n\u00f3 tem n\u00edvel suficiente\n        if (k &lt; x-&gt;sz) {\n            x-&gt;links[k] = t-&gt;links[k];\n            t-&gt;links[k] = x;\n        }\n\n        // Continua inser\u00e7\u00e3o nos n\u00edveis inferiores\n        if (k == 0) return;\n        insertR(t, x, k - 1);\n    } else {\n        // Avan\u00e7a para o pr\u00f3ximo n\u00f3 neste n\u00edvel\n        insertR(t-&gt;links[k], x, k);\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#34-travessia-e-ordenacao","title":"3.4 Travessia e Ordena\u00e7\u00e3o","text":"Travessia em ordem:<pre><code>// Fun\u00e7\u00e3o de visita\nvoid visit(Item i) {\n    printf(\"%d \", key(i));\n}\n\n// Travessia em ordem (n\u00edvel 0)\nvoid ST_traverse(void (*visit)(Item)) {\n    link current = head-&gt;links[0];\n\n    while (current != z) {\n        visit(current-&gt;item);\n        current = current-&gt;links[0];\n    }\n}\n\n// Fun\u00e7\u00e3o para imprimir todos os n\u00edveis (debug)\nvoid ST_printLevels() {\n    for (int level = lgN; level &gt;= 0; level--) {\n        printf(\"Level %d: \", level);\n        link current = head-&gt;links[level];\n\n        while (current != z) {\n            printf(\"%d \", key(current-&gt;item));\n            current = current-&gt;links[level];\n        }\n        printf(\"\\n\");\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#35-exemplo-de-uso","title":"3.5 Exemplo de Uso","text":"Exemplo de uso da Skip List:<pre><code>int main() {\n    ST_init(100);  // Inicializa Skip List com capacidade m\u00e1xima 100\n\n    // Insere elementos: 5, 3, 7, 2, 4, 6, 8\n    Item items[] = {{5}, {3}, {7}, {2}, {4}, {6}, {8}};\n\n    for (int i = 0; i &lt; 7; i++) {\n        ST_insert(items[i]);\n        printf(\"Inserido: %d\\n\", key(items[i]));\n    }\n\n    printf(\"\\nN\u00famero de elementos: %d\\n\", ST_count());\n    printf(\"N\u00edveis atuais: %d\\n\", lgN);\n\n    printf(\"\\nElementos em ordem: \");\n    ST_traverse(visit);\n\n    printf(\"\\n\\nEstrutura por n\u00edveis:\\n\");\n    ST_printLevels();\n\n    // Busca por uma chave\n    Key busca = 4;\n    Item resultado = ST_search(busca);\n    if (key(resultado) != 0) {\n        printf(\"\\nEncontrado: %d\\n\", key(resultado));\n    } else {\n        printf(\"\\nN\u00e3o encontrado: %d\\n\", busca);\n    }\n\n    busca = 10;\n    resultado = ST_search(busca);\n    if (key(resultado) != 0) {\n        printf(\"Encontrado: %d\\n\", key(resultado));\n    } else {\n        printf(\"N\u00e3o encontrado: %d\\n\", busca);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/skipList/#4-analise-de-performance","title":"4. An\u00e1lise de Performance","text":""},{"location":"disciplinas/EDA2/skipList/#41-complexidade-das-operacoes","title":"4.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Melhor Caso Caso M\u00e9dio Pior Caso Busca O(1) O(log n) O(n) Inser\u00e7\u00e3o O(1) O(log n) O(n) Remo\u00e7\u00e3o O(1) O(log n) O(n) Travessia O(n) O(n) O(n)"},{"location":"disciplinas/EDA2/skipList/#42-propriedades-probabilisticas","title":"4.2 Propriedades Probabil\u00edsticas","text":"<ul> <li>Altura esperada: O(log n) com alta probabilidade</li> <li>N\u00famero esperado de n\u00edveis: \u2248 log\u2082n</li> <li>Espa\u00e7o esperado: O(n) (cada elemento aparece em \u22482 n\u00edveis em m\u00e9dia)</li> </ul>"},{"location":"disciplinas/EDA2/skipList/#43-vantagens","title":"4.3 Vantagens","text":"<ul> <li>Implementa\u00e7\u00e3o simples: Mais f\u00e1cil que \u00e1rvores balanceadas</li> <li>Balanceamento autom\u00e1tico: N\u00e3o requer opera\u00e7\u00f5es complexas de rebalanceamento</li> <li>Performance consistente: Boa performance m\u00e9dia na pr\u00e1tica</li> <li>Flexibilidade: F\u00e1cil de modificar e extender</li> </ul>"},{"location":"disciplinas/EDA2/skipList/#44-desvantagens","title":"4.4 Desvantagens","text":"<ul> <li>Performance probabil\u00edstica: Caso raro de performance O(n)</li> <li>Uso de mem\u00f3ria: Overhead de ponteiros extras</li> <li>Aleatoriedade: Depende de gerador de n\u00fameros aleat\u00f3rios</li> </ul>"},{"location":"disciplinas/EDA2/skipList/#5-consideracoes-finais","title":"5. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/skipList/#51-quando-usar-skip-list","title":"5.1 Quando Usar Skip List","text":"<ul> <li>Implementa\u00e7\u00f5es simples: Quando complexidade de c\u00f3digo \u00e9 importante</li> <li>Dados din\u00e2micos: Muitas inser\u00e7\u00f5es/remo\u00e7\u00f5es</li> <li>Mem\u00f3ria dispon\u00edvel: Overhead de ponteiros \u00e9 aceit\u00e1vel</li> <li>Aplica\u00e7\u00f5es concorrentes: F\u00e1cil de tornar thread-safe</li> </ul>"},{"location":"disciplinas/EDA2/skipList/#52-aplicacoes-praticas","title":"5.2 Aplica\u00e7\u00f5es Pr\u00e1ticas","text":"<ul> <li>Bancos de dados: \u00cdndices em mem\u00f3ria</li> <li>Sistemas distribu\u00eddos: Tabelas de roteamento</li> <li>Aplica\u00e7\u00f5es de rede: Cache de consultas DNS</li> <li>Editores de texto: Estruturas de dados para documentos grandes</li> </ul>"},{"location":"disciplinas/EDA2/skipList/#53-comparacao-com-outras-estruturas","title":"5.3 Compara\u00e7\u00e3o com Outras Estruturas","text":"Caracter\u00edstica BST \u00c1rvore 2-3 ARNE Skip List Complexidade M\u00e9dia Alta M\u00e9dia Baixa Balanceamento N\u00e3o Sim Sim Probabil\u00edstico Performance Vari\u00e1vel Garantida Garantida M\u00e9dia Mem\u00f3ria Baixa Alta M\u00e9dia M\u00e9dia-Alta"},{"location":"disciplinas/EDA2/tabelaSimb/","title":"Tabelas de S\u00edmbolos (Symbol Tables - ST)","text":""},{"location":"disciplinas/EDA2/tabelaSimb/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Uma Tabela de S\u00edmbolos (ST) \u00e9 uma estrutura de dados fundamental que armazena pares chave-valor, onde a chave \u00e9 usada para identificar unicamente um item e o valor cont\u00e9m informa\u00e7\u00f5es associadas a esse item.</p> <p>Princ\u00edpio fundamental: Fornecer opera\u00e7\u00f5es eficientes para inser\u00e7\u00e3o, busca e remo\u00e7\u00e3o de itens baseados em suas chaves.</p>"},{"location":"disciplinas/EDA2/tabelaSimb/#2-interface-basica","title":"2. Interface B\u00e1sica","text":""},{"location":"disciplinas/EDA2/tabelaSimb/#21-definicoes-e-macros","title":"2.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para Tabela de S\u00edmbolos:<pre><code>#define key int\n#define less(A, B) ((A) &lt; (B))\n#define eq(A, B) ((A) == (B))\n\ntypedef struct {\n    key k;    // Chave (identificador \u00fanico)\n    data d;   // Dados associados \u00e0 chave\n} Item;\n\n#define key(A) (A.k)  // Macro para acessar a chave de um item\n</code></pre>"},{"location":"disciplinas/EDA2/tabelaSimb/#22-operacoes-basicas","title":"2.2 Opera\u00e7\u00f5es B\u00e1sicas","text":"Interface da Tabela de S\u00edmbolos:<pre><code>// Inicializa a tabela\nvoid ST_init();\n\n// Insere um item na tabela\nvoid ST_insert(Item ni);\n\n// Remove um item pela chave\nvoid ST_remove(key r);\n\n// Busca um item pela chave\nItem ST_search(key k);\n\n// Verifica se a tabela est\u00e1 vazia\nint ST_empty();\n\n// Retorna o n\u00famero de itens na tabela\nint ST_count();\n</code></pre>"},{"location":"disciplinas/EDA2/tabelaSimb/#3-implementacoes-de-tabelas-de-simbolos","title":"3. Implementa\u00e7\u00f5es de Tabelas de S\u00edmbolos","text":""},{"location":"disciplinas/EDA2/tabelaSimb/#31-implementacao-com-vetor-linear","title":"3.1 Implementa\u00e7\u00e3o com Vetor Linear","text":""},{"location":"disciplinas/EDA2/tabelaSimb/#311-caracteristicas","title":"3.1.1 Caracter\u00edsticas","text":"<ul> <li>Usa um vetor para armazenar itens sequencialmente;</li> <li><code>st_last</code> indica o n\u00famero de itens e a pr\u00f3xima posi\u00e7\u00e3o livre;</li> <li>Ideal para opera\u00e7\u00f5es simples, mas com desempenho linear para busca e remo\u00e7\u00e3o;</li> </ul>"},{"location":"disciplinas/EDA2/tabelaSimb/#312-implementacao","title":"3.1.2 Implementa\u00e7\u00e3o","text":"Implementa\u00e7\u00e3o com vetor linear:<pre><code>#define MAX_ITENS 1000000\n\nint st_last;    // N\u00famero de itens e pr\u00f3xima posi\u00e7\u00e3o livre\nItem *st;       // Vetor de itens\n\n// Inicializa a tabela\nint ST_init() {\n    st = malloc(sizeof(Item) * MAX_ITENS);\n    if (st == NULL) return 0;  // Falha na aloca\u00e7\u00e3o\n    st_last = 0;\n    return 1;  // Sucesso\n}\n\n// Insere um item no final do vetor\nvoid ST_insert(Item ni) {\n    if (st_last &lt; MAX_ITENS) {\n        st[st_last++] = ni;\n    }\n}\n\n// Verifica se a tabela est\u00e1 vazia\nint ST_empty() {\n    return st_last == 0;\n}\n\n// Retorna o n\u00famero de itens\nint ST_count() {\n    return st_last;\n}\n\n// Busca linear por uma chave\nint ST_search_index(key k) {\n    for (int i = 0; i &lt; st_last; i++) {\n        if (eq(k, key(st[i]))) {\n            return i;  // Retorna o \u00edndice do item encontrado\n        }\n    }\n    return -1;  // N\u00e3o encontrado\n}\n\n// Busca e retorna o item\nItem ST_search(key k) {\n    int index = ST_search_index(k);\n    if (index != -1) {\n        return st[index];\n    }\n    // Retorna um item vazio ou trata o erro\n    Item empty_item = {0};\n    return empty_item;\n}\n\n// Remove um item pela chave\nvoid ST_remove(key r) {\n    int to_remove = ST_search_index(r);\n    if (to_remove != -1) {\n        // Move o \u00faltimo item para a posi\u00e7\u00e3o a ser removida\n        st[to_remove] = st[st_last - 1];\n        st_last--;\n    }\n}\n\n// Destr\u00f3i a tabela liberando a mem\u00f3ria\nvoid ST_destroy() {\n    free(st);\n    st_last = 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/tabelaSimb/#313-analise-de-complexidade","title":"3.1.3 An\u00e1lise de Complexidade","text":"Opera\u00e7\u00e3o Complexidade Descri\u00e7\u00e3o ST_insert O(1) Inser\u00e7\u00e3o no final do vetor ST_search O(n) Busca linear no vetor ST_remove O(n) Busca + movimenta\u00e7\u00e3o de elementos ST_count O(1) Acesso direto ao contador"},{"location":"disciplinas/EDA2/tabelaSimb/#32-implementacao-com-lista-encadeada","title":"3.2 Implementa\u00e7\u00e3o com Lista Encadeada","text":""},{"location":"disciplinas/EDA2/tabelaSimb/#321-caracteristicas","title":"3.2.1 Caracter\u00edsticas","text":"<ul> <li>Cada n\u00f3 cont\u00e9m um item e um ponteiro para o pr\u00f3ximo n\u00f3;</li> <li>Inser\u00e7\u00f5es s\u00e3o feitas no in\u00edcio da lista (mais eficiente);</li> <li>Flex\u00edvel quanto ao tamanho (crescimento din\u00e2mico);</li> </ul>"},{"location":"disciplinas/EDA2/tabelaSimb/#322-implementacao","title":"3.2.2 Implementa\u00e7\u00e3o","text":"Implementa\u00e7\u00e3o com lista encadeada:<pre><code>// Estrutura do n\u00f3 da lista\ntypedef struct ST_node {\n    Item item;\n    struct ST_node *next;\n} ST_node;\n\nST_node *st_head;  // Cabe\u00e7a da lista\nint st_count;      // Contador de elementos\n\n// Inicializa a tabela\nvoid ST_init() {\n    st_head = NULL;\n    st_count = 0;\n}\n\n// Insere um item no in\u00edcio da lista\nvoid ST_insert(Item ni) {\n    ST_node *new_node = malloc(sizeof(ST_node));\n    if (new_node == NULL) return;  // Falha na aloca\u00e7\u00e3o\n\n    new_node-&gt;item = ni;\n    new_node-&gt;next = st_head;\n    st_head = new_node;\n    st_count++;\n}\n\n// Verifica se a tabela est\u00e1 vazia\nint ST_empty() {\n    return st_head == NULL;\n}\n\n// Retorna o n\u00famero de itens\nint ST_count() {\n    return st_count;\n}\n\n// Busca por uma chave na lista\nItem ST_search(key k) {\n    ST_node *current = st_head;\n\n    while (current != NULL) {\n        if (eq(k, key(current-&gt;item))) {\n            return current-&gt;item;  // Item encontrado\n        }\n        current = current-&gt;next;\n    }\n\n    // Item n\u00e3o encontrado\n    Item empty_item = {0};\n    return empty_item;\n}\n\n// Remove um item pela chave\nvoid ST_remove(key r) {\n    ST_node *current = st_head;\n    ST_node *prev = NULL;\n\n    while (current != NULL) {\n        if (eq(r, key(current-&gt;item))) {\n            // Item encontrado, remover da lista\n            if (prev == NULL) {\n                // Remover o primeiro elemento\n                st_head = current-&gt;next;\n            } else {\n                prev-&gt;next = current-&gt;next;\n            }\n\n            free(current);\n            st_count--;\n            return;\n        }\n\n        prev = current;\n        current = current-&gt;next;\n    }\n}\n\n// Destr\u00f3i a tabela liberando toda a mem\u00f3ria\nvoid ST_destroy() {\n    ST_node *current = st_head;\n    ST_node *next;\n\n    while (current != NULL) {\n        next = current-&gt;next;\n        free(current);\n        current = next;\n    }\n\n    st_head = NULL;\n    st_count = 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/tabelaSimb/#323-analise-de-complexidade","title":"3.2.3 An\u00e1lise de Complexidade","text":"Opera\u00e7\u00e3o Complexidade Descri\u00e7\u00e3o ST_insert O(1) Inser\u00e7\u00e3o no in\u00edcio da lista ST_search O(n) Busca linear na lista ST_remove O(n) Busca + remo\u00e7\u00e3o do n\u00f3 ST_count O(1) Acesso direto ao contador"},{"location":"disciplinas/EDA2/tabelaSimb/#4-comparacao-das-implementacoes","title":"4. Compara\u00e7\u00e3o das Implementa\u00e7\u00f5es","text":"Aspecto Vetor Linear Lista Encadeada Inser\u00e7\u00e3o O(1) O(1) Busca O(n) O(n) Remo\u00e7\u00e3o O(n) O(n) Espa\u00e7o O(n) O(n) Crescimento Tamanho fixo Din\u00e2mico Localidade Boa (cache) Ruim Simplicidade Alta M\u00e9dia"},{"location":"disciplinas/EDA2/Grafos/arvoreGer/","title":"\u00c1rvores Geradoras M\u00ednimas (MST)","text":""},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#1-arvores-geradoras-de-um-grafo-nao-dirigido","title":"1. \u00c1rvores Geradoras de um Grafo N\u00e3o-dirigido","text":"<p>\u00c9 um subconjunto das arestas de um grafo conectado e n\u00e3o dirigido;</p> <ul> <li>Contem todos os vertices de G;</li> <li>\u00c9 conexo e sem ciclos;</li> <li>Se o GND tem V v\u00e9rtices, a AG tem V - 1 arestas;</li> </ul> Exemplo:<pre><code>// grafo\n    A\n   / \\\n  B---C\n  |   |\n  D---E\n\n// possivel arvore geradora\n    A\n   / \\\n  B   C\n  |\n  D\n   \\\n    E\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#2-arvore-geradora-minima","title":"2. \u00c1rvore Geradora M\u00ednima","text":"<p>Uma \u00c1rvore Geradora M\u00ednima (MST - Minimum Spanning Tree) de um grafo n\u00e3o-dirigido e conexo \u00e9 uma \u00e1rvore geradora que:</p> <ul> <li>Conecta todos os v\u00e9rtices</li> <li>N\u00e3o forma ciclos</li> <li>Tem a soma m\u00ednima poss\u00edvel dos pesos das arestas</li> </ul> <p>Propriedades importantes: - Se o grafo tem V v\u00e9rtices, a MST tem exatamente V-1 arestas - Pode existir mais de uma MST para o mesmo grafo - S\u00f3 existe MST se o grafo for conexo</p>"},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#3-algoritmos-geradores-de-mst","title":"3. Algor\u00edtmos Geradores de MST","text":""},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#31-algoritmo-de-prim","title":"3.1. Algoritmo de Prim","text":"<p>Termos:</p> <ul> <li>Franja: Conjuntos de arestas que ligam a arvore atual T a vertices fora dela;</li> <li>Gancho: \u00c9 o v\u00e9rtice dentro da arvore que puxa um vertice de fora por meio da arestas mais barata;</li> <li>Pre\u00e7o: \u00c9 o custo da menor aresta que liga um vertice fora da arvore a algum vertice de dentro;</li> </ul> <p>Caracteristicas:</p> <ul> <li>Encontra a MST em um grafo n\u00e3o dirigido e conexo;</li> <li>Arestas podem ter custos positivos e negativos</li> <li>Algortimo simples por\u00e9m com implementa\u00e7\u00e3o eficiente possui dificuldade inesperadas;</li> </ul> <p>Ideia central:</p> <ul> <li>Come\u00e7a em qualquer  v\u00e9rtice, por exemplo o v</li> <li>Formado uma franja com todos as arestas que iniciam com v;</li> <li>Se escolhe a aresta com menor custo, exemplo v-x;</li> <li>V\u00e9rtice v (gancho) puxa para franja todas as arestas que iniciam com x;</li> <li>Novamente se escolhe a aresta com menor custo;</li> <li>Continua at\u00e9 todos os vertices estarem na arvore;</li> </ul> <p>Usado em:</p> <ul> <li>Constru\u00e7\u00e3o de redes (eletrica, internet, estrada);</li> <li>Redu\u00e7\u00e3o de custo em liga\u00e7\u00e3o entre pontos;</li> </ul> <p>Versoes:</p> <p>Ingenua:</p> <ul> <li>Desenpenho: O (V\u00b2 +E)</li> </ul> <p>Eficiente 1:</p> <ul> <li>Usa vetores de pre\u00e7o e ganho;<ul> <li>Mantem eles atualizados;</li> <li>Evita calcular toda a franja a cada passo;</li> </ul> </li> <li>Desepenho: O( V\u00b2)</li> </ul> <p>Eficiente 2:</p> <ul> <li>Usa fila de prioridade (heap)<ul> <li>Para encontrar o menor pre\u00e7o;</li> </ul> </li> <li>Melhor em grafos esparsos (pouca aresta por v\u00e9rtice);</li> <li>Desenpenho: E log V</li> </ul> Algoritmo de Prim para MST:<pre><code>#define UGraph Graph\n/* Recebe um grafo n\u00e3o-dirigido conexo G com custos arbitr\u00e1rios nas arestas e calcula uma MST de G.  A fun\u00e7\u00e3o trata a MST como uma \u00e1rvore radicada com raiz 0 e armazena a \u00e1rvore no vetor de pais pa[].  (A fun\u00e7\u00e3o implementa o algoritmo de Prim. O grafo G e os custos s\u00e3o representados por listas de adjac\u00eancia. O c\u00f3digo abaixo foi inspirado no Programa 21.1 de Sedgewick.) */\nvoid UGRAPHmstP2( UGraph G, vertex *pa)\n{ \n   bool tree[1000];\n   int preco[1000];\n   // inicializa\u00e7\u00e3o:\n   for (vertex v = 1; v &lt; G-&gt;V; ++v) \n      pa[v] = -1, tree[v] = false, preco[v] = INFINITY; \n   pa[0] = 0, tree[0] = true;\n   for (link a = G-&gt;adj[0]; a != NULL; a = a-&gt;next) \n      pa[a-&gt;w] = 0, preco[a-&gt;w] = a-&gt;c; \n\n   PQinit( G-&gt;V); \n   for (vertex v = 1; v &lt; G-&gt;V; ++v)\n      PQinsert( v, preco);\n\n   while (!PQempty( )) {\n      vertex y = PQdelmin( preco);\n      if (preco[y] == INFINITY) break;\n      tree[y] = true;\n      // atualiza\u00e7\u00e3o dos pre\u00e7os e ganchos:\n      for (link a = G-&gt;adj[y]; a != NULL; a = a-&gt;next) \n         if (!tree[a-&gt;w] &amp;&amp; a-&gt;c &lt; preco[a-&gt;w]) { \n            preco[a-&gt;w] = a-&gt;c;\n            PQdec( a-&gt;w, preco); \n            pa[a-&gt;w] = y; \n         }\n   }\n   PQfree( );\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#32-algoritmo-de-kruskal","title":"3.2 Algoritmo de Kruskal","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Seleciona arestas de menor peso, sem formar ciclos, at\u00e9 ligar todos os v\u00e9rtices;</li> </ul> <p>Ideia central:</p> <ul> <li>Ordena as  arestas por peso crescente;</li> <li>Inicializa com a aresta de menor peso;</li> <li>Cada itera\u00e7\u00e3o vai adicionando uma aresta;</li> <li>Se a proxima aresta possui uma aresta que ja esta esta conectada indiretamente pela floresta atual, \u00e9 pulada;</li> </ul> <p>Bom quando:</p> <ul> <li>Grafos esparsos (poucas arestas);</li> <li>Grafos nao dirigidos;</li> <li>Tem uma lista das arestas</li> </ul> <p>Componentes:</p> <ul> <li><code>Sort-Edges(G)</code>: ordena as <code>m</code> arestas por peso crescente.</li> <li><code>Find(u)</code>: retorna o representante (diretor) da componente de <code>u</code>.</li> <li><code>Union(r, s)</code>: une as componentes representadas por <code>r</code> e <code>s</code>.</li> </ul> <p>Eficiencia:</p> <ul> <li>Ordenar arestas: O (m log n);</li> <li>Find: O (log n)</li> <li>Union: O (1);</li> <li>Total: O (n + m log n);</li> </ul> Algoritmo de Kruskal para MST:<pre><code>MST-Kruskal (G, n, m, p)\narestas := Sort-Edges\u2009(G, m, p)\nX := { }\nInitialize\u2009()\npara i := 1 at\u00e9 m\n    uv := arestas[i]\n    r := Find\u2009(u)\n    s := Find\u2009(v)\n    se r \u2260 s\n         X := X\u2009\u222a\u2009{\u200auv\u200a}\n       Union\u2009(r, s)\ndevolva (V(G),\u2009X)\n\n\n1. Ordene as arestas por peso crescente.\n2. Inicialize F como floresta vazia (sem arestas).\n3. Para cada aresta uv na ordem:\n    - Se u e v est\u00e3o em componentes diferentes (n\u00e3o formam ciclo):\n        - Adicione uv \u00e0 floresta F.\n        - Una as componentes de u e v.\n4. Quando F tiver (n - 1) arestas, pare.\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/arvoreGer/#4-comparacao-dos-algoritmos","title":"4. Compara\u00e7\u00e3o dos Algoritmos","text":"Algoritmo Guloso MST Peso negativo Detecta ciclo Grafos esparsos/grandes Grafos densos/pequenos Suporta grafo direcionado Pr\u00e9-condi\u00e7\u00f5es / Quando usar Exemplo Complexidade Bellman-Ford n\u00e3o n\u00e3o sim sim (ciclo negativo) ok n\u00e3o sim Quando h\u00e1 arestas negativas Mercado financeiro O(V\u00b7E) Dijkstra sim n\u00e3o n\u00e3o n\u00e3o sim (lista + heap) ok sim Grafos com pesos positivos Rotas em mapas (Waze) O(E log V) Prim sim sim sim n\u00e3o (evita) ok sim (heap ajuda) n\u00e3o MST em grafos densos e conexos Redes el\u00e9tricas, internet O(E + V log V) Kruskal sim sim sim n\u00e3o (evita) sim ok n\u00e3o MST em grafos esparsos e conexos Redes de fibra \u00f3tica O(E log V)"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/","title":"Algoritmos para Caminhos M\u00ednimos","text":""},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#1-algoritmo-de-bellman-ford","title":"1. Algoritmo de Bellman-Ford","text":""},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#11-conceitos-e-caracteristicas","title":"1.1 Conceitos e Caracter\u00edsticas","text":"<p>O algoritmo de Bellman-Ford \u00e9 utilizado para encontrar caminhos m\u00ednimos em grafos com pesos que podem ser negativos, al\u00e9m de detectar ciclos negativos.</p> <p>Principais caracter\u00edsticas: - Funciona com pesos negativos - Detecta ciclos negativos - Complexidade: O(V \u00d7 E) - quadr\u00e1tica - Menos eficiente que Dijkstra para grafos sem pesos negativos</p>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#12-implementacao","title":"1.2 Implementa\u00e7\u00e3o","text":"Implementa\u00e7\u00e3o do Bellman-Ford:<pre><code>bool GRAPHcptBF(Graph G, int s, int *pa, int *dist) {\n    bool onqueue[1000];\n\n    for (int v = 0; v &lt; G-&gt;V; v++)\n        pa[v] = -1, dist[v] = INT_MAX, onqueue[v] = false;\n\n    pa[s] = s;\n    dist[s] = 0;\n\n    QueueInit(G-&gt;E);\n    QueuePut(s);\n    onqueue[s] = true;\n\n    QueuePut(G-&gt;V);\n    int k = 0;\n\n    while (1) {\n        int v = QueueGet();\n        if (v &lt; G-&gt;V) {\n            for (link a = G-&gt;adj[v]; a != NULL; a = a-&gt;next) {\n                if (dist[v] + a-&gt;c &lt; dist[a-&gt;w]) {\n                    dist[a-&gt;w] = dist[v] + a-&gt;c;\n                    pa[a-&gt;w] = v;\n\n                    if (onqueue[a-&gt;w] == false) {\n                        QueuePut(a-&gt;w);\n                        onqueue[a-&gt;w] = true;\n                    }\n                }\n            }\n        } else {\n            if (QueueEmpty()) return true;\n            if (++k &gt;= G-&gt;V) return false;\n\n            QueuePut(G-&gt;V);\n            for (int t = 0; t &lt; G-&gt;V; t++)\n                onqueue[t] = false;\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#13-exemplo-de-execucao","title":"1.3 Exemplo de Execu\u00e7\u00e3o","text":"Exemplo de uso do Bellman-Ford:<pre><code>int main() {\n    // Cria grafo de exemplo\n    Graph *G = malloc(sizeof(Graph));\n    G-&gt;V = 4;\n    G-&gt;E = 5;\n    G-&gt;adj = malloc(G-&gt;V * sizeof(Node*));\n    for (int i = 0; i &lt; G-&gt;V; i++) G-&gt;adj[i] = NULL;\n\n    // Insere arestas (incluindo peso negativo)\n    // 0 \u2192 1: -1\n    // 0 \u2192 2: 4\n    // 1 \u2192 2: 3\n    // 1 \u2192 3: 2\n    // 3 \u2192 1: -6 (ciclo negativo potencial)\n\n    // Executa Bellman-Ford\n    int *dist = malloc(G-&gt;V * sizeof(int));\n    int *parent = malloc(G-&gt;V * sizeof(int));\n\n    bool has_negative_cycle = !GRAPHcptBF(G, 0, parent, dist);\n\n    if (has_negative_cycle) {\n        printf(\"O grafo cont\u00e9m ciclo negativo!\\n\");\n    } else {\n        printf(\"Dist\u00e2ncias m\u00ednimas a partir do v\u00e9rtice 0:\\n\");\n        for (int i = 0; i &lt; G-&gt;V; i++) {\n            if (dist[i] == INT_MAX) {\n                printf(\"V\u00e9rtice %d: Inalcan\u00e7\u00e1vel\\n\", i);\n            } else {\n                printf(\"V\u00e9rtice %d: %d\\n\", i, dist[i]);\n            }\n        }\n    }\n\n    free(dist);\n    free(parent);\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#14-aplicacoes-do-bellman-ford","title":"1.4 Aplica\u00e7\u00f5es do Bellman-Ford","text":"<ul> <li>Arbitragem em mercados financeiros: Detec\u00e7\u00e3o de oportunidades onde sequ\u00eancias de transa\u00e7\u00f5es resultam em lucro garantido</li> <li>Redes de computadores: Roteamento com m\u00e9tricas complexas</li> <li>Sistemas de transporte: Otimiza\u00e7\u00e3o considerando custos que podem ser negativos (subs\u00eddios)</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#2-algoritmo-de-dijkstra","title":"2. Algoritmo de Dijkstra","text":""},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#21-conceitos-e-caracteristicas","title":"2.1 Conceitos e Caracter\u00edsticas","text":"<p>O algoritmo de Dijkstra encontra caminhos m\u00ednimos em grafos com pesos n\u00e3o-negativos usando uma abordagem gulosa.</p> <p>Principais caracter\u00edsticas: - Muito eficiente para grafos com pesos n\u00e3o-negativos - N\u00e3o funciona com pesos negativos - N\u00e3o detecta ciclos negativos - Complexidade: O(V\u00b2) na vers\u00e3o simples, O(E + V log V) com fila de prioridade</p>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#22-implementacao","title":"2.2 Implementa\u00e7\u00e3o","text":"Implementa\u00e7\u00e3o do Dijkstra com Fila de Prioridade:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;limits.h&gt;\n\n// Estrutura para elementos da fila de prioridade\ntypedef struct {\n    int vertex;\n    int distance;\n} HeapNode;\n\n// Estrutura do min-heap\ntypedef struct {\n    HeapNode *nodes;\n    int size;\n    int capacity;\n} MinHeap;\n\nMinHeap* createMinHeap(int capacity) {\n    MinHeap *heap = malloc(sizeof(MinHeap));\n    heap-&gt;nodes = malloc(capacity * sizeof(HeapNode));\n    heap-&gt;size = 0;\n    heap-&gt;capacity = capacity;\n    return heap;\n}\n\nvoid swap(HeapNode *a, HeapNode *b) {\n    HeapNode temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid minHeapify(MinHeap *heap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left &lt; heap-&gt;size &amp;&amp; heap-&gt;nodes[left].distance &lt; heap-&gt;nodes[smallest].distance)\n        smallest = left;\n\n    if (right &lt; heap-&gt;size &amp;&amp; heap-&gt;nodes[right].distance &lt; heap-&gt;nodes[smallest].distance)\n        smallest = right;\n\n    if (smallest != idx) {\n        swap(&amp;heap-&gt;nodes[idx], &amp;heap-&gt;nodes[smallest]);\n        minHeapify(heap, smallest);\n    }\n}\n\nvoid insertMinHeap(MinHeap *heap, HeapNode node) {\n    if (heap-&gt;size == heap-&gt;capacity) return;\n\n    heap-&gt;size++;\n    int i = heap-&gt;size - 1;\n    heap-&gt;nodes[i] = node;\n\n    while (i != 0 &amp;&amp; heap-&gt;nodes[(i-1)/2].distance &gt; heap-&gt;nodes[i].distance) {\n        swap(&amp;heap-&gt;nodes[i], &amp;heap-&gt;nodes[(i-1)/2]);\n        i = (i-1)/2;\n    }\n}\n\nHeapNode extractMin(MinHeap *heap) {\n    if (heap-&gt;size &lt;= 0) return (HeapNode){-1, INT_MAX};\n\n    HeapNode root = heap-&gt;nodes[0];\n    heap-&gt;nodes[0] = heap-&gt;nodes[heap-&gt;size-1];\n    heap-&gt;size--;\n    minHeapify(heap, 0);\n\n    return root;\n}\n\nvoid dijkstra(Graph *G, int src, int *dist, int *parent) {\n    MinHeap *heap = createMinHeap(G-&gt;V);\n    int *visited = calloc(G-&gt;V, sizeof(int));\n\n    // Inicializa\u00e7\u00e3o\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        dist[i] = INT_MAX;\n        parent[i] = -1;\n    }\n    dist[src] = 0;\n\n    insertMinHeap(heap, (HeapNode){src, 0});\n\n    while (heap-&gt;size &gt; 0) {\n        HeapNode minNode = extractMin(heap);\n        int u = minNode.vertex;\n\n        if (visited[u]) continue;\n        visited[u] = 1;\n\n        Node *current = G-&gt;adj[u];\n        while (current != NULL) {\n            int v = current-&gt;w;\n            int weight = current-&gt;weight;\n\n            if (!visited[v] &amp;&amp; dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {\n                dist[v] = dist[u] + weight;\n                parent[v] = u;\n                insertMinHeap(heap, (HeapNode){v, dist[v]});\n            }\n            current = current-&gt;next;\n        }\n    }\n\n    free(heap-&gt;nodes);\n    free(heap);\n    free(visited);\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#23-exemplo-de-execucao","title":"2.3 Exemplo de Execu\u00e7\u00e3o","text":"Exemplo de uso do Dijkstra:<pre><code>int main() {\n    // Cria grafo com pesos n\u00e3o-negativos\n    Graph *G = malloc(sizeof(Graph));\n    G-&gt;V = 5;\n    G-&gt;E = 7;\n    G-&gt;adj = malloc(G-&gt;V * sizeof(Node*));\n    for (int i = 0; i &lt; G-&gt;V; i++) G-&gt;adj[i] = NULL;\n\n    // Insere arestas (0\u21921:4, 0\u21922:1, 1\u21923:1, 2\u21921:2, 2\u21923:5, 3\u21924:3)\n\n    int *dist = malloc(G-&gt;V * sizeof(int));\n    int *parent = malloc(G-&gt;V * sizeof(int));\n\n    printf(\"Executando Dijkstra a partir do v\u00e9rtice 0:\\n\");\n    dijkstra(G, 0, dist, parent);\n\n    printf(\"Dist\u00e2ncias m\u00ednimas:\\n\");\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        if (dist[i] == INT_MAX) {\n            printf(\"V\u00e9rtice %d: Inalcan\u00e7\u00e1vel\\n\", i);\n        } else {\n            printf(\"V\u00e9rtice %d: %d\\n\", i, dist[i]);\n        }\n    }\n\n    free(dist);\n    free(parent);\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#24-aplicacoes-do-dijkstra","title":"2.4 Aplica\u00e7\u00f5es do Dijkstra","text":"<ul> <li>Sistemas de navega\u00e7\u00e3o: GPS, aplicativos de rotas (Waze, Google Maps)</li> <li>Redes de computadores: Roteamento OSPF, IS-IS</li> <li>Log\u00edstica: Otimiza\u00e7\u00e3o de rotas de entrega</li> <li>Jogos: Pathfinding em games para encontrar caminhos mais curtos</li> <li>Rob\u00f3tica: Planejamento de trajet\u00f3ria para rob\u00f4s m\u00f3veis</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#3-comparacao-entre-os-algoritmos","title":"3. Compara\u00e7\u00e3o entre os Algoritmos","text":""},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#31-tabela-comparativa","title":"3.1 Tabela Comparativa","text":"Caracter\u00edstica Bellman-Ford Dijkstra Pesos negativos Suporta N\u00e3o suporta Ciclos negativos Detecta N\u00e3o detecta Complexidade O(V\u00d7E) O(V\u00b2) ou O(E + V log V) Abordagem Programa\u00e7\u00e3o din\u00e2mica Algoritmo guloso Uso de mem\u00f3ria Moderado Baixo a moderado Aplica\u00e7\u00f5es t\u00edpicas Arbitragem, redes Navega\u00e7\u00e3o, roteamento"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#32-escolha-do-algoritmo","title":"3.2 Escolha do Algoritmo","text":"<p>Use Bellman-Ford quando: - O grafo cont\u00e9m pesos negativos - Precisa detectar ciclos negativos - O grafo \u00e9 pequeno ou moderado</p> <p>Use Dijkstra quando: - Todos os pesos s\u00e3o n\u00e3o-negativos - Deseja m\u00e1xima efici\u00eancia - O grafo \u00e9 grande</p>"},{"location":"disciplinas/EDA2/Grafos/caminhoMin/#33-consideracoes-de-implementacao","title":"3.3 Considera\u00e7\u00f5es de Implementa\u00e7\u00e3o","text":"<ol> <li>Para grafos esparsos: Dijkstra com fila de prioridade \u00e9 mais eficiente</li> <li>Para grafos densos: Dijkstra simples pode ser competitivo</li> <li>Para verifica\u00e7\u00e3o r\u00e1pida: Bellman-Ford \u00e9 mais vers\u00e1til mas menos eficiente</li> <li>Para aplica\u00e7\u00f5es em tempo real: Dijkstra \u00e9 geralmente preferido</li> </ol>"},{"location":"disciplinas/EDA2/Grafos/grafos/","title":"Grafos","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#1-conceitos-gerais","title":"1. Conceitos Gerais","text":"<p>Um grafo \u00e9 uma estrutura de dados composta por: - V\u00e9rtices (V): Conjunto de n\u00f3s (representados como pontos) - Arestas (E): Conex\u00f5es entre os v\u00e9rtices (representadas como linhas)</p> <p>Princ\u00edpio fundamental: Representar rela\u00e7\u00f5es entre objetos atrav\u00e9s de conex\u00f5es, permitindo modelar problemas complexos de diversas \u00e1reas.</p>"},{"location":"disciplinas/EDA2/Grafos/grafos/#2-tipos-de-grafos","title":"2. Tipos de Grafos","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#21-classificacao-por-direcao","title":"2.1 Classifica\u00e7\u00e3o por Dire\u00e7\u00e3o","text":"<ul> <li>Grafos N\u00e3o-Direcionados: Arestas n\u00e3o t\u00eam dire\u00e7\u00e3o (conex\u00e3o bidirecional)</li> <li>Grafos Direcionados (Digrafos): Arestas t\u00eam dire\u00e7\u00e3o (ex: A \u2192 B)</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#22-classificacao-por-peso","title":"2.2 Classifica\u00e7\u00e3o por Peso","text":"<ul> <li>Grafos N\u00e3o-Ponderados: Arestas sem pesos</li> <li>Grafos Ponderados: Arestas com pesos (custo, dist\u00e2ncia, etc.)</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#23-classificacao-por-conectividade","title":"2.3 Classifica\u00e7\u00e3o por Conectividade","text":"<ul> <li>Grafo Conexo: Existe caminho entre todos os pares de v\u00e9rtices</li> <li>Grafo Desconexo: Possui dois ou mais componentes conexos</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#24-classificacao-por-ciclos","title":"2.4 Classifica\u00e7\u00e3o por Ciclos","text":"<ul> <li>Grafo Ac\u00edclico: N\u00e3o cont\u00e9m ciclos</li> <li>Grafo C\u00edclico: Cont\u00e9m pelo menos um ciclo</li> <li>\u00c1rvore: Grafo conexo e ac\u00edclico</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#25-outras-classificacoes","title":"2.5 Outras Classifica\u00e7\u00f5es","text":"<ul> <li>Grafo Simples: Sem la\u00e7os ou arestas m\u00faltiplas</li> <li>Grafo Completo: Todos os v\u00e9rtices conectados entre si</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#3-estrutura-de-dados","title":"3. Estrutura de Dados","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#31-definicoes-e-macros","title":"3.1 Defini\u00e7\u00f5es e Macros","text":"Defini\u00e7\u00f5es b\u00e1sicas para Grafos:<pre><code>#define MAXV 1000        // N\u00famero m\u00e1ximo de v\u00e9rtices\n#define NULL_EDGE {-1, -1}  // Aresta nula\n\n// Estrutura da aresta\ntypedef struct {\n    int v;        // V\u00e9rtice de origem\n    int w;        // V\u00e9rtice de destino\n    float weight; // Peso (opcional)\n} Edge;\n\n// Macro para criar arestas\n#define EDGE(v, w) {v, w, 1.0}\n#define EDGE_W(v, w, weight) {v, w, weight}\n\n// Macros para compara\u00e7\u00e3o\n#define eq(A, B) ((A.v == B.v &amp;&amp; A.w == B.w) || (A.v == B.w &amp;&amp; A.w == B.v))\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#32-matriz-de-adjacencia","title":"3.2 Matriz de Adjac\u00eancia","text":"Implementa\u00e7\u00e3o com Matriz de Adjac\u00eancia:<pre><code>typedef struct {\n    int V;           // N\u00famero de v\u00e9rtices\n    int E;           // N\u00famero de arestas\n    int **adj;       // Matriz de adjac\u00eancia\n    float **weight;  // Matriz de pesos (opcional)\n} GraphM;\n\n// Inicializa\u00e7\u00e3o\nGraphM* GRAPHinitM(int V) {\n    GraphM *G = malloc(sizeof(GraphM));\n    G-&gt;V = V;\n    G-&gt;E = 0;\n\n    // Aloca matriz de adjac\u00eancia\n    G-&gt;adj = malloc(V * sizeof(int*));\n    for (int i = 0; i &lt; V; i++) {\n        G-&gt;adj[i] = malloc(V * sizeof(int));\n        for (int j = 0; j &lt; V; j++) {\n            G-&gt;adj[i][j] = 0;\n        }\n    }\n\n    return G;\n}\n\n// Inser\u00e7\u00e3o de aresta\nvoid GRAPHinsertM(GraphM *G, Edge e) {\n    if (G-&gt;adj[e.v][e.w] == 0) G-&gt;E++;\n    G-&gt;adj[e.v][e.w] = 1;\n    G-&gt;adj[e.w][e.v] = 1;  // Para grafo n\u00e3o-direcionado\n}\n\n// Remo\u00e7\u00e3o de aresta\nvoid GRAPHremoveM(GraphM *G, Edge e) {\n    if (G-&gt;adj[e.v][e.w] == 1) G-&gt;E--;\n    G-&gt;adj[e.v][e.w] = 0;\n    G-&gt;adj[e.w][e.v] = 0;\n}\n\n// Consulta de aresta\nint GRAPHedgeM(GraphM *G, int v, int w) {\n    return G-&gt;adj[v][w];\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#33-lista-de-adjacencia","title":"3.3 Lista de Adjac\u00eancia","text":"Implementa\u00e7\u00e3o com Lista de Adjac\u00eancia:<pre><code>// Estrutura do n\u00f3 da lista\ntypedef struct node {\n    int w;           // V\u00e9rtice destino\n    float weight;    // Peso da aresta\n    struct node *next;\n} Node;\n\ntypedef struct {\n    int V;           // N\u00famero de v\u00e9rtices\n    int E;           // N\u00famero de arestas\n    Node **adj;      // Vetor de listas de adjac\u00eancia\n} GraphL;\n\n// Inicializa\u00e7\u00e3o\nGraphL* GRAPHinitL(int V) {\n    GraphL *G = malloc(sizeof(GraphL));\n    G-&gt;V = V;\n    G-&gt;E = 0;\n    G-&gt;adj = malloc(V * sizeof(Node*));\n\n    for (int i = 0; i &lt; V; i++) {\n        G-&gt;adj[i] = NULL;\n    }\n\n    return G;\n}\n\n// Cria novo n\u00f3\nNode* NEW(int w, float weight, Node *next) {\n    Node *x = malloc(sizeof(Node));\n    x-&gt;w = w;\n    x-&gt;weight = weight;\n    x-&gt;next = next;\n    return x;\n}\n\n// Inser\u00e7\u00e3o de aresta\nvoid GRAPHinsertL(GraphL *G, Edge e) {\n    G-&gt;adj[e.v] = NEW(e.w, e.weight, G-&gt;adj[e.v]);\n    G-&gt;adj[e.w] = NEW(e.v, e.weight, G-&gt;adj[e.w]);  // N\u00e3o-direcionado\n    G-&gt;E++;\n}\n\n// Remo\u00e7\u00e3o de aresta\nvoid GRAPHremoveL(GraphL *G, Edge e) {\n    // Remove de v para w\n    Node **t = &amp;G-&gt;adj[e.v];\n    while (*t != NULL) {\n        if ((*t)-&gt;w == e.w) {\n            Node *tmp = *t;\n            *t = (*t)-&gt;next;\n            free(tmp);\n            break;\n        }\n        t = &amp;(*t)-&gt;next;\n    }\n\n    // Remove de w para v (n\u00e3o-direcionado)\n    t = &amp;G-&gt;adj[e.w];\n    while (*t != NULL) {\n        if ((*t)-&gt;w == e.v) {\n            Node *tmp = *t;\n            *t = (*t)-&gt;next;\n            free(tmp);\n            G-&gt;E--;\n            break;\n        }\n        t = &amp;(*t)-&gt;next;\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#4-algoritmos-de-busca","title":"4. Algoritmos de Busca","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#41-busca-em-profundidade-dfs","title":"4.1 Busca em Profundidade (DFS)","text":"DFS com Matriz de Adjac\u00eancia:<pre><code>int pre[MAXV];  // Tempo de descoberta\nint cnt;        // Contador\n\nvoid dfsR(GraphM *G, Edge e) {\n    int w = e.w;\n    pre[w] = cnt++;\n\n    for (int t = 0; t &lt; G-&gt;V; t++) {\n        if (G-&gt;adj[w][t] != 0 &amp;&amp; pre[t] == -1) {\n            dfsR(G, EDGE(w, t));\n        }\n    }\n}\n\nvoid GRAPHdfsM(GraphM *G) {\n    cnt = 0;\n    for (int v = 0; v &lt; G-&gt;V; v++) pre[v] = -1;\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        if (pre[v] == -1) {\n            dfsR(G, EDGE(v, v));\n        }\n    }\n}\n</code></pre> DFS com Lista de Adjac\u00eancia:<pre><code>void dfsR(GraphL *G, Edge e) {\n    int w = e.w;\n    pre[w] = cnt++;\n\n    for (Node *t = G-&gt;adj[w]; t != NULL; t = t-&gt;next) {\n        if (pre[t-&gt;w] == -1) {\n            dfsR(G, EDGE(w, t-&gt;w));\n        }\n    }\n}\n\nvoid GRAPHdfsL(GraphL *G) {\n    cnt = 0;\n    for (int v = 0; v &lt; G-&gt;V; v++) pre[v] = -1;\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        if (pre[v] == -1) {\n            dfsR(G, EDGE(v, v));\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#42-busca-em-largura-bfs","title":"4.2 Busca em Largura (BFS)","text":"BFS com Lista de Adjac\u00eancia:<pre><code>// Estrutura de fila\ntypedef struct {\n    Edge *items;\n    int front, rear, size, capacity;\n} Queue;\n\nQueue* QUEUEinit(int capacity) {\n    Queue *Q = malloc(sizeof(Queue));\n    Q-&gt;items = malloc(capacity * sizeof(Edge));\n    Q-&gt;front = 0;\n    Q-&gt;rear = -1;\n    Q-&gt;size = 0;\n    Q-&gt;capacity = capacity;\n    return Q;\n}\n\nvoid bfs(GraphL *G, Edge e) {\n    Queue *Q = QUEUEinit(G-&gt;V);\n    QUEUEput(Q, e);\n    pre[e.w] = cnt++;\n\n    while (Q-&gt;size &gt; 0) {\n        e = QUEUEget(Q);\n        int w = e.w;\n\n        for (Node *t = G-&gt;adj[w]; t != NULL; t = t-&gt;next) {\n            if (pre[t-&gt;w] == -1) {\n                QUEUEput(Q, EDGE(w, t-&gt;w));\n                pre[t-&gt;w] = cnt++;\n            }\n        }\n    }\n\n    free(Q-&gt;items);\n    free(Q);\n}\n\nvoid GRAPHbfsL(GraphL *G) {\n    cnt = 0;\n    for (int v = 0; v &lt; G-&gt;V; v++) pre[v] = -1;\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        if (pre[v] == -1) {\n            bfs(G, EDGE(v, v));\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#5-comparacao-de-implementacoes","title":"5. Compara\u00e7\u00e3o de Implementa\u00e7\u00f5es","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#51-complexidade-das-operacoes","title":"5.1 Complexidade das Opera\u00e7\u00f5es","text":"Opera\u00e7\u00e3o Matriz de Adjac\u00eancia Lista de Adjac\u00eancia Espa\u00e7o O(V\u00b2) O(V + E) Inser\u00e7\u00e3o O(1) O(1) Remo\u00e7\u00e3o O(1) O(grau(v)) Consulta O(1) O(grau(v)) DFS/BFS O(V\u00b2) O(V + E)"},{"location":"disciplinas/EDA2/Grafos/grafos/#52-quando-usar-cada-implementacao","title":"5.2 Quando Usar Cada Implementa\u00e7\u00e3o","text":"<p>Matriz de Adjac\u00eancia: - Grafos densos (E \u2248 V\u00b2) - Consultas frequentes de exist\u00eancia de arestas - Opera\u00e7\u00f5es matriciais - Mem\u00f3ria n\u00e3o \u00e9 limitante</p> <p>Lista de Adjac\u00eancia: - Grafos esparsos (E &lt;&lt; V\u00b2) - Itera\u00e7\u00e3o frequente sobre vizinhos - Grafos que mudam frequentemente - Mem\u00f3ria limitada</p>"},{"location":"disciplinas/EDA2/Grafos/grafos/#53-aplicacoes-praticas","title":"5.3 Aplica\u00e7\u00f5es Pr\u00e1ticas","text":"<p>Matriz de Adjac\u00eancia: - Redes altamente conectadas - Algoritmos de caminho m\u00ednimo (Floyd-Warshall) - Processamento de imagens</p> <p>Lista de Adjac\u00eancia: - Redes sociais - Sistemas de navega\u00e7\u00e3o - Compiladores (grafos de fluxo) - Jogos com mundos abertos</p>"},{"location":"disciplinas/EDA2/Grafos/grafos/#6-exemplo-de-uso","title":"6. Exemplo de Uso","text":"Exemplo completo de uso de grafos:<pre><code>int main() {\n    // Cria grafo com 5 v\u00e9rtices\n    GraphL *G = GRAPHinitL(5);\n\n    // Insere arestas\n    GRAPHinsertL(G, EDGE(0, 1));\n    GRAPHinsertL(G, EDGE(0, 2));\n    GRAPHinsertL(G, EDGE(1, 3));\n    GRAPHinsertL(G, EDGE(2, 4));\n    GRAPHinsertL(G, EDGE(3, 4));\n\n    printf(\"Grafo criado com %d v\u00e9rtices e %d arestas\\n\", G-&gt;V, G-&gt;E);\n\n    // Executa DFS\n    printf(\"Ordem DFS: \");\n    GRAPHdfsL(G);\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        printf(\"%d(%d) \", i, pre[i]);\n    }\n    printf(\"\\n\");\n\n    // Executa BFS\n    printf(\"Ordem BFS: \");\n    GRAPHbfsL(G);\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        printf(\"%d(%d) \", i, pre[i]);\n    }\n    printf(\"\\n\");\n\n    // Remove aresta\n    GRAPHremoveL(G, EDGE(0, 2));\n    printf(\"Ap\u00f3s remo\u00e7\u00e3o: %d arestas\\n\", G-&gt;E);\n\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafos/#7-consideracoes-finais","title":"7. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/Grafos/grafos/#71-vantagens-dos-grafos","title":"7.1 Vantagens dos Grafos","text":"<ul> <li>Modelagem flex\u00edvel: Representam diversos tipos de rela\u00e7\u00f5es</li> <li>Algoritmos eficientes: Muitos problemas bem estudados</li> <li>Escalabilidade: Boa performance com estruturas adequadas</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#72-desafios","title":"7.2 Desafios","text":"<ul> <li>Complexidade de implementa\u00e7\u00e3o: Especialmente para algoritmos avan\u00e7ados</li> <li>Uso de mem\u00f3ria: Pode ser intensivo para grafos grandes</li> <li>Escolha da estrutura: Impacto significativo na performance</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#73-aplicacoes-comuns","title":"7.3 Aplica\u00e7\u00f5es Comuns","text":"<ul> <li>Redes sociais: Amizades, seguidores</li> <li>Sistemas de navega\u00e7\u00e3o: Rotas e mapas</li> <li>Compiladores: An\u00e1lise de c\u00f3digo</li> <li>Bioinform\u00e1tica: Redes de prote\u00ednas</li> <li>Recomenda\u00e7\u00e3o: Sistemas de recomenda\u00e7\u00e3o</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafos/#74-extensoes-comuns","title":"7.4 Extens\u00f5es Comuns","text":"<ul> <li>Grafos ponderados: Arestas com pesos</li> <li>Grafos direcionados: Rela\u00e7\u00f5es assim\u00e9tricas</li> <li>Multigrafos: M\u00faltiplas arestas entre v\u00e9rtices</li> <li>Hipergrafos: Arestas conectando m\u00faltiplos v\u00e9rtices</li> </ul> <p>Os grafos representam uma das estruturas de dados mais vers\u00e1teis e poderosas na ci\u00eancia da computa\u00e7\u00e3o, permitindo a modelagem e solu\u00e7\u00e3o eficiente de problemas complexos em diversas \u00e1reas do conhecimento.</p>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/","title":"Grafos Dirigidos (D\u00edgrafos) e Grafos Ponderados","text":""},{"location":"disciplinas/EDA2/Grafos/grafosDir/#1-grafos-dirigidos-digrafos","title":"1. Grafos Dirigidos (D\u00edgrafos)","text":""},{"location":"disciplinas/EDA2/Grafos/grafosDir/#11-conceitos-basicos","title":"1.1 Conceitos B\u00e1sicos","text":"<p>Um grafo dirigido (d\u00edgrafo) \u00e9 uma estrutura onde: - V\u00e9rtices: Conjunto de n\u00f3s - Arestas direcionadas: Conex\u00f5es com dire\u00e7\u00e3o espec\u00edfica (v \u2192 w)</p> <p>Propriedades fundamentais: - Assimetria: A \u2192 B n\u00e3o implica B \u2192 A - Caminhos direcionais: Sequ\u00eancias de v\u00e9rtices conectados por arestas direcionadas - Alcan\u00e7abilidade: v \u00e9 alcan\u00e7\u00e1vel de u se existe caminho direcionado de u para v</p>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#12-tipos-de-grafos-dirigidos","title":"1.2 Tipos de Grafos Dirigidos","text":"<p>Grafo Dirigido Ac\u00edcilico (DAG): Grafo dirigido sem ciclos. Se vc sair de um v\u00e9rtice, vc n\u00e3o consegue voltar para ele;</p> <p>Grago Dirigido Fortemente Conexo: Quando todos os v\u00e9rtices s\u00e3o alcan\u00e7aveis a partir de todos os v\u00e9rtices;  </p> <p>Grafo conexo: Cada um de seus v\u00e9rtices estpa ao alcanse de cada um dos demais;</p> <p>Grafos n\u00e3o conexo: H\u00e1 mais de um componente conexo;</p>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#12-implementacao-de-digrafos","title":"1.2 Implementa\u00e7\u00e3o de D\u00edgrafos","text":"Estruturas para D\u00edgrafos:<pre><code>#define MAXV 1000\n\n// Estrutura da aresta direcionada\ntypedef struct {\n    int v;        // V\u00e9rtice origem\n    int w;        // V\u00e9rtice destino\n    float weight; // Peso (opcional)\n} Edge;\n\n// D\u00edgrafo com matriz de adjac\u00eancia\ntypedef struct {\n    int V;\n    int E;\n    int **adj;      // Matriz de adjac\u00eancia\n    float **weight; // Matriz de pesos\n} DigraphM;\n\n// D\u00edgrafo com lista de adjac\u00eancia\ntypedef struct node {\n    int w;\n    float weight;\n    struct node *next;\n} Node;\n\ntypedef struct {\n    int V;\n    int E;\n    Node **adj;     // Listas de adjac\u00eancia (apenas arestas de sa\u00edda)\n} DigraphL;\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#13-operacoes-basicas","title":"1.3 Opera\u00e7\u00f5es B\u00e1sicas","text":"Implementa\u00e7\u00e3o de opera\u00e7\u00f5es para d\u00edgrafos:<pre><code>// Inicializa\u00e7\u00e3o de d\u00edgrafo com matriz\nDigraphM* DIGRAPHinitM(int V) {\n    DigraphM *G = malloc(sizeof(DigraphM));\n    G-&gt;V = V;\n    G-&gt;E = 0;\n    G-&gt;adj = malloc(V * sizeof(int*));\n\n    for (int i = 0; i &lt; V; i++) {\n        G-&gt;adj[i] = malloc(V * sizeof(int));\n        for (int j = 0; j &lt; V; j++) {\n            G-&gt;adj[i][j] = 0;\n        }\n    }\n    return G;\n}\n\n// Inser\u00e7\u00e3o de aresta direcionada\nvoid DIGRAPHinsertM(DigraphM *G, Edge e) {\n    if (G-&gt;adj[e.v][e.w] == 0) G-&gt;E++;\n    G-&gt;adj[e.v][e.w] = 1;\n    // N\u00e3o insere a rec\u00edproca (diferente de grafo n\u00e3o-direcionado)\n}\n\n// Invers\u00e3o de d\u00edgrafo\nDigraphM* DIGRAPHreverseM(DigraphM *G) {\n    DigraphM *R = DIGRAPHinitM(G-&gt;V);\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        for (int w = 0; w &lt; G-&gt;V; w++) {\n            if (G-&gt;adj[v][w] == 1) {\n                DIGRAPHinsertM(R, EDGE(w, v)); // Inverte dire\u00e7\u00e3o\n            }\n        }\n    }\n    return R;\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#14-algoritmo-de-floyd-warshall","title":"1.4 Algoritmo de Floyd-Warshall","text":"<p>Usos:</p> <ul> <li>Calcular o fecho transitivo de um grafo G;</li> <li>Encontrar dist\u00e2ncias m\u00ednimas entre todos os pares;</li> <li>Roteamento em redes;</li> </ul> <p>Complexidade: O(V^3);</p> <p>Funcionamento: Copia o grafo G e faz os v\u00e9rtices serem alcan\u00e7aveis a si mesmos;</p> Fecho transitivo com Floyd-Warshall:<pre><code>void DIGRAPHtc(DigraphM *G) {\n    // Aloca matriz do fecho transitivo\n    int **tc = malloc(G-&gt;V * sizeof(int*));\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        tc[i] = malloc(G-&gt;V * sizeof(int));\n        for (int j = 0; j &lt; G-&gt;V; j++) {\n            tc[i][j] = G-&gt;adj[i][j]; // C\u00f3pia inicial\n        }\n    }\n\n    // Todo v\u00e9rtice \u00e9 alcan\u00e7\u00e1vel de si mesmo\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        tc[i][i] = 1;\n    }\n\n    // Algoritmo de Floyd-Warshall\n    for (int k = 0; k &lt; G-&gt;V; k++) {\n        for (int i = 0; i &lt; G-&gt;V; i++) {\n            if (tc[i][k] == 1) {\n                for (int j = 0; j &lt; G-&gt;V; j++) {\n                    if (tc[k][j] == 1) {\n                        tc[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    // Atualiza a matriz do grafo\n    for (int i = 0; i &lt; G-&gt;V; i++) {\n        free(G-&gt;adj[i]);\n    }\n    free(G-&gt;adj);\n    G-&gt;adj = tc;\n}\n\n// Verifica\u00e7\u00e3o de alcan\u00e7abilidade\nint DIGRAPHreach(DigraphM *G, int s, int t) {\n    return G-&gt;adj[s][t];\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#2-ordenacao-topologica","title":"2. Ordena\u00e7\u00e3o Topol\u00f3gica","text":"<p>\u00c9 uma ordena\u00e7\u00e3o linear dos v\u00e9rtices de um DAG tal que para toda aresta u \u2192 v, u aparece antes de v na ordena\u00e7\u00e3o.</p> Implementa\u00e7\u00e3o:<pre><code>static int inT[maxV];\n\nvoid DAGts(Graph G, int ts[]) {\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        inT[v] = 0;\n        ts[v] = -1;\n    }\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        for (link t = G-&gt;adj[v]; t != NULL; t = t-&gt;next) {\n            inT[t-&gt;w]++;\n        }\n    }\n\n    QUEUEinit(G-&gt;V);\n\n    for (int v = 0; v &lt; G-&gt;V; v++) {\n        if (inT[v] == 0) QUEUEput(v);\n    }\n\n    int i = 0, v;\n\n    while (!QUEUEempty()) {\n        ts[i++] = (v = QUEUEget());\n\n        for (link t = G-&gt;adj[v]; t != NULL; t = t-&gt;next) {\n            if (--inT[t-&gt;w] == 0) QUEUEput(t-&gt;w);\n        }\n    }\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#3-grafos-ponderados","title":"3. Grafos Ponderados","text":"<p>\u00c9 aquele em que as arestas possuem pesos, como dist\u00e2ncias entre cidades, custos de rotas ou tempos de viagem. </p> <p>O caminho m\u00ednimo \u00e9 o trajeto entre dois v\u00e9rtices com a menor soma de pesos. </p> <p>Um v\u00e9rtice maduro \u00e9 aquele cujos vizinhos j\u00e1 foram totalmente explorados. </p> <p>Os pesos podem ser representados em:</p> <ul> <li> <p>Matriz de adjac\u00eancia, substituindo 0 e 1 pelos valores das arestas;</p> </li> <li> <p>Lista de adjac\u00eancia, onde cada v\u00e9rtice armazena seus vizinhos e os respectivos pesos;</p> </li> </ul> Implementa\u00e7\u00f5es:<pre><code>// Grafo ponderado com matriz de adjac\u00eancia\ntypedef struct {\n    int V;\n    int E;\n    float **weight; // Matriz de pesos\n} WGraphM;\n\n// Grafo ponderado com lista de adjac\u00eancia\ntypedef struct wnode {\n    int w;\n    float weight;\n    struct wnode *next;\n} WNode;\n\ntypedef struct {\n    int V;\n    int E;\n    WNode **adj;\n} WGraphL;\n\n// Inicializa\u00e7\u00e3o de grafo ponderado\nWGraphM* WGRAPHinitM(int V) {\n    WGraphM *G = malloc(sizeof(WGraphM));\n    G-&gt;V = V;\n    G-&gt;E = 0;\n    G-&gt;weight = malloc(V * sizeof(float*));\n\n    for (int i = 0; i &lt; V; i++) {\n        G-&gt;weight[i] = malloc(V * sizeof(float));\n        for (int j = 0; j &lt; V; j++) {\n            G-&gt;weight[i][j] = INFINITY; // Valor que representa aus\u00eancia de aresta\n        }\n    }\n    return G;\n}\n\n// Inser\u00e7\u00e3o de aresta ponderada\nvoid WGRAPHinsertM(WGraphM *G, Edge e) {\n    if (G-&gt;weight[e.v][e.w] == INFINITY) G-&gt;E++;\n    G-&gt;weight[e.v][e.w] = e.weight;\n    G-&gt;weight[e.w][e.v] = e.weight; // Para grafo n\u00e3o-direcionado\n}\n</code></pre>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#4-consideracoes-finais","title":"4. Considera\u00e7\u00f5es Finais","text":""},{"location":"disciplinas/EDA2/Grafos/grafosDir/#41-aplicacoes-dos-digrafos","title":"4.1 Aplica\u00e7\u00f5es dos D\u00edgrafos","text":"<ul> <li>Sistemas de depend\u00eancia: Compiladores, gerenciadores de pacotes</li> <li>Redes de fluxo: Sistemas de transporte, redes el\u00e9tricas</li> <li>Processos de neg\u00f3cio: Workflows, cadeias de suprimentos</li> <li>Redes sociais: Seguidores, influ\u00eancias</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#42-aplicacoes-dos-grafos-ponderados","title":"4.2 Aplica\u00e7\u00f5es dos Grafos Ponderados","text":"<ul> <li>Sistemas de navega\u00e7\u00e3o: Rotas mais curtas/rapidas</li> <li>Projeto de redes: Conex\u00f5es de custo m\u00ednimo</li> <li>Aloca\u00e7\u00e3o de recursos: Otimiza\u00e7\u00e3o de custos</li> <li>An\u00e1lise de redes: Centralidade, import\u00e2ncia</li> </ul>"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#43-complexidade-dos-algoritmos","title":"4.3 Complexidade dos Algoritmos","text":"Algoritmo Complexidade Aplica\u00e7\u00e3o Floyd-Warshall O(V\u00b3) Fecho transitivo Ordena\u00e7\u00e3o Topol\u00f3gica O(V + E) Ordena\u00e7\u00e3o em DAGs"},{"location":"disciplinas/EDA2/Grafos/grafosDir/#54-escolha-da-estrutura","title":"5.4 Escolha da Estrutura","text":"<p>Matriz de Adjac\u00eancia: - Grafos densos - Consultas frequentes - Opera\u00e7\u00f5es matriciais</p> <p>Lista de Adjac\u00eancia: - Grafos esparsos - Itera\u00e7\u00e3o sobre vizinhos - Mem\u00f3ria limitada</p>"},{"location":"disciplinas/FSO/corrida/","title":"Condi\u00e7\u00f5es de Corrida","text":""},{"location":"disciplinas/FSO/corrida/#1-o-que-e","title":"1. O que \u00e9","text":"<ul> <li>Situa\u00e7\u00e3o em que dois ou mais processos/threads tentam acessar e modificar um recurso compartilhado ao mesmo tempo.</li> <li>O resultado depende da ordem de execu\u00e7\u00e3o dos acessos.</li> <li>Como o escalonador do SO decide a ordem de execu\u00e7\u00e3o e pode ocorrer troca de contexto a qualquer instante, n\u00e3o h\u00e1 garantia de consist\u00eancia.</li> </ul>"},{"location":"disciplinas/FSO/corrida/#2-exemplos-de-condicoes-de-corrida","title":"2. Exemplos de Condi\u00e7\u00f5es de Corrida","text":""},{"location":"disciplinas/FSO/corrida/#21-exemplo-1-incremento-de-variavel","title":"2.1 Exemplo 1 \u2013 Incremento de vari\u00e1vel","text":"<ul> <li>Duas threads incrementam a mesma vari\u00e1vel <code>x</code> (inicialmente 0) at\u00e9 2.</li> <li>Dependendo da ordem de execu\u00e7\u00e3o, o valor final pode estar incorreto.</li> </ul> Exemplo:<pre><code>// Caso 1 - Escalonamento: A \u2192 B\nLOAD R1, x  (x = 0)\nINC R1      (R1 = 1)\nSTORE R1, x (x = 1)\n\nLOAD R1, x  (x = 1)\nINC R1      (R1 = 2)\nSTORE R1, x (x = 2)\n// Valor final: x = 2 \u2705\n\n// Caso 2 \u2013 Escalonamento: A \u2192 B \u2192 A\nLOAD R1, x  (x = 0)\nINC R1      (R1 = 1)\n\nLOAD R1, x  (x = 0)\nINC R1      (R1 = 1)\nSTORE R1, x (x = 1)\n\nSTORE R1, x (x = 1)\n// Valor final: x = 1 \u274c (incremento perdido)\n</code></pre>"},{"location":"disciplinas/FSO/corrida/#22-exemplo-2-servidor-de-impressao","title":"2.2 Exemplo 2 \u2013 Servidor de Impress\u00e3o","text":"Exemplo:<pre><code>// Situa\u00e7\u00e3o\nx = next;\nescreve_pos(arq, x);\nnext = x + 1;\n\n// Possibilidades\nA \u2192 B: tudo ocorre bem \u2192 next = 9\nA \u2192 B \u2192 A: ambos pegam next = 7 \u2192 sobrescrevem, e next = 8 (posi\u00e7\u00e3o repetida!)\n</code></pre>"},{"location":"disciplinas/FSO/corrida/#3-regioes-criticas","title":"3. Regi\u00f5es Cr\u00edticas","text":"<ul> <li> <p>Regi\u00e3o cr\u00edtica: trecho de c\u00f3digo onde h\u00e1 leitura/escrita em recurso compartilhado.</p> </li> <li> <p>No exemplo 1: a opera\u00e7\u00e3o de incremento.</p> </li> <li> <p>No exemplo 2: a escrita na posi\u00e7\u00e3o de impress\u00e3o.</p> </li> <li> <p>Fun\u00e7\u00f5es de controle:</p> </li> <li> <p>Colocadas antes e depois da regi\u00e3o cr\u00edtica.</p> </li> <li>Impedem que dois processos entrem simultaneamente.</li> <li>Garantem exclus\u00e3o m\u00fatua.</li> </ul>"},{"location":"disciplinas/FSO/corrida/#31-variaveis-de-impedimento","title":"3.1 Vari\u00e1veis de Impedimento","text":"<ul> <li>Usadas para indicar se um processo est\u00e1 na regi\u00e3o cr\u00edtica.</li> <li> <p>Exemplo:</p> </li> <li> <p><code>0</code> \u2192 livre</p> </li> <li><code>1</code> \u2192 ocupado</li> </ul>"},{"location":"disciplinas/FSO/corrida/#4-consideracoes-finais","title":"4. Considera\u00e7\u00f5es Finais","text":"<ul> <li>Condi\u00e7\u00f5es de corrida s\u00e3o erros dif\u00edceis de detectar e reproduzir.</li> <li>O controle deve ser feito por sincroniza\u00e7\u00e3o (exclus\u00e3o m\u00fatua, sem\u00e1foros, monitores, locks, etc.).</li> <li>Prevenir condi\u00e7\u00f5es de corrida \u00e9 essencial para garantir consist\u00eancia e integridade dos dados em sistemas concorrentes.</li> </ul>"},{"location":"disciplinas/FSO/escalonamento/","title":"Escalonamento","text":""},{"location":"disciplinas/FSO/escalonamento/#1-quando-ocorre","title":"1. Quando Ocorre","text":"<p>O escalonamento ocorre quando h\u00e1 necessidade de decidir qual processo em estado pronto deve assumir a CPU. Situa\u00e7\u00f5es t\u00edpicas:</p> <ul> <li>Quando um processo termina;</li> <li>Quando um processo \u00e9 bloqueado;</li> <li>Quando um novo processo \u00e9 criado (reavaliar prioridades);</li> <li>Quando ocorrem interrup\u00e7\u00f5es.</li> </ul> <p>O processo em execu\u00e7\u00e3o pode se tornar n\u00e3o apto e outro precisa ser escolhido. Essa decis\u00e3o \u00e9 feita pelo escalonador, que usa um algoritmo de escalonamento.</p>"},{"location":"disciplinas/FSO/escalonamento/#2-classificacao-dos-algoritmos","title":"2. Classifica\u00e7\u00e3o dos Algoritmos","text":"<p>N\u00e3o-preemptivo:</p> <ul> <li>O processo selecionado executa at\u00e9 ser bloqueado ou liberar voluntariamente a CPU.</li> </ul> <p>Preemptivo:</p> <ul> <li>O processo \u00e9 executado por um tempo m\u00e1ximo (quantum). Se n\u00e3o terminar, \u00e9 suspenso e outro assume.</li> <li>Mais equilibrado e usado na maioria dos SO modernos.</li> <li>Dificulta a programa\u00e7\u00e3o de processos concorrentes.</li> </ul>"},{"location":"disciplinas/FSO/escalonamento/#3-criterios-de-escalonamento","title":"3. Crit\u00e9rios de Escalonamento","text":"<ul> <li>Justi\u00e7a: garantir que todos os processos tenham acesso justo \u00e0 CPU.</li> <li>Efici\u00eancia: manter a CPU ocupada sempre que houver trabalho.</li> <li>Tempo de resposta: minimizar o tempo de resposta para usu\u00e1rios interativos.</li> <li>Turnaround: minimizar o tempo total entre o lan\u00e7amento e o t\u00e9rmino do processo.</li> <li>Tempo de espera (waiting line): reduzir o tempo m\u00e9dio na fila de prontos.</li> <li>Throughput: maximizar o n\u00famero de processos conclu\u00eddos por unidade de tempo.</li> </ul>"},{"location":"disciplinas/FSO/escalonamento/#4-algoritmos-classicos","title":"4. Algoritmos Cl\u00e1ssicos","text":""},{"location":"disciplinas/FSO/escalonamento/#41-first-come-first-served-fcfs","title":"4.1 First Come First Served (FCFS)","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Processo executado na ordem de chegada.</li> <li> <p>N\u00e3o-preemptivo.</p> </li> <li> <p>Baseado em fila FIFO.</p> </li> </ul> <p>Vantagens: implementa\u00e7\u00e3o simples, CPU sempre utilizada.</p> <p>Desvantagens: processos longos podem atrasar os demais.</p> <p>Crit\u00e9rios:</p> <ul> <li>Justi\u00e7a: n\u00e3o (um processo pode monopolizar).</li> <li>Efici\u00eancia: sim.</li> <li>Tempo de resposta: ruim em caso de tarefas longas.</li> <li>Turnaround: n\u00e3o necessariamente minimizado.</li> <li>Waiting time: alto para processos curtos.</li> <li>Throughput: baixo se tarefas iniciais forem longas.</li> </ul>"},{"location":"disciplinas/FSO/escalonamento/#42-round-robin-rr","title":"4.2 Round-Robin (RR)","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Cada processo recebe a CPU por um quantum fixo.</li> <li>Altern\u00e2ncia circular entre processos.</li> </ul> <p>Vantagens: justo, adequado para sistemas interativos.</p> <p>Problema: definir quantum ideal.</p> <ul> <li>Quantum longo \u2192 similar a FCFS.</li> <li>Quantum curto \u2192 muitas trocas de contexto, perda de efici\u00eancia.</li> <li>Tempo de troca de contexto deve ser menor que o tempo m\u00e9dio de execu\u00e7\u00e3o.</li> </ul>"},{"location":"disciplinas/FSO/escalonamento/#43-escalonamento-com-prioridades","title":"4.3 Escalonamento com Prioridades","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Cada processo recebe uma prioridade.</li> </ul> <p>Atribui\u00e7\u00e3o de prioridades:</p> <ul> <li>Est\u00e1tica: classes fixas de prioridade.</li> <li> <p>Din\u00e2mica: ajustada pelo sistema conforme comportamento.</p> <ul> <li>Processos de E/S \u2192 alta prioridade.</li> <li>F\u00f3rmula exemplo: prioridade = 1/f, onde f \u00e9 o quantum usado na \u00faltima rodada.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/escalonamento/#44-shortest-job-first-sjf","title":"4.4 Shortest Job First (SJF)","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Executa primeiro o processo com menor tempo de execu\u00e7\u00e3o estimado.</li> <li>Ideal para sistemas em lote.</li> </ul> <p>Vantagem: minimiza turnaround.</p> <p>Desvantagem: dif\u00edcil prever tempo de execu\u00e7\u00e3o real.</p>"},{"location":"disciplinas/FSO/escalonamento/#5-deadlock","title":"5. Deadlock","text":"<p>Deadlock ocorre quando dois ou mais processos ficam bloqueados permanentemente, esperando por recursos que nunca ser\u00e3o liberados.</p> <p>Exemplo:</p> <ul> <li>Processo A tem o recurso 1 e pede o recurso 2.</li> <li>Processo B tem o recurso 2 e pede o recurso 1.</li> </ul> <p>Condi\u00e7\u00f5es necess\u00e1rias para deadlock:</p> <ol> <li>Exclus\u00e3o m\u00fatua: recursos n\u00e3o podem ser compartilhados.</li> <li>Posse e espera (hold and wait): processos mant\u00eam recursos j\u00e1 adquiridos enquanto esperam por novos.</li> <li>N\u00e3o-preemp\u00e7\u00e3o: recursos n\u00e3o podem ser retirados \u00e0 for\u00e7a.</li> <li>Espera circular: cadeia de processos em que cada um espera por recurso do pr\u00f3ximo.</li> </ol>"},{"location":"disciplinas/FSO/escalonamento/#6-consideracoes-finais","title":"6. Considera\u00e7\u00f5es Finais","text":"<ul> <li>O escalonador \u00e9 fundamental para garantir uso eficiente da CPU e atendimento justo aos processos.</li> <li>A escolha do algoritmo depende do ambiente (lote, interativo, tempo real).</li> <li>Deadlocks representam riscos que exigem preven\u00e7\u00e3o, detec\u00e7\u00e3o e recupera\u00e7\u00e3o.</li> </ul>"},{"location":"disciplinas/FSO/gerencia/","title":"Ger\u00eancia de dispositivos de entrada e sa\u00edda","text":""},{"location":"disciplinas/FSO/gerencia/#1-classificacoes-de-dispositivos-de-es","title":"1. Classifica\u00e7\u00f5es de dispositivos de E/S","text":"<p>Bloco:</p> <ul> <li>Armazena informa\u00e7\u00f5es de tamanho fixo;</li> <li>Pode ser lido e escrito independentemente;</li> <li>Ex: HDs, Blu-Rays, Pendrives.</li> </ul> <p>Caracteres:</p> <ul> <li>Envia e aceita um fluxo de caracteres sem estrutura de bloco;</li> <li>N\u00e3o \u00e9 endere\u00e7\u00e1vel, n\u00e3o possui opera\u00e7\u00f5es de busca;</li> <li>Ex: impressoras, mouses, teclados.</li> </ul>"},{"location":"disciplinas/FSO/gerencia/#2-subsistemas-de-es","title":"2. Subsistemas de E/S","text":"<p>Fun\u00e7\u00f5es:</p> <ul> <li>Isolar a complexidade dos dispositivos f\u00edsicos;</li> <li>Realizar buffering;</li> <li>Garantir prote\u00e7\u00e3o de acesso aos dispositivos;</li> <li>Fornecer interface padronizada para inclus\u00e3o de novos drivers ao instalar dispositivos.</li> </ul> <p>Rotinas de E/S:</p> <ul> <li>Conjunto de rotinas para comunica\u00e7\u00e3o com qualquer dispositivo conectado;</li> <li>Usu\u00e1rio n\u00e3o precisa lidar com detalhes da implementa\u00e7\u00e3o;</li> <li>S\u00e3o independentes do dispositivo;</li> <li>Respons\u00e1veis por fun\u00e7\u00f5es comuns a todos dispositivos.</li> </ul> <p>Tipos de chamadas:</p> <ul> <li>Expl\u00edcitas: realizadas diretamente no subsistema de E/S;</li> <li>Impl\u00edcitas: realizadas a partir de outra chamada de sistema de outro m\u00f3dulo do SO;</li> <li>S\u00edncronas: aplica\u00e7\u00e3o espera o t\u00e9rmino, ficando bloqueada;</li> <li>Ass\u00edncronas: aplica\u00e7\u00e3o continua pronta ap\u00f3s a chamada, sendo avisada quando terminar.</li> </ul>"},{"location":"disciplinas/FSO/gerencia/#3-device-drivers","title":"3. Device Drivers","text":"<p>Fun\u00e7\u00f5es:</p> <ul> <li>Fazer a comunica\u00e7\u00e3o entre subsistema e dispositivos (via controladores de E/S);</li> <li>Lidar com particularidades de cada dispositivo;</li> <li>Cada driver manipula um tipo espec\u00edfico de dispositivo (ex: impressora, disco, etc.);</li> <li>Recebem comandos gerais do SO e traduzem para comandos espec\u00edficos;</li> <li>Geralmente s\u00e3o escritos pelo fabricante e fornecidos junto com o dispositivo.</li> </ul>"},{"location":"disciplinas/FSO/gerencia/#4-controladores","title":"4. Controladores","text":"<p>Fun\u00e7\u00e3o:</p> <ul> <li>Manipular diretamente os dispositivos;</li> <li>Receber instru\u00e7\u00f5es da CPU e repassar ao dispositivo;</li> <li>Possuem mem\u00f3ria e registradores pr\u00f3prios.</li> </ul> <p>Tipos de comunica\u00e7\u00e3o entre CPU e dispositivo:</p> <ul> <li> <p>E/S programada:</p> <ul> <li>Uso intenso do processador;</li> <li>Muito tempo desperdi\u00e7ado.</li> <li> <p>E/S por interrup\u00e7\u00e3o:</p> </li> <li> <p>CPU envia ordem e continua trabalhando;</p> </li> <li>Quando o dispositivo termina, interrompe a CPU para avisar.</li> </ul> </li> <li> <p>DMA (Acesso Direto \u00e0 Mem\u00f3ria):</p> <ul> <li>CPU apenas inicia e finaliza;</li> <li>Transfer\u00eancia feita pelo controlador DMA;</li> <li>Dados v\u00e3o direto para RAM sem passar pela CPU;</li> <li>CPU \u00e9 avisada no final com uma interrup\u00e7\u00e3o.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/gerencia/#5-tratadores-de-interrupcao","title":"5. Tratadores de Interrup\u00e7\u00e3o","text":"<p>Uma interrup\u00e7\u00e3o \u00e9 um sinal enviado por um dispositivo pedindo aten\u00e7\u00e3o ao processador.</p> <p>Processo:</p> <ol> <li>Interrup\u00e7\u00e3o acontece;</li> <li>Registradores s\u00e3o salvos numa pilha;</li> <li>O sistema identifica a causa da interrup\u00e7\u00e3o;</li> <li>Executa a rotina de tratamento;</li> <li>Restaura os registradores salvos.</li> </ol>"},{"location":"disciplinas/FSO/gerencia/#6-discos-magneticos-hds","title":"6. Discos Magn\u00e9ticos (HDs)","text":"<p>Estrutura:</p> <ul> <li>Conjunto de discos sobrepostos unidos por um eixo vertical girando a velocidade constante;</li> <li>Discos possuem trilhas, divididas em setores \u2192 formam cilindros;</li> <li>Cabe\u00e7ote: agulha que l\u00ea/grava dados, preso a um bra\u00e7o mec\u00e2nico.</li> </ul> <p>Funcionamento:</p> <ul> <li>Disco gira constantemente;</li> <li>Bra\u00e7o move o cabe\u00e7ote at\u00e9 a trilha correta;</li> <li>Cabe\u00e7ote espera o setor desejado passar;</li> <li>Realiza leitura/escrita.</li> </ul> <p>Tempo de acesso depende de:</p> <ul> <li>Tempo de seek: movimento do bra\u00e7o at\u00e9 a trilha;</li> <li>Tempo rotacional: espera at\u00e9 o setor girar;</li> <li>Tempo de transfer\u00eancia: leitura/escrita de dados do disco para a mem\u00f3ria.</li> </ul>"},{"location":"disciplinas/FSO/gerencia/#7-raid","title":"7. RAID","text":"<p>T\u00e9cnicas para melhorar desempenho e/ou confiabilidade dos discos.</p> <p>Criam um dispositivo virtual (array), conjunto de discos f\u00edsicos tratados como um s\u00f3.</p> <p>RAID 0 (Striping):</p> <ul> <li>Divide o disco em faixas (stripes);</li> <li>Distribui opera\u00e7\u00f5es entre discos;</li> <li>Permite processamento paralelo.</li> </ul> <p>RAID 1 (Espelhamento):</p> <ul> <li>Duplica o conte\u00fado do disco principal;</li> <li>Garante confiabilidade (redund\u00e2ncia).</li> </ul> <p>RAID 5 (Paridade distribu\u00edda):</p> <ul> <li>Distribui dados entre os discos do array;</li> <li>Redund\u00e2ncia baseada em paridade;</li> <li>Permite recupera\u00e7\u00e3o de dados.</li> </ul> <p>RAID 2 e 3:</p> <ul> <li>Trabalham com palavras em vez de faixas.</li> </ul> <p>RAID 4 e 6:</p> <ul> <li>Semelhantes ao RAID 5, com diferen\u00e7as no n\u00edvel de redund\u00e2ncia.</li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/","title":"Ger\u00eancia de Mem\u00f3ria","text":""},{"location":"disciplinas/FSO/gerenciaMem/#1-hierarquia-de-memoria","title":"1. Hierarquia de Mem\u00f3ria","text":"<ul> <li>Registradores: manipulados diretamente pela CPU.</li> <li>Cache: controlada pelo hardware, armazena dados frequentemente acessados.</li> <li>Mem\u00f3ria Principal (RAM): onde os programas s\u00e3o carregados e executados.</li> <li>Mem\u00f3ria Secund\u00e1ria (Disco): armazenamento persistente, abundante e barato, mas com acesso muito mais lento.</li> </ul> <p>Observa\u00e7\u00f5es:</p> <ul> <li>O SO transfere programas da mem\u00f3ria secund\u00e1ria para a mem\u00f3ria principal para execu\u00e7\u00e3o,com o objetivo de:</li> <li>Maximizar o n\u00famero de processos residentes.</li> <li>Compartilhar recursos de forma eficiente.</li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/#2-alocacao-contigua-simples","title":"2. Aloca\u00e7\u00e3o Cont\u00edgua Simples","text":"<ul> <li> <p>Utilizada em sistemas monoprogram\u00e1veis.</p> </li> <li> <p>Mem\u00f3ria principal dividida em duas \u00e1reas:</p> <ul> <li>\u00c1rea do SO.</li> <li>\u00c1rea para programas do usu\u00e1rio.</li> </ul> </li> <li> <p>O programador precisava apenas garantir que n\u00e3o ultrapassaria o espa\u00e7o dispon\u00edvel.</p> </li> <li> <p>Prote\u00e7\u00e3o: um registrador delimita a \u00e1rea do usu\u00e1rio, evitando acesso ao SO.</p> </li> <li> <p>Desvantagens:</p> <ul> <li>Sempre haver\u00e1 algum espa\u00e7o de mem\u00f3ria livre desperdi\u00e7ado.</li> <li>Apenas um usu\u00e1rio/programa pode usar os recursos por vez.</li> </ul> </li> </ul> <p> </p>"},{"location":"disciplinas/FSO/gerenciaMem/#3-tecnica-de-overlay","title":"3. T\u00e9cnica de Overlay","text":"<ul> <li>Programa dividido em m\u00f3dulos.</li> <li>Um m\u00f3dulo comum permanece durante toda a execu\u00e7\u00e3o.</li> <li> <p>Outros m\u00f3dulos s\u00e3o carregados sob demanda em uma \u00e1rea de overlay (mesmo espa\u00e7o de mem\u00f3ria).</p> </li> <li> <p>Vantagem: Permite executar programas maiores do que a mem\u00f3ria dispon\u00edvel.</p> </li> <li> <p>Desvantagem: Exige cuidados extras do programador e dif\u00edcil manuten\u00e7\u00e3o.</p> </li> </ul> <p> </p>"},{"location":"disciplinas/FSO/gerenciaMem/#4-alocacao-particionada","title":"4. Aloca\u00e7\u00e3o Particionada","text":"<p>Permite que diversos programas residam na mem\u00f3ria principal ao mesmo tempo.</p>"},{"location":"disciplinas/FSO/gerenciaMem/#41-alocacao-particionada-estatica","title":"4.1 Aloca\u00e7\u00e3o Particionada Est\u00e1tica","text":"<ul> <li>Mem\u00f3ria dividida em parti\u00e7\u00f5es fixas.</li> <li>Se fosse necess\u00e1rio mudar o tamanho, o sistema precisava ser reiniciado.</li> </ul> <p>1. Absoluta: Programas s\u00f3 podiam ser carregados em uma parti\u00e7\u00e3o espec\u00edfica.</p> <p> </p> <p>2. Reloc\u00e1vel:  c\u00f3digo adaptado para ser carregado em qualquer parti\u00e7\u00e3o.</p> <ul> <li>Usa tabela com endere\u00e7o inicial, tamanho e status (livre/ocupada).</li> <li>Prote\u00e7\u00e3o com dois registradores (limite inferior e superior).</li> </ul> <p> </p>"},{"location":"disciplinas/FSO/gerenciaMem/#42-alocacao-particionada-dinamica","title":"4.2 Aloca\u00e7\u00e3o Particionada Din\u00e2mica","text":"<ul> <li>Parti\u00e7\u00f5es criadas sob demanda, conforme o tamanho dos programas.</li> <li> <p>Problema: fragmenta\u00e7\u00e3o externa.</p> </li> <li> <p>Espa\u00e7os livres espalhados pela mem\u00f3ria.</p> </li> <li> <p>Solu\u00e7\u00f5es:</p> <ol> <li>Combinar espa\u00e7os adjacentes quando liberados.</li> <li>Relocar programas, compactando a mem\u00f3ria.</li> </ol> </li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/#43-estrategias-de-alocacao","title":"4.3 Estrat\u00e9gias de Aloca\u00e7\u00e3o","text":"<p>Best-fit: </p> <ul> <li>Escolhe a menor parti\u00e7\u00e3o poss\u00edvel.</li> <li>Desvantagem: tende a gerar muitas \u00e1reas pequenas.</li> </ul> <p>Worst-fit: </p> <ul> <li>Escolhe a maior parti\u00e7\u00e3o.</li> <li>Vantagem: mant\u00e9m \u00e1reas livres maiores.</li> </ul> <p>First-fit: </p> <ul> <li>Escolhe a primeira parti\u00e7\u00e3o suficiente.</li> <li>Mais r\u00e1pida, mas pode deixar grandes fragmentos no fim da mem\u00f3ria.</li> </ul> <p> </p>"},{"location":"disciplinas/FSO/gerenciaMem/#5-swapping","title":"5. Swapping","text":"<ul> <li>T\u00e9cnica para contornar a insufici\u00eancia de mem\u00f3ria.</li> <li>Antes: um processo permanecia na mem\u00f3ria at\u00e9 terminar.</li> <li>Com swapping: um processo pode ser temporariamente movido para o disco (mem\u00f3ria secund\u00e1ria) e substitu\u00eddo por outro.</li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/#51-caracteristicas","title":"5.1 Caracter\u00edsticas","text":"<ul> <li>Escolha de processos para swap prioriza aqueles menos prov\u00e1veis de serem escalonados.</li> <li>Loader com registrador de reloca\u00e7\u00e3o garante retomada correta.</li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/#52-problemas","title":"5.2 Problemas","text":"<ul> <li>Alto custo de opera\u00e7\u00f5es de entrada/sa\u00edda.</li> <li>Thrashing: ocorre quando o sistema passa mais tempo trocando processos entre RAM e disco do que executando instru\u00e7\u00f5es.</li> </ul>"},{"location":"disciplinas/FSO/gerenciaMem/#6-consideracoes-finais","title":"6. Considera\u00e7\u00f5es Finais","text":"<ul> <li>A ger\u00eancia de mem\u00f3ria busca equilibrar uso eficiente da RAM, velocidade de acesso e compartilhamento entre processos.</li> <li>As t\u00e9cnicas evolu\u00edram de modelos simples (monoprograma\u00e7\u00e3o) at\u00e9 sistemas mais complexos (multiprograma\u00e7\u00e3o com swapping e estrat\u00e9gias avan\u00e7adas).</li> </ul>"},{"location":"disciplinas/FSO/introFSO/","title":"Fundamentos de Sistemas Operacionais (FSO)","text":""},{"location":"disciplinas/FSO/introFSO/#1-conceitos-basicos","title":"1. Conceitos B\u00e1sicos","text":"<p>Um computador \u00e9 formado por duas partes principais:</p> <ul> <li>Hardware (parte f\u00edsica)</li> <li>Software (programas e instru\u00e7\u00f5es)</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#11-definicao","title":"1.1 Defini\u00e7\u00e3o","text":"<p>Tanenbaum: Sistema Operacional (SO) \u00e9 a parte fundamental do software que executa em modo protegido, com acesso total ao hardware e capacidade de executar qualquer instru\u00e7\u00e3o da m\u00e1quina.</p> <ul> <li>Exemplo: apenas o SO tem acesso direto ao disco, mem\u00f3ria e dispositivos. Aplicativos precisam solicitar esse acesso ao SO.</li> </ul> <p>Machado e Maia: O SO \u00e9 uma aplica\u00e7\u00e3o capaz de executar de forma ass\u00edncrona, em vez de linear.</p> <ul> <li>Exemplo: podemos ouvir m\u00fasica, baixar arquivos e usar antiv\u00edrus ao mesmo tempo; se fosse s\u00edncrono, s\u00f3 rodaria uma tarefa por vez.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#12-funcoes","title":"1.2 Fun\u00e7\u00f5es","text":"<p>Abstra\u00e7\u00e3o do hardware (m\u00e1quina estendida / m\u00e1quina abstrata):</p> <ul> <li>O SO atua como interface entre usu\u00e1rio e computador.</li> <li>Inicialmente, programadores precisavam conhecer linguagem de m\u00e1quina e hardware em detalhes.</li> <li>Atualmente, o SO esconde a complexidade, simplificando e tornando o uso mais seguro.</li> </ul> <p>Compartilhamento de recursos:</p> <p>O SO gerencia recursos f\u00edsicos (CPU, mem\u00f3ria, disco, dispositivos) e l\u00f3gicos de forma organizada e protegida. - Exemplo multiusu\u00e1rio: o SO organiza impress\u00f5es de v\u00e1rios usu\u00e1rios em uma mesma impressora. - Exemplo monousu\u00e1rio: em um laptop, o SO organiza m\u00faltiplas tarefas simultaneamente.</p> <p>Responsabilidades do SO:</p> <ul> <li>Gerenciar dispositivos (HD, mem\u00f3ria, CPU, perif\u00e9ricos);</li> <li>Controlar opera\u00e7\u00f5es de leitura/escrita;</li> <li>Transferir dados entre hardware e mem\u00f3ria;</li> <li>Informar programas sobre conclus\u00f5es de opera\u00e7\u00f5es;</li> <li>Definir quem pode acessar quais recursos.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#3-classificacao-dos-sistemas-operacionais","title":"3. Classifica\u00e7\u00e3o dos Sistemas Operacionais","text":""},{"location":"disciplinas/FSO/introFSO/#31-monoprogramaveis-monotarefa","title":"3.1 Monoprogram\u00e1veis / Monotarefa","text":"<ul> <li>Primeiros a surgir.</li> <li>Executam apenas uma aplica\u00e7\u00e3o por vez.</li> <li>Todos os recursos s\u00e3o dedicados a uma \u00fanica tarefa.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#32-multiprogramaveis","title":"3.2 Multiprogram\u00e1veis","text":"<ul> <li>Permitem que m\u00faltiplos programas compartilhem recursos.</li> <li>Enquanto um programa espera por E/S, outro pode usar o processador.</li> <li>Implementa\u00e7\u00e3o mais complexa.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#321-classificacao-por-numero-de-usuarios","title":"3.2.1 Classifica\u00e7\u00e3o por n\u00famero de usu\u00e1rios:","text":"<ul> <li>Monousu\u00e1rio</li> <li>Multiusu\u00e1rio</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#322-classificacao-pela-forma-de-gerenciamento","title":"3.2.2 Classifica\u00e7\u00e3o pela forma de gerenciamento:","text":"<p>Batch (em lote):</p> <ul> <li>Programas armazenados e processados em lotes, sem intera\u00e7\u00e3o do usu\u00e1rio.</li> <li>Exemplo: gera\u00e7\u00e3o de boletos de clientes.</li> </ul> <p>Tempo compartilhado:</p> <ul> <li>Divis\u00e3o do tempo do processador em fatias (time-slice).</li> <li>Usu\u00e1rios interagem diretamente com o SO.</li> <li>Altern\u00e2ncia r\u00e1pida \u2192 apar\u00eancia de simultaneidade.</li> <li>Exemplo: celular executando v\u00e1rios aplicativos.</li> </ul> <p>Tempo real:</p> <ul> <li>Cumprimento r\u00edgido de prazos temporais.</li> <li>Pontualidade &gt; desempenho.</li> <li>Exemplo: controle de tr\u00e1fego a\u00e9reo, airbags, ind\u00fastria automobil\u00edstica.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#33-sistemas-com-multiplos-processadores","title":"3.3 Sistemas com M\u00faltiplos Processadores","text":"<ul> <li>Dois ou mais processadores trabalhando em conjunto.</li> <li>V\u00e1rios programas executados em paralelo.</li> <li>Maior desempenho, escalabilidade e disponibilidade.</li> </ul> <p>Tipos:</p> <ul> <li>Fortemente acoplados: mem\u00f3ria compartilhada.</li> <li>Fracamente acoplados: mem\u00f3rias independentes.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#4-sistemas-operacionais-usuais","title":"4. Sistemas Operacionais Usuais","text":""},{"location":"disciplinas/FSO/introFSO/#41-computadores-pessoais","title":"4.1 Computadores Pessoais","text":"<ul> <li>Desktop, notebooks.</li> <li>Exemplo: Windows 10, Ubuntu, Fedora.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#42-servidores","title":"4.2 Servidores","text":"<ul> <li>Objetivo: atender v\u00e1rios usu\u00e1rios simultaneamente.</li> <li>Servi\u00e7os: web, e-mail, autentica\u00e7\u00e3o.</li> <li>Exemplo: Windows Server 2008, CentOS, Red Hat.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#43-embarcados","title":"4.3 Embarcados","text":"<ul> <li>Equipamentos que n\u00e3o aparentam ser computadores.</li> <li>Exemplo: Android, iOS, sistemas embarcados de TVs, micro-ondas, carros.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#5-estrutura-dos-sistemas-operacionais","title":"5. Estrutura dos Sistemas Operacionais","text":""},{"location":"disciplinas/FSO/introFSO/#51-basico","title":"5.1 B\u00e1sico","text":"<ul> <li>O n\u00facleo (kernel) \u00e9 respons\u00e1vel por oferecer servi\u00e7os essenciais.</li> <li> <p>Comunica\u00e7\u00e3o com o n\u00facleo:</p> </li> <li> <p>Chamadas de sistema (system calls): exemplo, criar/escrever arquivos.</p> </li> <li>Utilit\u00e1rios: interfaces gr\u00e1ficas (gerenciador de arquivos, tarefas).</li> <li>Linguagem de comando: terminal (prompt de comando, shell).</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#52-funcoes-do-nucleo","title":"5.2 Fun\u00e7\u00f5es do N\u00facleo","text":"<ul> <li>Tratamento de interrup\u00e7\u00f5es e exce\u00e7\u00f5es.</li> <li>Cria\u00e7\u00e3o e elimina\u00e7\u00e3o de processos e threads.</li> <li>Comunica\u00e7\u00e3o e sincroniza\u00e7\u00e3o entre processos.</li> <li>Escalonamento de tarefas.</li> <li>Ger\u00eancia de mem\u00f3ria e arquivos.</li> <li>Controle de dispositivos de E/S.</li> <li>Suporte a redes locais e distribu\u00eddas.</li> <li>Contabiliza\u00e7\u00e3o e auditoria de recursos.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#53-modo-de-acesso","title":"5.3 Modo de Acesso","text":"<ul> <li>Modo Usu\u00e1rio: execu\u00e7\u00e3o de instru\u00e7\u00f5es n\u00e3o privilegiadas.</li> <li>Modo Kernel: acesso total \u00e0s instru\u00e7\u00f5es e recursos.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#54-system-calls","title":"5.4 System Calls","text":"<ul> <li>Permitem que aplica\u00e7\u00f5es solicitem servi\u00e7os privilegiados do SO.</li> <li>Executadas em modo kernel.</li> <li>O processador alterna entre modo usu\u00e1rio \u2194 modo kernel durante chamadas.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#55-arquiteturas-do-nucleo","title":"5.5 Arquiteturas do N\u00facleo","text":""},{"location":"disciplinas/FSO/introFSO/#551-monoliticos","title":"5.5.1 Monol\u00edticos","text":"<ul> <li>N\u00facleo \u00fanico formado por m\u00f3dulos compilados em um \u00fanico programa.</li> <li>Apenas o SO roda em modo protegido.</li> <li>Vantagem: melhor tempo de resposta.</li> <li>Desvantagem: dif\u00edcil manuten\u00e7\u00e3o.</li> <li>Exemplo: Linux.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#552-em-camadas","title":"5.5.2 Em Camadas","text":"<ul> <li>Dividido em camadas sobrepostas.</li> <li>Cada camada acessa apenas a imediatamente inferior.</li> <li>Vantagens: isolamento, prote\u00e7\u00e3o.</li> <li>Desvantagens: menor desempenho, mais trocas de modo.</li> <li>Exemplos: THE, MULTICS.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#553-maquinas-virtuais","title":"5.5.3 M\u00e1quinas Virtuais","text":"<ul> <li>Camada intermedi\u00e1ria que cria m\u00e1quinas virtuais independentes.</li> <li>Cada VM possui c\u00f3pia virtual configur\u00e1vel do hardware.</li> <li>Vantagens: isolamento, consolida\u00e7\u00e3o de servidores, testes.</li> <li>Exemplo: VMware ESX, VirtualBox.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#554-microkernel","title":"5.5.4 Microkernel","text":"<ul> <li>Modelo cliente-servidor.</li> <li>N\u00facleo m\u00ednimo: gerencia processos, mem\u00f3ria b\u00e1sica, IPC e interrup\u00e7\u00f5es.</li> <li>Servi\u00e7os do SO implementados em n\u00edvel usu\u00e1rio.</li> <li>Vantagens: estabilidade, seguran\u00e7a.</li> <li>Desvantagens: implementa\u00e7\u00e3o complexa, menor desempenho.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#555-exokernel","title":"5.5.5 Exokernel","text":"<ul> <li>N\u00facleo m\u00ednimo que apenas gerencia recursos b\u00e1sicos (CPU, mem\u00f3ria, disco).</li> <li>Aplica\u00e7\u00f5es acessam diretamente o hardware.</li> <li>Vantagens: alta performance, customiza\u00e7\u00e3o.</li> <li>Desvantagens: complexidade de uso.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#556-conteineres","title":"5.5.6 Cont\u00eaineres","text":"<ul> <li>Alternativa \u00e0s m\u00e1quinas virtuais.</li> <li>N\u00e3o emulam hardware nem rodam um SO completo.</li> <li>Compartilham o mesmo kernel, mas t\u00eam bibliotecas isoladas.</li> <li>Exemplo: Docker.</li> </ul>"},{"location":"disciplinas/FSO/introFSO/#6-consideracoes-finais","title":"6. Considera\u00e7\u00f5es Finais","text":"<ul> <li>O Sistema Operacional \u00e9 essencial para abstrair, organizar e proteger recursos.</li> <li>Diferentes arquiteturas e classifica\u00e7\u00f5es atendem a necessidades distintas (tempo real, multiprograma\u00e7\u00e3o, servidores, embarcados).</li> <li>Evolu\u00e7\u00f5es recentes como m\u00e1quinas virtuais e cont\u00eaineres expandem seu papel para ambientes de nuvem e escalabilidade.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/","title":"Mem\u00f3ria Virtual","text":""},{"location":"disciplinas/FSO/memoriaVirtual/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Problema das parti\u00e7\u00f5es vari\u00e1veis:</p> <ul> <li>Fragmenta\u00e7\u00e3o externa constante, necessitando de interven\u00e7\u00e3o do SO.</li> <li>Solu\u00e7\u00e3o: mem\u00f3ria virtual.</li> </ul> <p>Caracter\u00edsticas da Mem\u00f3ria Virtual</p> <ul> <li>Presente em sistemas operacionais modernos.</li> <li>Funciona como um overlay, mas implementado pelo SO (n\u00e3o pelo programador).</li> <li> <p>Combina Mem\u00f3ria Secund\u00e1ria (MS) e Mem\u00f3ria Principal (MP):</p> <ul> <li>A mem\u00f3ria secund\u00e1ria \u00e9 usada como extens\u00e3o da mem\u00f3ria principal.</li> <li>Quando o programa \u00e9 executado, apenas uma parte dele permanece na mem\u00f3ria principal.</li> <li>D\u00e1 a ilus\u00e3o de existir uma mem\u00f3ria muito maior.</li> <li> <p>Os processos referenciam endere\u00e7os virtuais, n\u00e3o f\u00edsicos.</p> </li> <li> <p>O programador n\u00e3o precisa se preocupar com os endere\u00e7os f\u00edsicos.</p> </li> <li> <p>Respons\u00e1veis pelo mapeamento:</p> <ul> <li>Compilador: cria instru\u00e7\u00f5es com endere\u00e7os virtuais.</li> <li>SO: traduz os endere\u00e7os virtuais para endere\u00e7os reais.</li> </ul> </li> </ul> </li> </ul> <p>Exemplo:</p> <p>Em m\u00e1quinas de 32 bits, o processo pode referenciar 2^{32}-1 endere\u00e7os virtuais, independentemente do tamanho da mem\u00f3ria f\u00edsica.</p> <p>Vantagens:</p> <ul> <li>Maior n\u00famero de processos residentes na mem\u00f3ria principal.</li> <li>Uso mais eficiente do processador.</li> <li>Minimiza problemas de fragmenta\u00e7\u00e3o da mem\u00f3ria principal.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#2-implementacao","title":"2. Implementa\u00e7\u00e3o","text":"<ul> <li>Implementada diretamente no hardware.</li> <li>Depende da arquitetura do processador.</li> <li>Desvantagem: requer mecanismos de tradu\u00e7\u00e3o de endere\u00e7os virtuais para f\u00edsicos.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#3-mapeamento-de-enderecos","title":"3. Mapeamento de Endere\u00e7os","text":"<p>O processador s\u00f3 executa instru\u00e7\u00f5es em endere\u00e7os reais.</p> <p>MMU (Memory Management Unit)</p> <ul> <li>Traduz endere\u00e7os virtuais para f\u00edsicos.</li> <li>Atua sempre que um endere\u00e7o virtual \u00e9 referenciado.</li> <li>Localizada no hardware.</li> </ul> <p>Tabela de mapeamento (uma por processo)</p> <ul> <li>Cont\u00e9m rela\u00e7\u00e3o entre endere\u00e7os virtuais e reais.</li> <li>Alterada a cada troca de contexto.</li> </ul> <p>Registrador de base</p> <ul> <li>Aponta para a tabela do processo corrente.</li> <li> <p>Tabela dividida em blocos:</p> </li> <li> <p>Facilita o gerenciamento de processos com endere\u00e7os virtuais grandes.</p> </li> <li>Quanto maior o bloco, menor o n\u00famero de entradas na tabela.</li> </ul> <p>TLB (Translation Lookaside Buffer)</p> <ul> <li>Cache da MMU para endere\u00e7os virtuais.</li> <li>Se o endere\u00e7o n\u00e3o estiver na TLB, acessa a mem\u00f3ria.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#4-paginacao","title":"4. Pagina\u00e7\u00e3o","text":"<p>Pagina\u00e7\u00e3o: divis\u00e3o do espa\u00e7o de endere\u00e7amento em blocos de tamanho fixo.</p> <p>P\u00e1ginas virtuais: na mem\u00f3ria virtual.</p> <p>Frames (ou p\u00e1ginas reais): na mem\u00f3ria principal.</p> <p>Tabela de P\u00e1ginas (ETP):</p> <ul> <li>Cada processo possui uma.</li> <li>Cada p\u00e1gina virtual tem uma entrada.</li> <li>NPV (N\u00famero da P\u00e1gina Virtual): \u00edndice para localiza\u00e7\u00e3o.</li> </ul> <p>Execu\u00e7\u00e3o de um programa:</p> <ul> <li>P\u00e1ginas virtuais s\u00e3o transferidas da MS para MP quando necess\u00e1rio.</li> <li>Endere\u00e7o f\u00edsico obtido a partir do frame e deslocamento na p\u00e1gina.</li> </ul> <p> </p>"},{"location":"disciplinas/FSO/memoriaVirtual/#41-bit-de-validade","title":"4.1 Bit de Validade","text":"<ul> <li>Indica se a p\u00e1gina est\u00e1 na mem\u00f3ria principal.</li> <li> <p>Se n\u00e3o estiver, ocorre page fault:</p> </li> <li> <p>O processo passa de execu\u00e7\u00e3o para espera.</p> </li> <li>O SO transfere a p\u00e1gina da MS para MP (page in).</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#42-taxa-de-paginacao","title":"4.2 Taxa de Pagina\u00e7\u00e3o","text":"<ul> <li>N\u00famero de page faults gerados por processo em um intervalo de tempo.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#43-politicas-de-busca-de-paginas","title":"4.3 Pol\u00edticas de Busca de P\u00e1ginas","text":"<ol> <li>Por demanda: carrega a p\u00e1gina apenas quando referenciada.</li> <li>Antecipada (pre-paging): carrega p\u00e1ginas adjacentes que podem ser usadas.</li> </ol>"},{"location":"disciplinas/FSO/memoriaVirtual/#44-praticas-de-alocacao-de-paginas","title":"4.4 Pr\u00e1ticas de Aloca\u00e7\u00e3o de P\u00e1ginas","text":"<p>Aloca\u00e7\u00e3o fixa: n\u00famero fixo de frames por processo.</p> <p>Aloca\u00e7\u00e3o vari\u00e1vel: n\u00famero de frames pode mudar conforme a taxa de page faults.</p>"},{"location":"disciplinas/FSO/memoriaVirtual/#45-politicas-de-substituicao-de-paginas","title":"4.5 Pol\u00edticas de Substitui\u00e7\u00e3o de P\u00e1ginas","text":"<p>Page out:</p> <ul> <li>Libera p\u00e1ginas quando atingido o limite de frames.</li> <li>Verifica se a p\u00e1gina foi modificada antes de salvar.</li> </ul> <p>Page file: </p> <ul> <li>Arquivo onde p\u00e1ginas modificadas s\u00e3o armazenadas.</li> </ul> <p>Tipos:</p> <ul> <li>Local: apenas p\u00e1ginas do processo que gerou o page fault.</li> <li>Global: qualquer p\u00e1gina da mem\u00f3ria principal.</li> </ul> <p>Working set: </p> <ul> <li> <p>Conjunto de p\u00e1ginas referenciadas recentemente pelo processo.</p> </li> <li> <p>Leva em conta localidade espacial e temporal.</p> </li> </ul> <p>Algoritmos de substitui\u00e7\u00e3o:</p> <ul> <li>\u00d3timo:baseado em previs\u00e3o futura (te\u00f3rico).</li> <li>Aleat\u00f3rio: escolhe qualquer p\u00e1gina.</li> <li>FIFO: remove a p\u00e1gina mais antiga.</li> <li>LFU: remove a menos referenciada.</li> <li>LRU: remove a menos recentemente usada.</li> <li>NRU:utiliza bit de refer\u00eancia.</li> <li>Clock: varia\u00e7\u00e3o do FIFO com bit de uso.</li> </ul>"},{"location":"disciplinas/FSO/memoriaVirtual/#46-tamanho-de-paginas","title":"4.6 Tamanho de P\u00e1ginas","text":"<p>P\u00e1ginas pequenas: resultam em tabelas maiores, mais page faults, mas melhor uso da MP.</p> <p>P\u00e1ginas grandes: resulam em tabelas menores e maior fragmenta\u00e7\u00e3o interna.</p> <p>Pagina\u00e7\u00e3o em m\u00faltiplos n\u00edveis: evita tabelas gigantes, organiza em camadas.</p>"},{"location":"disciplinas/FSO/memoriaVirtual/#5-protecao-de-memoria","title":"5. Prote\u00e7\u00e3o de Mem\u00f3ria","text":"<p>Impede que programas alterem p\u00e1ginas n\u00e3o autorizadas e usa bits de permiss\u00e3o na tabela de p\u00e1ginas:</p> <ul> <li>00: sem acesso.</li> <li>10: leitura.</li> <li>11: leitura e grava\u00e7\u00e3o.</li> </ul> <p>Segmenta\u00e7\u00e3o: Divide mem\u00f3ria em segmentos l\u00f3gicos e facilita modularidade e organiza\u00e7\u00e3o.</p> <p>Segmenta\u00e7\u00e3o com Pagina\u00e7\u00e3o: Grandes segmentos divididos em p\u00e1ginas para melhor gerenciamento.</p> <p> </p>"},{"location":"disciplinas/FSO/processos/","title":"Processos","text":""},{"location":"disciplinas/FSO/processos/#1-modelo-de-processo","title":"1. Modelo de Processo","text":"<p>Um processo pode ser visto em duas dimens\u00f5es:</p> <ul> <li>Ambiente: espa\u00e7o de endere\u00e7amento + contexto de software.</li> <li>Execu\u00e7\u00e3o: contexto de hardware.</li> </ul> <p>Tipos de modelos de processos:</p> <ul> <li>Heavyweight: processo tradicional.</li> <li>Lightweight: threads (processos leves).</li> </ul>"},{"location":"disciplinas/FSO/processos/#2-o-que-e-um-processo","title":"2. O que \u00e9 um Processo","text":"<p>Em sistemas multiprogram\u00e1veis, existe um pseudoparalelismo: ilus\u00e3o de que v\u00e1rios programas rodam ao mesmo tempo.</p> <p>Cada processo possui sua pr\u00f3pria \"CPU virtual\", mas, na pr\u00e1tica, a CPU alterna entre processos rapidamente.</p> <p>Ao longo do tempo, todos progridem, mas em um instante dado apenas um executa.</p> <p>Analogia do bolo:</p> <ul> <li>Confeiteiro \u2192 CPU.</li> <li>Receita do bolo \u2192 Programa (passivo).</li> <li>Fazer o bolo \u2192 Processo (ativo).</li> <li>Ingredientes \u2192 Dados de entrada.</li> <li>Bolo pronto \u2192 Dados de sa\u00edda.</li> <li>Se surgir outra tarefa priorit\u00e1ria (ex: socorrer crian\u00e7a), o confeiteiro interrompe o bolo, memoriza o ponto, faz a nova tarefa, e depois retorna.</li> </ul> <p>Conceito: processo \u00e9 um programa em execu\u00e7\u00e3o junto com seu contexto:</p> <ul> <li>Pilha de execu\u00e7\u00e3o.</li> <li>Apontador para a pilha.</li> <li>Contador de programa (pr\u00f3xima instru\u00e7\u00e3o).</li> <li>Valores dos registradores.</li> </ul>"},{"location":"disciplinas/FSO/processos/#3-criacao-de-um-processo","title":"3. Cria\u00e7\u00e3o de um Processo","text":"<p>Um processo pode ser criado em situa\u00e7\u00f5es como:</p> <ul> <li> <p>Inicializa\u00e7\u00e3o do sistema:</p> </li> <li> <p>Foreground: processos que interagem com o usu\u00e1rio.</p> </li> <li>Background: processos sem intera\u00e7\u00e3o direta (daemons, servi\u00e7os).</li> <li>Chamada de sistema feita por outro processo.</li> <li>Solicita\u00e7\u00e3o do usu\u00e1rio.</li> <li>Execu\u00e7\u00e3o de tarefas em lote.</li> </ul>"},{"location":"disciplinas/FSO/processos/#4-termino-de-processos","title":"4. T\u00e9rmino de Processos","text":"<ul> <li>Normal (volunt\u00e1rio): terminou sua tarefa ou o usu\u00e1rio encerrou.</li> <li>Erro (volunt\u00e1rio): t\u00e9rmino por falha detectada.</li> <li>Erro fatal (involunt\u00e1rio): t\u00e9rmino for\u00e7ado por falha grave.</li> <li>Eliminado por outro processo (involunt\u00e1rio).</li> </ul>"},{"location":"disciplinas/FSO/processos/#5-hierarquia-de-processos","title":"5. Hierarquia de Processos","text":"<ul> <li>Processos criados por outros mant\u00eam rela\u00e7\u00e3o de pai-filho.</li> <li>Em sistemas Unix/Linux, todos descendem do processo <code>init</code>.</li> <li>Windows n\u00e3o possui a mesma hierarquia expl\u00edcita.</li> </ul>"},{"location":"disciplinas/FSO/processos/#6-estados-de-processos","title":"6. Estados de Processos","text":"<p>Processos interagem, comunicam-se e sincronizam-se. Seus estados podem ser:</p> <ul> <li>Executando: em uso da CPU.</li> <li>Pronto: apto a executar, aguardando a vez.</li> <li> <p>Bloqueado: aguardando evento externo.</p> </li> <li> <p>Exemplo: leitura em disco, entrada de usu\u00e1rio, depend\u00eancia de outro processo.</p> </li> </ul> <p>Transi\u00e7\u00f5es t\u00edpicas:</p> <ol> <li>Executando \u2192 Bloqueado (aguarda evento).</li> <li>Executando \u2192 Pronto (usou tempo m\u00e1ximo).</li> <li>Pronto \u2192 Executando (escalonado).</li> <li>Bloqueado \u2192 Pronto (evento chegou).</li> </ol> <p>Classifica\u00e7\u00e3o Bound:</p> <ul> <li>CPU-bound: usam mais tempo de CPU.</li> <li>I/O-bound: ficam mais tempo bloqueados esperando E/S.</li> </ul>"},{"location":"disciplinas/FSO/processos/#7-implementacao-de-processos","title":"7. Implementa\u00e7\u00e3o de Processos","text":""},{"location":"disciplinas/FSO/processos/#71-tabela-de-processos","title":"7.1 Tabela de Processos","text":"<ul> <li>Cont\u00e9m informa\u00e7\u00f5es essenciais sobre cada processo.</li> <li>Cada processo tem um identificador (PID).</li> <li>Campos incluem gerenciamento de mem\u00f3ria, arquivos abertos, registradores.</li> <li> <p>Troca de contexto:</p> </li> <li> <p>Salva os registradores e o estado do processo.</p> </li> <li>Carrega o estado de outro processo.</li> <li>Permite retomar a execu\u00e7\u00e3o como se n\u00e3o tivesse sido interrompido.</li> </ul>"},{"location":"disciplinas/FSO/processos/#72-tabela-de-descritores-de-interrupcao-idt","title":"7.2 Tabela de Descritores de Interrup\u00e7\u00e3o (IDT)","text":"<ul> <li>Tabela usada pelo processador para tratar interrup\u00e7\u00f5es.</li> <li>O vetor de interrup\u00e7\u00e3o \u00e9 o \u00edndice da entrada na IDT.</li> <li>Cada dispositivo tem uma entrada associada.</li> </ul> <p>Passo a passo de uma interrup\u00e7\u00e3o de disco:</p> <ol> <li>Processo de usu\u00e1rio est\u00e1 em execu\u00e7\u00e3o.</li> <li>Disco gera interrup\u00e7\u00e3o (opera\u00e7\u00e3o conclu\u00edda).</li> <li>CPU salva automaticamente o estado do processo (contadores, registradores).</li> <li>Processador consulta a IDT com o vetor de interrup\u00e7\u00e3o.</li> <li>Carrega a rotina de tratamento correspondente (assembly).</li> <li>Rotina de tratamento processa a interrup\u00e7\u00e3o (ex: l\u00ea dados do disco, desbloqueia processos).</li> <li>Escalonador decide se o processo interrompido retoma ou outro ser\u00e1 executado.</li> <li>Registradores e contador de programa s\u00e3o restaurados \u2192 execu\u00e7\u00e3o continua.</li> </ol>"},{"location":"disciplinas/FSO/processos/#8-consideracoes-finais","title":"8. Considera\u00e7\u00f5es Finais","text":"<ul> <li>Processos s\u00e3o a unidade fundamental de execu\u00e7\u00e3o em sistemas operacionais.</li> <li>O gerenciamento de processos envolve cria\u00e7\u00e3o, execu\u00e7\u00e3o, t\u00e9rmino, troca de contexto e escalonamento.</li> <li>A abstra\u00e7\u00e3o de processos \u00e9 essencial para permitir concorr\u00eancia, isolamento e multitarefa.</li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/","title":"Sistema de Arquivos","text":""},{"location":"disciplinas/FSO/sistemaArquivos/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Arquivos:</p> <ul> <li>Permitem leitura e grava\u00e7\u00e3o de dados em discos.</li> <li>Viabilizam o compartilhamento de dados entre processos.</li> <li>S\u00e3o conjuntos de instru\u00e7\u00f5es ou dados.</li> <li>Identificados por nome.extens\u00e3o (ex.: <code>arquivo.txt</code>).</li> </ul> <p>Organiza\u00e7\u00e3o de arquivos:</p> <ul> <li>Conjunto de bytes estruturados ou n\u00e3o.</li> <li> <p>M\u00e9todos de acesso:</p> <ul> <li> <p>Acesso sequencial:</p> <ul> <li>Usado em fitas magn\u00e9ticas.</li> <li>Dados s\u00f3 podem ser lidos na ordem em que foram gravados.</li> <li>Grava\u00e7\u00e3o somente no final do arquivo.</li> <li>Exemplo: para ler o registro <code>R5</code>, \u00e9 necess\u00e1rio passar por <code>R0, R1, R2, R3, R4</code>.</li> </ul> </li> <li> <p>Acesso direto:</p> <ul> <li>Usado em discos magn\u00e9ticos.</li> <li>Permite ler ou gravar um registro diretamente, desde que se conhe\u00e7a seu n\u00famero.</li> <li>Todos os registros t\u00eam o mesmo tamanho.</li> </ul> </li> <li> <p>Acesso indexado: usa um \u00edndice (dicion\u00e1rio) acessado por chaves.</p> </li> </ul> </li> <li> <p>Opera\u00e7\u00f5es de entrada/sa\u00edda (E/S): rotinas de E/S dos sistemas de arquivos permitem:</p> <ul> <li>Traduzir endere\u00e7os.</li> <li>Ler e gravar dados.</li> <li>Criar e eliminar arquivos.</li> </ul> </li> <li> <p>Atributos:</p> <ul> <li>Informa\u00e7\u00f5es de controle sobre um arquivo.</li> <li>Exemplos: tamanho, permiss\u00f5es, autor, data de cria\u00e7\u00e3o, data de modifica\u00e7\u00e3o.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/#2-diretorios","title":"2. Diret\u00f3rios","text":"<p>Forma como o sistema organiza logicamente os arquivos.</p> <p>Tabela de arquivos:</p> <ul> <li>Cont\u00e9m todos os arquivos abertos no momento.</li> </ul> <p>Tipos de estruturas de diret\u00f3rios:</p> <ul> <li>N\u00edvel \u00fanico: um \u00fanico diret\u00f3rio para todos os arquivos e usu\u00e1rios.</li> <li> <p>UFD (User File Directory): diret\u00f3rio particular para cada usu\u00e1rio.</p> <ul> <li>MFD (Master File Directory): diret\u00f3rio principal que gerencia os diret\u00f3rios individuais.</li> <li>Path (caminho): sequ\u00eancia que referencia um arquivo dentro da hierarquia.</li> <li>Estrutura em \u00e1rvore: permite m\u00faltiplos subdiret\u00f3rios por usu\u00e1rio.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/#3-gerencia-de-espaco-livre-em-disco","title":"3. Ger\u00eancia de Espa\u00e7o Livre em Disco","text":"<p>M\u00e9todos para identificar blocos dispon\u00edveis:</p> <ul> <li>Mapa de bits.</li> <li>Lista encadeada.</li> <li>Tabela de blocos livres.</li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/#4-gerencia-de-alocacao-de-espaco","title":"4. Ger\u00eancia de Aloca\u00e7\u00e3o de Espa\u00e7o","text":"<p>Aloca\u00e7\u00e3o cont\u00edgua: Arquivo armazenado em blocos sequenciais.</p> <ul> <li> <p>Estrat\u00e9gias:</p> <ul> <li>First-fit: primeiro segmento livre de tamanho suficiente.</li> <li>Best-fit: menor segmento livre de tamanho suficiente.</li> <li>Worst-fit: maior segmento livre.</li> </ul> </li> <li> <p>Problema: fragmenta\u00e7\u00e3o.</p> </li> <li> <p>Solu\u00e7\u00e3o: desfragmenta\u00e7\u00e3o, reorganizando arquivos para concentrar o espa\u00e7o livre. Arquivos podem ter tamanhos vari\u00e1veis.</p> </li> </ul> <p>Aloca\u00e7\u00e3o encadeada:</p> <ul> <li>Arquivo organizado em blocos ligados logicamente por ponteiros.</li> <li>Elimina fragmenta\u00e7\u00e3o de espa\u00e7o livre.</li> <li> <p>Problemas:</p> <ul> <li>Fragmenta\u00e7\u00e3o do arquivo (blocos espalhados).</li> <li>Leitura lenta: necess\u00e1rio percorrer blocos em sequ\u00eancia.</li> <li>Solu\u00e7\u00e3o parcial: desfragmenta\u00e7\u00e3o para tornar blocos cont\u00edguos.</li> </ul> </li> </ul> <p>Aloca\u00e7\u00e3o indexada:</p> <ul> <li>Uso de blocos de \u00edndice.</li> <li>Permite acesso direto a qualquer bloco do arquivo.</li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/#5-protecao-de-acesso","title":"5. Prote\u00e7\u00e3o de Acesso","text":"<p>Como o disco \u00e9 compartilhado por v\u00e1rios usu\u00e1rios, \u00e9 necess\u00e1rio:</p> <ul> <li>Proteger dados gravados.</li> <li>Permitir compartilhamento controlado.</li> </ul> <p>Tipos de concess\u00f5es:</p> <ul> <li>Leitura.</li> <li>Grava\u00e7\u00e3o.</li> <li>Execu\u00e7\u00e3o.</li> <li>Exclus\u00e3o.</li> </ul> <p>Mecanismos de prote\u00e7\u00e3o:</p> <ul> <li>Senha de acesso: acesso liberado apenas com senha.</li> <li> <p>Grupos de usu\u00e1rios:</p> <ul> <li>Arquivos podem ser compartilhados dentro de um grupo.</li> <li> <p>Prote\u00e7\u00f5es definidas em tr\u00eas n\u00edveis:</p> </li> <li> <p>Owner (dono).</p> </li> <li>Group (grupo).</li> <li>All (todos).</li> </ul> </li> <li> <p>Lista de Controle de Acesso (ACL): Cada arquivo possui uma lista especificando usu\u00e1rios e seus direitos de acesso.</p> </li> </ul>"},{"location":"disciplinas/FSO/sistemaArquivos/#6-implementacao-de-caches","title":"6. Implementa\u00e7\u00e3o de Caches","text":"<p>Problema: disco \u00e9 muito mais lento que a mem\u00f3ria principal.</p> <ul> <li>Est\u00e1 fisicamente distante do processador.</li> <li>Possui partes mec\u00e2nicas.</li> <li>Discos magn\u00e9ticos s\u00e3o especialmente lentos.</li> </ul> <p>Buffer Cache:</p> <ul> <li>\u00c1rea da mem\u00f3ria principal que armazena temporariamente blocos de disco usados com frequ\u00eancia.</li> <li>Antes de acessar o disco, verifica-se primeiro no cache.</li> <li>Se n\u00e3o estiver, o acesso vai ao disco.</li> <li> <p>Pol\u00edticas de substitui\u00e7\u00e3o:</p> <ul> <li>FIFO (First In, First Out).</li> <li>LRU (Least Recently Used).</li> </ul> </li> </ul> <p>Problema de consist\u00eancia: </p> <p>Se a m\u00e1quina perder energia, dados no cache podem ser perdidos.</p> <ul> <li> <p>Solu\u00e7\u00f5es:</p> <ul> <li> <p>Atualiza\u00e7\u00e3o peri\u00f3dica: grava blocos no disco em intervalos de tempo.</p> <ul> <li>Menos opera\u00e7\u00f5es de escrita.</li> <li>Maior risco de perda em caso de falha de energia.</li> </ul> </li> <li> <p>Atualiza\u00e7\u00e3o imediata (write-through):</p> <ul> <li>Toda altera\u00e7\u00e3o no cache \u00e9 escrita imediatamente no disco.</li> <li>Mais seguro, por\u00e9m mais lento.</li> </ul> </li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/threads/","title":"Threads","text":""},{"location":"disciplinas/FSO/threads/#1-definicoes-gerais","title":"1. Defini\u00e7\u00f5es Gerais","text":""},{"location":"disciplinas/FSO/threads/#processos","title":"Processos","text":"<ul> <li>Agrupam recursos relacionados.</li> <li> <p>Cada processo possui seu pr\u00f3prio espa\u00e7o de endere\u00e7amento, incluindo:</p> </li> <li> <p>C\u00f3digo (texto)</p> </li> <li>Dados</li> <li>Arquivos abertos</li> <li>Vari\u00e1veis globais</li> <li>Processos filhos</li> <li>Rotinas de tratamento</li> <li>Gerenciamento mais simples e isolado.</li> </ul>"},{"location":"disciplinas/FSO/threads/#threads_1","title":"Threads","text":"<ul> <li>Fluxos de execu\u00e7\u00e3o independentes dentro de um mesmo processo.</li> <li>Compartilham o espa\u00e7o de endere\u00e7amento do processo.</li> <li> <p>Cada thread possui:</p> </li> <li> <p>Contador de programa</p> </li> <li>Registradores</li> <li>Pilha</li> <li>Estado</li> <li>Contexto de hardware pr\u00f3prio, mas compartilham o contexto de software.</li> </ul> <p></p> <ul> <li>Imagem A: tr\u00eas processos, cada um com seu pr\u00f3prio espa\u00e7o de endere\u00e7amento e uma thread.</li> <li>Imagem B: um processo com tr\u00eas threads que compartilham o mesmo espa\u00e7o de endere\u00e7amento.</li> </ul>"},{"location":"disciplinas/FSO/threads/#vantagens-das-threads","title":"Vantagens das Threads","text":"<ul> <li>Mais r\u00e1pidas (compartilham mem\u00f3ria, comunica\u00e7\u00e3o eficiente).</li> <li>Compartilham recursos como arquivos abertos, temporizadores, sinais.</li> <li>Melhor aproveitamento de perif\u00e9ricos (CPU, disco, rede).</li> <li> <p>Usadas em:</p> </li> <li> <p>Aplica\u00e7\u00f5es interativas (editores de texto, planilhas, processadores de imagens).</p> </li> <li>Cliente-servidor.</li> <li>N\u00facleo do sistema operacional.</li> <li>Mais f\u00e1ceis de criar e destruir que processos.</li> </ul>"},{"location":"disciplinas/FSO/threads/#desvantagens-das-threads","title":"Desvantagens das Threads","text":"<ul> <li>Compartilham vari\u00e1veis globais \u2192 risco de sobrescrita.</li> <li>Requerem sincroniza\u00e7\u00e3o para evitar inconsist\u00eancias.</li> </ul>"},{"location":"disciplinas/FSO/threads/#2-multiprogramacao-e-threads","title":"2. Multiprograma\u00e7\u00e3o e Threads","text":"<ul> <li>Multiprograma\u00e7\u00e3o pode gerar problemas quando threads compartilham recursos.</li> <li> <p>Exemplos de riscos:</p> </li> <li> <p>Fechar arquivo ainda em uso por outra thread.</p> </li> <li>Depura\u00e7\u00e3o complexa.</li> <li>Condi\u00e7\u00f5es de corrida.</li> </ul>"},{"location":"disciplinas/FSO/threads/#3-implementacao-de-threads","title":"3. Implementa\u00e7\u00e3o de Threads","text":""},{"location":"disciplinas/FSO/threads/#31-em-modo-usuario","title":"3.1 Em Modo Usu\u00e1rio","text":"<ul> <li>Threads gerenciadas pela aplica\u00e7\u00e3o, n\u00e3o pelo SO.</li> <li> <p>Requer biblioteca de rotinas para:</p> </li> <li> <p>Cria\u00e7\u00e3o/elimina\u00e7\u00e3o de threads.</p> </li> <li>Comunica\u00e7\u00e3o entre threads.</li> <li>Pol\u00edticas de escalonamento.</li> <li> <p>Vantagens:</p> </li> <li> <p>Funciona mesmo em SO sem suporte nativo.</p> </li> <li>Mais r\u00e1pidas.</li> <li> <p>Desvantagens:</p> </li> <li> <p>SO enxerga apenas um processo.</p> </li> <li>Se uma thread \u00e9 bloqueada em chamada de sistema, todas ficam bloqueadas.</li> <li>Tratamento de sinais \u00e9 complexo.</li> </ul>"},{"location":"disciplinas/FSO/threads/#32-em-modo-kernel","title":"3.2 Em Modo Kernel","text":"<ul> <li>Threads implementadas diretamente pelo kernel.</li> <li>SO conhece e gerencia cada thread individualmente.</li> <li>Permite escalonamento separado para cada thread.</li> </ul>"},{"location":"disciplinas/FSO/threads/#33-modelo-hibrido","title":"3.3 Modelo H\u00edbrido","text":"<ul> <li>Combina os dois modelos.</li> <li>Cada Thread em Modo Kernel (TMK) pode gerenciar v\u00e1rias Threads em Modo Usu\u00e1rio (TMU).</li> <li>Vantagens: flexibilidade.</li> <li>Desvantagens: desempenho menor devido a mudan\u00e7as frequentes de modo.</li> </ul>"},{"location":"disciplinas/FSO/threads/#4-modelo-de-execucao-de-threads","title":"4. Modelo de Execu\u00e7\u00e3o de Threads","text":"<ul> <li>Threads din\u00e2micas: criadas sob demanda, uma para cada requisi\u00e7\u00e3o.</li> <li>Threads est\u00e1ticas: n\u00famero fixo de threads definido previamente.</li> </ul>"},{"location":"disciplinas/FSO/threads/#5-padroes-de-projeto-com-threads","title":"5. Padr\u00f5es de Projeto com Threads","text":""},{"location":"disciplinas/FSO/threads/#51-dispatcherworker-despachantetrabalhador","title":"5.1 Dispatcher/Worker (Despachante/Trabalhador)","text":"<ul> <li>Uma thread despachante recebe tarefas e as distribui para threads trabalhadoras.</li> <li>Exemplo: servidor web.</li> <li>Vantagens: balanceamento eficiente, consumo r\u00e1pido de requisi\u00e7\u00f5es.</li> <li>Desvantagem: risco de sobrecarga na thread despachante.</li> </ul>"},{"location":"disciplinas/FSO/threads/#52-thread-pool-time-de-threads","title":"5.2 Thread Pool (Time de Threads)","text":"<ul> <li>Conjunto fixo de threads que retiram tarefas de um reposit\u00f3rio/pool.</li> <li> <p>Vantagens:</p> </li> <li> <p>Boa distribui\u00e7\u00e3o de carga.</p> </li> <li>N\u00e3o h\u00e1 necessidade de criar/destruir threads constantemente.</li> <li>Flexibilidade para ajustar o n\u00famero de threads.</li> <li>Desvantagem: implementa\u00e7\u00e3o cuidadosa necess\u00e1ria.</li> </ul>"},{"location":"disciplinas/FSO/threads/#53-pipeline","title":"5.3 Pipeline","text":"<ul> <li>Cada thread executa uma etapa de um processo sequencial.</li> <li>A sa\u00edda de uma \u00e9 a entrada da pr\u00f3xima.</li> <li> <p>Desvantagens:</p> </li> <li> <p>Gargalo se uma etapa for lenta.</p> </li> <li>Nem sempre \u00e9 f\u00e1cil dividir tarefas em pipeline.</li> </ul>"},{"location":"disciplinas/FSO/threads/#6-consideracoes-finais","title":"6. Considera\u00e7\u00f5es Finais","text":"<ul> <li>Threads permitem concorr\u00eancia dentro de processos, otimizando recursos.</li> <li>Reduzem custo de cria\u00e7\u00e3o/gerenciamento em compara\u00e7\u00e3o com processos.</li> <li>Demandam sincroniza\u00e7\u00e3o robusta para evitar erros como condi\u00e7\u00f5es de corrida.</li> <li>Diferentes modelos de implementa\u00e7\u00e3o (usu\u00e1rio, kernel, h\u00edbrido) trazem vantagens e limita\u00e7\u00f5es.</li> </ul>"},{"location":"disciplinas/FSO/unix/","title":"Fundamentos UNIX","text":""},{"location":"disciplinas/FSO/unix/#1-criacao-de-processos","title":"1. Cria\u00e7\u00e3o de Processos","text":""},{"location":"disciplinas/FSO/unix/#11-identificadores","title":"1.1 Identificadores","text":"<ul> <li>pid (process id): identificador \u00fanico de um processo.</li> <li>ppid (parent process id): identificador do processo pai.</li> </ul> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t meupid = getpid();\n    printf(\"Pid atual do processo: %d\\n\", meupid);\n\n    pid_t pidpai = getppid();\n    printf(\"Pid do pai do processo: %d\\n\", pidpai);\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/FSO/unix/#12-fork","title":"1.2 fork()","text":"<ul> <li>Cria uma c\u00f3pia do processo atual (pai \u2192 filho).</li> <li>Pai e filho continuam a execu\u00e7\u00e3o do mesmo ponto.</li> <li> <p>O filho herda quase toda a tabela de processos do pai.</p> </li> <li> <p>Retorno:</p> <ul> <li>0 \u2192 processo filho.</li> <li>pid do filho \u2192 processo pai.</li> </ul> </li> </ul> Exemplo:<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t id_filho;\n\n    printf(\"Processo inicial possui pid: %d\\n\", getpid());\n    id_filho = fork();\n    if (id_filho == 0)\n        printf(\"Ol\u00e1, sou o processo filho de pid: %d!\\n\", getpid());\n    else\n        printf(\"Ol\u00e1, sou o processo pai (%d) e criei o filho: %d!\\n\", getpid(), id_filho);\n    return 0;\n}\n\n// Sa\u00edda esperada:\n// Processo inicial possui pid: 16370\n// Ol\u00e1, sou o processo pai (16370) e criei o filho: 16371!\n// Ol\u00e1, sou o processo filho de pid: 16371!\n</code></pre>"},{"location":"disciplinas/FSO/unix/#2-carga-de-arquivo-executavel","title":"2. Carga de Arquivo Execut\u00e1vel","text":"<ul> <li>fork(): cria processos por clonagem (mesmo programa).</li> <li> <p>exec(): substitui o processo atual por um novo programa.</p> </li> <li> <p>O pid continua o mesmo, mas c\u00f3digo e dados s\u00e3o substitu\u00eddos.</p> </li> <li>Retorna apenas em caso de falha.</li> <li> <p>Em caso de sucesso:</p> <ul> <li>C\u00f3digo do programa atual \u00e9 descartado.</li> <li>O processo carrega o novo programa na mem\u00f3ria.</li> <li>A execu\u00e7\u00e3o come\u00e7a do in\u00edcio (<code>main()</code>).</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/unix/#21-familias-de-funcoes-exec","title":"2.1 Fam\u00edlias de fun\u00e7\u00f5es exec","text":"<p>Formas de passar argumentos:</p> <ul> <li><code>v</code>: argumentos em vetor \u2192 <code>execv(\"/bin/ls\", argv)</code>.</li> <li><code>l</code>: argumentos em lista variada \u2192 <code>execl(\"/bin/ls\", \"ls\", \"-l\", NULL)</code>.</li> </ul> <p>Onde procurar o programa:</p> <ul> <li><code>p</code>: procura no PATH \u2192 <code>execlp(\"ls\", \"ls\", \"-l\", NULL)</code>.</li> <li>sem <code>p</code>: exige caminho completo \u2192 <code>execl(\"/bin/ls\", \"ls\", \"-l\", NULL)</code>.</li> </ul> <p>Vari\u00e1veis de ambiente:</p> <ul> <li>Com <code>e</code>: permite passar vari\u00e1veis de ambiente.</li> <li>Sem <code>e</code>: herda o ambiente do processo atual.</li> </ul>"},{"location":"disciplinas/FSO/unix/#3-sinais","title":"3. Sinais","text":""},{"location":"disciplinas/FSO/unix/#31-o-que-sao","title":"3.1 O que s\u00e3o","text":"<ul> <li>Mecanismo do UNIX para comunica\u00e7\u00e3o entre processos.</li> <li>Alteram o comportamento do processo alvo.</li> <li> <p>Ao receber um sinal, o processo pode:</p> </li> <li> <p>Ser interrompido e executar um handler (fun\u00e7\u00e3o tratadora).</p> </li> <li>Ignorar o sinal.</li> </ul>"},{"location":"disciplinas/FSO/unix/#32-exemplos-de-sinais","title":"3.2 Exemplos de sinais","text":"<ul> <li><code>SIGTERM</code>: Terminar (padr\u00e3o).</li> <li><code>SIGKILL</code>: Finaliza\u00e7\u00e3o for\u00e7ada (n\u00e3o pode ser ignorado).</li> <li><code>SIGUSR1</code>, <code>SIGUSR2</code>: Uso definido pelo usu\u00e1rio.</li> <li><code>SIGSEGV</code>: Acesso inv\u00e1lido \u00e0 mem\u00f3ria (segfault).</li> <li><code>SIGFPE</code>: Erro de ponto flutuante.</li> </ul>"},{"location":"disciplinas/FSO/unix/#33-envio-de-sinais","title":"3.3 Envio de sinais","text":"<p>Pelo terminal:</p> <ol> <li>Executar o programa.</li> <li>Encontrar o pid com <code>ps aux | grep nome_do_programa</code>.</li> <li>Enviar sinal: <code>kill -SIGUSR1 2240</code>.</li> </ol> <p>No c\u00f3digo em C:</p> <pre><code>    ```c\n    kill(pid_filho, SIGUSR1);\n    ```\n</code></pre>"},{"location":"disciplinas/FSO/unix/#34-exemplo-completo","title":"3.4 Exemplo completo","text":"Exemplo:<pre><code>#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n\nint contador = 0;\n\nvoid handler(int signal_number) {\n    contador++;\n}\n\nint main() {\n    struct sigaction sa = {};\n    sa.sa_handler = &amp;handler; // define o tratador\n    sigaction(SIGUSR1, &amp;sa, NULL);\n    // Quando esse processo receber SIGUSR1, executa handler\n\n    printf(\"Pressione E para terminar a execu\u00e7\u00e3o:\\n\");\n\n    while (getchar() != 'E') ;\n\n    printf(\"SIGUSR1 recebido %d vezes\\n\", contador);\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/FSO/unix/#4-termino-de-processos","title":"4. T\u00e9rmino de Processos","text":""},{"location":"disciplinas/FSO/unix/#41-formas-de-termino","title":"4.1 Formas de t\u00e9rmino","text":"<p>Por sinais: <code>SIGTERM</code>, <code>SIGKILL</code>.</p> <p>Voluntariamente:</p> <ul> <li>Retornando da fun\u00e7\u00e3o <code>main</code>.</li> <li>Chamando <code>exit()</code>:<ul> <li><code>exit(0)</code>: sucesso.</li> <li><code>exit(1)</code>: erro.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/unix/#42-comunicacao-com-processo-pai","title":"4.2 Comunica\u00e7\u00e3o com processo pai","text":"<ul> <li>wait(): processo pai bloqueia at\u00e9 o filho terminar.</li> <li>pause(): processo atual pausa at\u00e9 receber sinal.</li> <li> <p>Macros \u00fateis:</p> <ul> <li><code>WIFEXITED(status)</code>: verifica se o filho terminou normalmente.</li> <li><code>WEXITSTATUS(status)</code>: obt\u00e9m valor de retorno do filho.</li> </ul> </li> </ul>"},{"location":"disciplinas/FSO/unix/#43-processos-zumbis","title":"4.3 Processos Zumbis","text":"<p>Normal: pai cria filho, depois chama <code>wait()</code> para receber informa\u00e7\u00f5es de t\u00e9rmino.</p> <p>Zumbi: filho termina, mas o pai n\u00e3o chama <code>wait()</code>. O processo permanece na tabela como \"zumbi\" at\u00e9 o pai coletar seu status.</p> Exemplo:<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t filho;\n\n    filho = fork();\n    if (filho &gt; 0)\n        sleep(6);\n    else\n        exit(0);\n    wait(NULL); // elimina o zumbi\n    return 0;\n}\n</code></pre>"},{"location":"disciplinas/FSO/unix/#5-consideracoes-finais","title":"5. Considera\u00e7\u00f5es Finais","text":"<ul> <li>fork + exec s\u00e3o a base para cria\u00e7\u00e3o e substitui\u00e7\u00e3o de processos no UNIX.</li> <li>Sinais permitem comunica\u00e7\u00e3o e controle.</li> <li>O gerenciamento de t\u00e9rmino \u00e9 essencial para evitar processos zumbis.</li> </ul>"}]}